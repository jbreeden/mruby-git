#include "mruby_Git.h"

/* MRUBY_BINDING: header */
/* sha: user_defined */

/* MRUBY_BINDING_END */

#ifdef __cplusplus
extern "C" {
#endif

/* MRUBY_BINDING: git_annotated_commit_free */
/* sha: c10baf7d74ff0b9957c2dad680ed77de3deddc377ee224662800d4bc0eb5ad87 */
#if BIND_git_annotated_commit_free_FUNCTION
#define git_annotated_commit_free_REQUIRED_ARGC 1
#define git_annotated_commit_free_OPTIONAL_ARGC 0
/* git_annotated_commit_free
 *
 * Parameters:
 * - commit: git_annotated_commit *
 * Return Type: void
 */
mrb_value
mrb_Git_git_annotated_commit_free(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  git_annotated_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_annotated_commit(commit));

  /* Invocation */
  git_annotated_commit_free(native_commit);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_annotated_commit_from_fetchhead */
/* sha: d731a8725f62fe926b78bd708fda2e83bcb98f67ad9ffeafe9f973c3aa3eb981 */
#if BIND_git_annotated_commit_from_fetchhead_FUNCTION
#define git_annotated_commit_from_fetchhead_REQUIRED_ARGC 4
#define git_annotated_commit_from_fetchhead_OPTIONAL_ARGC 0
/* git_annotated_commit_from_fetchhead
 *
 * Parameters:
 * - repo: git_repository *
 * - branch_name: const char *
 * - remote_url: const char *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_annotated_commit_from_fetchhead(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_annotated_commit * native_out = NULL;
  mrb_value repo;
  char * native_branch_name = NULL;
  char * native_remote_url = NULL;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzo", &repo, &native_branch_name, &native_remote_url, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_annotated_commit_from_fetchhead(&native_out, native_repo, native_branch_name, native_remote_url, native_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_annotated_commit(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_annotated_commit_from_ref */
/* sha: 47b4eddfbe5779ba24281ace84907adc4962f5fbb1f57105b6182a4a2a2ff392 */
#if BIND_git_annotated_commit_from_ref_FUNCTION
#define git_annotated_commit_from_ref_REQUIRED_ARGC 2
#define git_annotated_commit_from_ref_OPTIONAL_ARGC 0
/* git_annotated_commit_from_ref
 *
 * Parameters:
 * - repo: git_repository *
 * - ref: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_annotated_commit_from_ref(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_annotated_commit * native_out = NULL;
  mrb_value repo;
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_annotated_commit_from_ref(&native_out, native_repo, native_ref);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_annotated_commit(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_annotated_commit_from_revspec */
/* sha: aa4c867d8c1e67df7d6e5b16baa8842f10ded91266f5ea0d834a5d48a38b0da0 */
#if BIND_git_annotated_commit_from_revspec_FUNCTION
#define git_annotated_commit_from_revspec_REQUIRED_ARGC 2
#define git_annotated_commit_from_revspec_OPTIONAL_ARGC 0
/* git_annotated_commit_from_revspec
 *
 * Parameters:
 * - repo: git_repository *
 * - revspec: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_annotated_commit_from_revspec(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_annotated_commit * native_out = NULL;
  mrb_value repo;
  char * native_revspec = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_revspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_annotated_commit_from_revspec(&native_out, native_repo, native_revspec);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_annotated_commit(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_annotated_commit_id */
/* sha: 03aac0a4fd8cc604fa9cd0334de237690566b81f0931152451681720f820288d */
#if BIND_git_annotated_commit_id_FUNCTION
#define git_annotated_commit_id_REQUIRED_ARGC 1
#define git_annotated_commit_id_OPTIONAL_ARGC 0
/* git_annotated_commit_id
 *
 * Parameters:
 * - commit: const git_annotated_commit *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_annotated_commit_id(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_annotated_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_annotated_commit(commit));

  /* Invocation */
  const git_oid * native_return_value = git_annotated_commit_id(native_commit);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_annotated_commit_lookup */
/* sha: bdb5fa73462952a3ff620ae2f3392aaf70a2a7f6afa4341de82fd4d003d6cb95 */
#if BIND_git_annotated_commit_lookup_FUNCTION
#define git_annotated_commit_lookup_REQUIRED_ARGC 2
#define git_annotated_commit_lookup_OPTIONAL_ARGC 0
/* git_annotated_commit_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_annotated_commit_lookup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_annotated_commit * native_out = NULL;
  mrb_value repo;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_annotated_commit_lookup(&native_out, native_repo, native_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_annotated_commit(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_attr_add_macro */
/* sha: 7543cd3acd0b38de12163fe6f9daec36846d330567d26545ad4c111beffdc97b */
#if BIND_git_attr_add_macro_FUNCTION
#define git_attr_add_macro_REQUIRED_ARGC 3
#define git_attr_add_macro_OPTIONAL_ARGC 0
/* git_attr_add_macro
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - values: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_attr_add_macro(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_name = NULL;
  char * native_values = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_name, &native_values);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_attr_add_macro(native_repo, native_name, native_values);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_attr_cache_flush */
/* sha: 06ab8bcb73a66e6e03b44c29654356edb8528e60e5d15493b23828c8cf482979 */
#if BIND_git_attr_cache_flush_FUNCTION
#define git_attr_cache_flush_REQUIRED_ARGC 1
#define git_attr_cache_flush_OPTIONAL_ARGC 0
/* git_attr_cache_flush
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: void
 */
mrb_value
mrb_Git_git_attr_cache_flush(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  git_attr_cache_flush(native_repo);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_attr_foreach */
/* sha: 72ba832edb7d2cc392fb97a681b0b7d37eb09c374155699c470ff6f0f89b200f */
#if BIND_git_attr_foreach_FUNCTION
#define git_attr_foreach_REQUIRED_ARGC 5
#define git_attr_foreach_OPTIONAL_ARGC 0
/* git_attr_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - flags: uint32_t
 * - path: const char *
 * - callback: git_attr_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_attr_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_int native_flags;
  char * native_path = NULL;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oizoo", &repo, &native_flags, &native_path, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  int (*native_callback)(const char *, const char *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_attr_foreach(native_repo, native_flags, native_path, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_attr_get */
/* sha: 873d346196793083e49d3a7aa77882a80301027efaa3d0205dfa8278bed90637 */
#if BIND_git_attr_get_FUNCTION
#define git_attr_get_REQUIRED_ARGC 4
#define git_attr_get_OPTIONAL_ARGC 0
/* git_attr_get
 *
 * Parameters:
 * - repo: git_repository *
 * - flags: uint32_t
 * - path: const char *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_attr_get(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_value_out = NULL;
  mrb_value repo;
  mrb_int native_flags;
  char * native_path = NULL;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oizz", &repo, &native_flags, &native_path, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_attr_get(&native_value_out, native_repo, native_flags, native_path, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: value_out */
  mrb_value value_out = native_value_out ==  NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_value_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, value_out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_attr_get_many */
/* sha: 1e2e0a961ed6ae7590f38bb48ae9698345aed18e28b504de37271c0af158ef04 */
#if BIND_git_attr_get_many_FUNCTION
#define git_attr_get_many_REQUIRED_ARGC 6
#define git_attr_get_many_OPTIONAL_ARGC 0
/* git_attr_get_many
 *
 * Parameters:
 * - values_out: const char **
 * - repo: git_repository *
 * - flags: uint32_t
 * - path: const char *
 * - num_attr: size_t
 * - names: const char **
 * Return Type: int
 */
mrb_value
mrb_Git_git_attr_get_many(mrb_state* mrb, mrb_value self) {
  mrb_value values_out;
  mrb_value repo;
  mrb_int native_flags;
  char * native_path = NULL;
  mrb_int native_num_attr;
  mrb_value names;

  /* Fetch the args */
  mrb_get_args(mrb, "ooizio", &values_out, &repo, &native_flags, &native_path, &native_num_attr, &names);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(values_out);
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_PTR(names);

  /* Unbox param: values_out */
  const char ** native_values_out = TODO_mruby_unbox_char_PTR_PTR(values_out);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: names */
  const char ** native_names = TODO_mruby_unbox_char_PTR_PTR(names);

  /* Invocation */
  int native_return_value = git_attr_get_many(native_values_out, native_repo, native_flags, native_path, native_num_attr, native_names);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_attr_value */
/* sha: aa487003555e3ef7b4d32d313cb98152218e21f7d4ce94425fb1c69b436508b9 */
#if BIND_git_attr_value_FUNCTION
#define git_attr_value_REQUIRED_ARGC 1
#define git_attr_value_OPTIONAL_ARGC 0
/* git_attr_value
 *
 * Parameters:
 * - attr: const char *
 * Return Type: git_attr_t
 */
mrb_value
mrb_Git_git_attr_value(mrb_state* mrb, mrb_value self) {
  char * native_attr = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_attr);

  /* Invocation */
  git_attr_t native_return_value = git_attr_value(native_attr);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blame_buffer */
/* sha: cee8939246c0b1a0fd9bc751830f73514b08b653cbb514a36cf957ff3598379f */
#if BIND_git_blame_buffer_FUNCTION
#define git_blame_buffer_REQUIRED_ARGC 3
#define git_blame_buffer_OPTIONAL_ARGC 0
/* git_blame_buffer
 *
 * Parameters:
 * - reference: git_blame *
 * - buffer: const char *
 * - buffer_len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_blame_buffer(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_blame * native_out = NULL;
  mrb_value reference;
  char * native_buffer = NULL;
  mrb_int native_buffer_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &reference, &native_buffer, &native_buffer_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, reference, Blame_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blame expected");
    return mrb_nil_value();
  }

  /* Unbox param: reference */
  git_blame * native_reference = (mrb_nil_p(reference) ? NULL : mruby_unbox_git_blame(reference));

  /* Invocation */
  int native_return_value = git_blame_buffer(&native_out, native_reference, native_buffer, native_buffer_len);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_blame(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blame_file */
/* sha: 0b1e3198028f2e4fe4ffc30b1b152118b80a2574ad51676caf113597c04634eb */
#if BIND_git_blame_file_FUNCTION
#define git_blame_file_REQUIRED_ARGC 3
#define git_blame_file_OPTIONAL_ARGC 0
/* git_blame_file
 *
 * Parameters:
 * - repo: git_repository *
 * - path: const char *
 * - options: git_blame_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_blame_file(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_blame * native_out = NULL;
  mrb_value repo;
  char * native_path = NULL;
  mrb_value options;

  /* Fetch the args */
  mrb_get_args(mrb, "ozo", &repo, &native_path, &options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, options, BlameOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "BlameOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: options */
  git_blame_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_blame_options(options));

  /* Invocation */
  int native_return_value = git_blame_file(&native_out, native_repo, native_path, native_options);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_blame(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blame_free */
/* sha: 1b57908a45f2826eb88205486f3d228fcbf435982ec3c3f1f2ddea8fcab4cc2b */
#if BIND_git_blame_free_FUNCTION
#define git_blame_free_REQUIRED_ARGC 1
#define git_blame_free_OPTIONAL_ARGC 0
/* git_blame_free
 *
 * Parameters:
 * - blame: git_blame *
 * Return Type: void
 */
mrb_value
mrb_Git_git_blame_free(mrb_state* mrb, mrb_value self) {
  mrb_value blame;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blame);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blame, Blame_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blame expected");
    return mrb_nil_value();
  }

  /* Unbox param: blame */
  git_blame * native_blame = (mrb_nil_p(blame) ? NULL : mruby_unbox_git_blame(blame));

  /* Invocation */
  git_blame_free(native_blame);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blame_get_hunk_byindex */
/* sha: c0617822a989e5f3144a46ce55bc378335d4010697f44d7bdd33e194bdf3b47f */
#if BIND_git_blame_get_hunk_byindex_FUNCTION
#define git_blame_get_hunk_byindex_REQUIRED_ARGC 2
#define git_blame_get_hunk_byindex_OPTIONAL_ARGC 0
/* git_blame_get_hunk_byindex
 *
 * Parameters:
 * - blame: git_blame *
 * - index: uint32_t
 * Return Type: const git_blame_hunk *
 */
mrb_value
mrb_Git_git_blame_get_hunk_byindex(mrb_state* mrb, mrb_value self) {
  mrb_value blame;
  mrb_int native_index;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &blame, &native_index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blame, Blame_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blame expected");
    return mrb_nil_value();
  }

  /* Unbox param: blame */
  git_blame * native_blame = (mrb_nil_p(blame) ? NULL : mruby_unbox_git_blame(blame));

  /* Invocation */
  const git_blame_hunk * native_return_value = git_blame_get_hunk_byindex(native_blame, native_index);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_blame_hunk(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blame_get_hunk_byline */
/* sha: 6db3ad327fd85c4b9147929b14693d78b52df57bffe6fa668bb8c5c2a15c9905 */
#if BIND_git_blame_get_hunk_byline_FUNCTION
#define git_blame_get_hunk_byline_REQUIRED_ARGC 2
#define git_blame_get_hunk_byline_OPTIONAL_ARGC 0
/* git_blame_get_hunk_byline
 *
 * Parameters:
 * - blame: git_blame *
 * - lineno: size_t
 * Return Type: const git_blame_hunk *
 */
mrb_value
mrb_Git_git_blame_get_hunk_byline(mrb_state* mrb, mrb_value self) {
  mrb_value blame;
  mrb_int native_lineno;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &blame, &native_lineno);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blame, Blame_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blame expected");
    return mrb_nil_value();
  }

  /* Unbox param: blame */
  git_blame * native_blame = (mrb_nil_p(blame) ? NULL : mruby_unbox_git_blame(blame));

  /* Invocation */
  const git_blame_hunk * native_return_value = git_blame_get_hunk_byline(native_blame, native_lineno);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_blame_hunk(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blame_get_hunk_count */
/* sha: be71c2091e98575d45968474ac4ae42431cac959c7668db9ae554806e15d7835 */
#if BIND_git_blame_get_hunk_count_FUNCTION
#define git_blame_get_hunk_count_REQUIRED_ARGC 1
#define git_blame_get_hunk_count_OPTIONAL_ARGC 0
/* git_blame_get_hunk_count
 *
 * Parameters:
 * - blame: git_blame *
 * Return Type: uint32_t
 */
mrb_value
mrb_Git_git_blame_get_hunk_count(mrb_state* mrb, mrb_value self) {
  mrb_value blame;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blame);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blame, Blame_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blame expected");
    return mrb_nil_value();
  }

  /* Unbox param: blame */
  git_blame * native_blame = (mrb_nil_p(blame) ? NULL : mruby_unbox_git_blame(blame));

  /* Invocation */
  uint32_t native_return_value = git_blame_get_hunk_count(native_blame);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blame_init_options */
/* sha: c09da1e3b03fbca34883d10e2ce0cd83b518cc46e9e7c73b6c199ac3f6441da8 */
#if BIND_git_blame_init_options_FUNCTION
#define git_blame_init_options_REQUIRED_ARGC 2
#define git_blame_init_options_OPTIONAL_ARGC 0
/* git_blame_init_options
 *
 * Parameters:
 * - opts: git_blame_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_blame_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, BlameOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "BlameOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_blame_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_blame_options(opts));

  /* Invocation */
  int native_return_value = git_blame_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_create_frombuffer */
/* sha: eea93e56dc8f3ad24e5142cd1d003b95479703315ed27af20183fd8029bf9046 */
#if BIND_git_blob_create_frombuffer_FUNCTION
#define git_blob_create_frombuffer_REQUIRED_ARGC 3
#define git_blob_create_frombuffer_OPTIONAL_ARGC 0
/* git_blob_create_frombuffer
 *
 * Parameters:
 * - id: git_oid *
 * - repo: git_repository *
 * - buffer: const void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_create_frombuffer(mrb_state* mrb, mrb_value self) {
  mrb_value id;
  mrb_value repo;
  mrb_value native_buffer;

  /* Fetch the args */
  mrb_get_args(mrb, "ooS", &id, &repo, &native_buffer);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: id */
  git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_blob_create_frombuffer(native_id, native_repo, RSTRING_PTR(native_buffer), RSTRING_LEN(native_buffer));

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_create_fromchunks */
/* sha: bd22aa83b59d4437c85e70fc2b2fc663fcd614e8ec72fed4227b1db6aec47dd4 */
#if BIND_git_blob_create_fromchunks_FUNCTION
#define git_blob_create_fromchunks_REQUIRED_ARGC 5
#define git_blob_create_fromchunks_OPTIONAL_ARGC 0
/* git_blob_create_fromchunks
 *
 * Parameters:
 * - id: git_oid *
 * - repo: git_repository *
 * - hintpath: const char *
 * - callback: git_blob_chunk_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_create_fromchunks(mrb_state* mrb, mrb_value self) {
  mrb_value id;
  mrb_value repo;
  char * native_hintpath = NULL;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oozoo", &id, &repo, &native_hintpath, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_blob_chunk_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: id */
  git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_blob_chunk_cb native_callback = TODO_mruby_unbox_git_blob_chunk_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_blob_create_fromchunks(native_id, native_repo, native_hintpath, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_create_fromdisk */
/* sha: ab1d4208c3fa2b85e6fc951b49f5fb7eb2720c02363e93904115e5aaf69307c7 */
#if BIND_git_blob_create_fromdisk_FUNCTION
#define git_blob_create_fromdisk_REQUIRED_ARGC 3
#define git_blob_create_fromdisk_OPTIONAL_ARGC 0
/* git_blob_create_fromdisk
 *
 * Parameters:
 * - id: git_oid *
 * - repo: git_repository *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_create_fromdisk(mrb_state* mrb, mrb_value self) {
  mrb_value id;
  mrb_value repo;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &id, &repo, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: id */
  git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_blob_create_fromdisk(native_id, native_repo, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_create_fromworkdir */
/* sha: 555fd5fc7f4cfd4eaf7cabd2dc93ebe72dc2ddf471aed6c9b68ad3f1a7a4cb93 */
#if BIND_git_blob_create_fromworkdir_FUNCTION
#define git_blob_create_fromworkdir_REQUIRED_ARGC 3
#define git_blob_create_fromworkdir_OPTIONAL_ARGC 0
/* git_blob_create_fromworkdir
 *
 * Parameters:
 * - id: git_oid *
 * - repo: git_repository *
 * - relative_path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_create_fromworkdir(mrb_state* mrb, mrb_value self) {
  mrb_value id;
  mrb_value repo;
  char * native_relative_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &id, &repo, &native_relative_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: id */
  git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_blob_create_fromworkdir(native_id, native_repo, native_relative_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_filtered_content */
/* sha: 5325b33841e227bb9fa48bf1cff1a82bd0b03b8ca9bcc67138195514f0086e11 */
#if BIND_git_blob_filtered_content_FUNCTION
#define git_blob_filtered_content_REQUIRED_ARGC 4
#define git_blob_filtered_content_OPTIONAL_ARGC 0
/* git_blob_filtered_content
 *
 * Parameters:
 * - out: git_buf *
 * - blob: git_blob *
 * - as_path: const char *
 * - check_for_binary_data: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_filtered_content(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value blob;
  char * native_as_path = NULL;
  mrb_int native_check_for_binary_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oozi", &out, &blob, &native_as_path, &native_check_for_binary_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: blob */
  git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  int native_return_value = git_blob_filtered_content(native_out, native_blob, native_as_path, native_check_for_binary_data);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_free */
/* sha: 3744d2bfbb352180afe3ed04719d78a9150ea254b5c58f3c8d8d9e1cbf9decfe */
#if BIND_git_blob_free_FUNCTION
#define git_blob_free_REQUIRED_ARGC 1
#define git_blob_free_OPTIONAL_ARGC 0
/* git_blob_free
 *
 * Parameters:
 * - blob: git_blob *
 * Return Type: void
 */
mrb_value
mrb_Git_git_blob_free(mrb_state* mrb, mrb_value self) {
  mrb_value blob;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: blob */
  git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  git_blob_free(native_blob);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_id */
/* sha: b5b29714d61b778872f26ffc811953341159921eda09351ee33ebcde2cf53e9c */
#if BIND_git_blob_id_FUNCTION
#define git_blob_id_REQUIRED_ARGC 1
#define git_blob_id_OPTIONAL_ARGC 0
/* git_blob_id
 *
 * Parameters:
 * - blob: const git_blob *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_blob_id(mrb_state* mrb, mrb_value self) {
  mrb_value blob;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: blob */
  const git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  const git_oid * native_return_value = git_blob_id(native_blob);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_is_binary */
/* sha: bf56e27efde75443e7e8f460ed857f3e015b5731b43706d4e6b22761d2cb0b03 */
#if BIND_git_blob_is_binary_FUNCTION
#define git_blob_is_binary_REQUIRED_ARGC 1
#define git_blob_is_binary_OPTIONAL_ARGC 0
/* git_blob_is_binary
 *
 * Parameters:
 * - blob: const git_blob *
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_is_binary(mrb_state* mrb, mrb_value self) {
  mrb_value blob;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: blob */
  const git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  int native_return_value = git_blob_is_binary(native_blob);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_lookup */
/* sha: b7947ad10a555ee9e201f1a100b93151e6099be5e533e0568c54ef0329ec88db */
#if BIND_git_blob_lookup_FUNCTION
#define git_blob_lookup_REQUIRED_ARGC 2
#define git_blob_lookup_OPTIONAL_ARGC 0
/* git_blob_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_lookup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_blob * native_blob = NULL;
  mrb_value repo;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_blob_lookup(&native_blob, native_repo, native_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: blob */
  mrb_value blob = native_blob == NULL ? mrb_nil_value() : mruby_giftwrap_git_blob(mrb, native_blob);

  /* Add out params to results */
  mrb_ary_push(mrb, results, blob);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_lookup_prefix */
/* sha: 47597f6c99b849dacbf820507d0634d3308b89542ab2d392c114e770e949b55b */
#if BIND_git_blob_lookup_prefix_FUNCTION
#define git_blob_lookup_prefix_REQUIRED_ARGC 3
#define git_blob_lookup_prefix_OPTIONAL_ARGC 0
/* git_blob_lookup_prefix
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_lookup_prefix(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_blob * native_blob = NULL;
  mrb_value repo;
  mrb_value id;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &repo, &id, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_blob_lookup_prefix(&native_blob, native_repo, native_id, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: blob */
  mrb_value blob = native_blob == NULL ? mrb_nil_value() : mruby_giftwrap_git_blob(mrb, native_blob);

  /* Add out params to results */
  mrb_ary_push(mrb, results, blob);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_owner */
/* sha: 101b87a1ab77b319d5b62b43b8d05b93eb02d35cb3017b33ddb7eee9a29890ba */
#if BIND_git_blob_owner_FUNCTION
#define git_blob_owner_REQUIRED_ARGC 1
#define git_blob_owner_OPTIONAL_ARGC 0
/* git_blob_owner
 *
 * Parameters:
 * - blob: const git_blob *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_blob_owner(mrb_state* mrb, mrb_value self) {
  mrb_value blob;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: blob */
  const git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  git_repository * native_return_value = git_blob_owner(native_blob);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_rawcontent */
/* sha: b2a3a017925156cbd6e918dc4690ee3354917ad5267f78949c2f5367d15f995c */
#if BIND_git_blob_rawcontent_FUNCTION
#define git_blob_rawcontent_REQUIRED_ARGC 1
#define git_blob_rawcontent_OPTIONAL_ARGC 0
/* git_blob_rawcontent
 *
 * Parameters:
 * - blob: const git_blob *
 * Return Type: const void *
 */
mrb_value
mrb_Git_git_blob_rawcontent(mrb_state* mrb, mrb_value self) {
  mrb_value blob;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: blob */
  const git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  const void * native_return_value = git_blob_rawcontent(native_blob);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_void_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_rawsize */
/* sha: ba5e16b3937112d5802e80bff2ddd0a4a05d203ec7b36a3296a2031599619f28 */
#if BIND_git_blob_rawsize_FUNCTION
#define git_blob_rawsize_REQUIRED_ARGC 1
#define git_blob_rawsize_OPTIONAL_ARGC 0
/* git_blob_rawsize
 *
 * Parameters:
 * - blob: const git_blob *
 * Return Type: git_off_t
 */
mrb_value
mrb_Git_git_blob_rawsize(mrb_state* mrb, mrb_value self) {
  mrb_value blob;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: blob */
  const git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  git_off_t native_return_value = git_blob_rawsize(native_blob);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_create */
/* sha: 2b03b4ab5457e060b859a43fbd50f07ac1c1d0fe534298aa86f1ca1af9a15d85 */
#if BIND_git_branch_create_FUNCTION
#define git_branch_create_REQUIRED_ARGC 4
#define git_branch_create_OPTIONAL_ARGC 0
/* git_branch_create
 *
 * Parameters:
 * - repo: git_repository *
 * - branch_name: const char *
 * - target: const git_commit *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_create(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_branch_name = NULL;
  mrb_value target;
  mrb_int native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoi", &repo, &native_branch_name, &target, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: target */
  const git_commit * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_commit(target));

  /* Invocation */
  int native_return_value = git_branch_create(&native_out, native_repo, native_branch_name, native_target, native_force);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_create_from_annotated */
/* sha: a24c0b6daeac969399eed6c7d987f6e0e6c485c1b3cb5a77bdcf4a8177b45e03 */
#if BIND_git_branch_create_from_annotated_FUNCTION
#define git_branch_create_from_annotated_REQUIRED_ARGC 4
#define git_branch_create_from_annotated_OPTIONAL_ARGC 0
/* git_branch_create_from_annotated
 *
 * Parameters:
 * - repository: git_repository *
 * - branch_name: const char *
 * - commit: const git_annotated_commit *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_create_from_annotated(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_ref_out = NULL;
  mrb_value repository;
  char * native_branch_name = NULL;
  mrb_value commit;
  mrb_int native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoi", &repository, &native_branch_name, &commit, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repository, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }

  /* Unbox param: repository */
  git_repository * native_repository = (mrb_nil_p(repository) ? NULL : mruby_unbox_git_repository(repository));

  /* Unbox param: commit */
  const git_annotated_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_annotated_commit(commit));

  /* Invocation */
  int native_return_value = git_branch_create_from_annotated(&native_ref_out, native_repository, native_branch_name, native_commit, native_force);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: ref_out */
  mrb_value ref_out = native_ref_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_ref_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, ref_out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_delete */
/* sha: a0b1842172a610362477ad13c40a59c70b9586e454edd8a26e3be234611fa03e */
#if BIND_git_branch_delete_FUNCTION
#define git_branch_delete_REQUIRED_ARGC 1
#define git_branch_delete_OPTIONAL_ARGC 0
/* git_branch_delete
 *
 * Parameters:
 * - branch: git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_delete(mrb_state* mrb, mrb_value self) {
  mrb_value branch;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &branch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, branch, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: branch */
  git_reference * native_branch = (mrb_nil_p(branch) ? NULL : mruby_unbox_git_reference(branch));

  /* Invocation */
  int native_return_value = git_branch_delete(native_branch);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_is_head */
/* sha: 2b697d31c1bb3597cefb90a1cea2fa362e50cd620ad0aa48f693eeb4dea08518 */
#if BIND_git_branch_is_head_FUNCTION
#define git_branch_is_head_REQUIRED_ARGC 1
#define git_branch_is_head_OPTIONAL_ARGC 0
/* git_branch_is_head
 *
 * Parameters:
 * - branch: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_is_head(mrb_state* mrb, mrb_value self) {
  mrb_value branch;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &branch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, branch, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: branch */
  const git_reference * native_branch = (mrb_nil_p(branch) ? NULL : mruby_unbox_git_reference(branch));

  /* Invocation */
  int native_return_value = git_branch_is_head(native_branch);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_iterator_free */
/* sha: 10adfc0dcf298a072da40069d7bbe88314047f0006cca4286cb7a690323f3a21 */
#if BIND_git_branch_iterator_free_FUNCTION
#define git_branch_iterator_free_REQUIRED_ARGC 1
#define git_branch_iterator_free_OPTIONAL_ARGC 0
/* git_branch_iterator_free
 *
 * Parameters:
 * - iter: git_branch_iterator *
 * Return Type: void
 */
mrb_value
mrb_Git_git_branch_iterator_free(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, BranchIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "BranchIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iter */
  git_branch_iterator * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox_git_branch_iterator(iter));

  /* Invocation */
  git_branch_iterator_free(native_iter);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_iterator_new */
/* sha: 069deac6b9b32f592553bb3f2db95cf37af9540655ea6a2e40adbcce11f99bfb */
#if BIND_git_branch_iterator_new_FUNCTION
#define git_branch_iterator_new_REQUIRED_ARGC 2
#define git_branch_iterator_new_OPTIONAL_ARGC 0
/* git_branch_iterator_new
 *
 * Parameters:
 * - repo: git_repository *
 * - list_flags: git_branch_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_iterator_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_branch_iterator * native_out = NULL;
  mrb_value repo;
  mrb_int native_list_flags;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &repo, &native_list_flags);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_branch_iterator_new(&native_out, native_repo, native_list_flags);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_branch_iterator(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_lookup */
/* sha: 9350b9cb1feb40284fe8bea8d587661bd99ec71be5d8121a40490b4ef2013bdd */
#if BIND_git_branch_lookup_FUNCTION
#define git_branch_lookup_REQUIRED_ARGC 3
#define git_branch_lookup_OPTIONAL_ARGC 0
/* git_branch_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - branch_name: const char *
 * - branch_type: git_branch_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_lookup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_branch_name = NULL;
  mrb_int native_branch_type;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &repo, &native_branch_name, &native_branch_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_branch_lookup(&native_out, native_repo, native_branch_name, native_branch_type);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_move */
/* sha: 8b10108c01e4e9947dba15901d2b240bd9552ae484c9e4b4b00614d4f97da285 */
#if BIND_git_branch_move_FUNCTION
#define git_branch_move_REQUIRED_ARGC 3
#define git_branch_move_OPTIONAL_ARGC 0
/* git_branch_move
 *
 * Parameters:
 * - branch: git_reference *
 * - new_branch_name: const char *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_move(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  mrb_value branch;
  char * native_new_branch_name = NULL;
  mrb_int native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &branch, &native_new_branch_name, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, branch, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: branch */
  git_reference * native_branch = (mrb_nil_p(branch) ? NULL : mruby_unbox_git_reference(branch));

  /* Invocation */
  int native_return_value = git_branch_move(&native_out, native_branch, native_new_branch_name, native_force);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_name */
/* sha: 23808bef41df7dfe1919c8e3b676c41b481959bcba0784d8633b05b35a148eb0 */
#if BIND_git_branch_name_FUNCTION
#define git_branch_name_REQUIRED_ARGC 1
#define git_branch_name_OPTIONAL_ARGC 0
/* git_branch_name
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_name(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_out = NULL;
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_branch_name(&native_out, native_ref);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out ==  NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_next */
/* sha: df0121f2f27b493af99a182c2857fb7b891ecd5313127f75d2f6a7f9a5f70c90 */
#if BIND_git_branch_next_FUNCTION
#define git_branch_next_REQUIRED_ARGC 1
#define git_branch_next_OPTIONAL_ARGC 0
/* git_branch_next
 *
 * Parameters:
 * - iter: git_branch_iterator *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_next(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  int native_out_type;
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, BranchIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "BranchIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iter */
  git_branch_iterator * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox_git_branch_iterator(iter));

  /* Invocation */
  int native_return_value = git_branch_next(&native_out, &native_out_type, native_iter);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);
  /* Box out param: out_type */
  mrb_value out_type = mrb_fixnum_value(native_out_type);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);
  mrb_ary_push(mrb, results, out_type);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_remote_name */
/* sha: d2532347746bff390f9a1911587beca4731815e0d468cad615fc284ca006456b */
#if BIND_git_branch_remote_name_FUNCTION
#define git_branch_remote_name_REQUIRED_ARGC 3
#define git_branch_remote_name_OPTIONAL_ARGC 0
/* git_branch_remote_name
 *
 * Parameters:
 * - out: git_buf *
 * - repo: git_repository *
 * - canonical_branch_name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_remote_name(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;
  char * native_canonical_branch_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &out, &repo, &native_canonical_branch_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_branch_remote_name(native_out, native_repo, native_canonical_branch_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_set_upstream */
/* sha: 62576b83f9b72fcca14c9b8c75dc5491f0ab186ea30c102fa172b28dd5ec5bf4 */
#if BIND_git_branch_set_upstream_FUNCTION
#define git_branch_set_upstream_REQUIRED_ARGC 2
#define git_branch_set_upstream_OPTIONAL_ARGC 0
/* git_branch_set_upstream
 *
 * Parameters:
 * - branch: git_reference *
 * - upstream_name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_set_upstream(mrb_state* mrb, mrb_value self) {
  mrb_value branch;
  char * native_upstream_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &branch, &native_upstream_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, branch, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: branch */
  git_reference * native_branch = (mrb_nil_p(branch) ? NULL : mruby_unbox_git_reference(branch));

  /* Invocation */
  int native_return_value = git_branch_set_upstream(native_branch, native_upstream_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_upstream */
/* sha: 5e9ce55eba3fad61fe2376f109bd972e715ab70759682566afa3564721d73221 */
#if BIND_git_branch_upstream_FUNCTION
#define git_branch_upstream_REQUIRED_ARGC 1
#define git_branch_upstream_OPTIONAL_ARGC 0
/* git_branch_upstream
 *
 * Parameters:
 * - branch: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_upstream(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  mrb_value branch;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &branch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, branch, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: branch */
  const git_reference * native_branch = (mrb_nil_p(branch) ? NULL : mruby_unbox_git_reference(branch));

  /* Invocation */
  int native_return_value = git_branch_upstream(&native_out, native_branch);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_upstream_name */
/* sha: bb4a0179a357ced53167f4bd1eba0ccf3db10d8f0d724aa2d22e96e6d7529654 */
#if BIND_git_branch_upstream_name_FUNCTION
#define git_branch_upstream_name_REQUIRED_ARGC 3
#define git_branch_upstream_name_OPTIONAL_ARGC 0
/* git_branch_upstream_name
 *
 * Parameters:
 * - out: git_buf *
 * - repo: git_repository *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_upstream_name(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &out, &repo, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_branch_upstream_name(native_out, native_repo, native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_upstream_remote */
/* sha: 9a59290f7541ec967bd296975312dcf614ef7d9a18cf07f0d99265382c7b5167 */
#if BIND_git_branch_upstream_remote_FUNCTION
#define git_branch_upstream_remote_REQUIRED_ARGC 3
#define git_branch_upstream_remote_OPTIONAL_ARGC 0
/* git_branch_upstream_remote
 *
 * Parameters:
 * - buf: git_buf *
 * - repo: git_repository *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_upstream_remote(mrb_state* mrb, mrb_value self) {
  mrb_value buf;
  mrb_value repo;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &buf, &repo, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, buf, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: buf */
  git_buf * native_buf = (mrb_nil_p(buf) ? NULL : mruby_unbox_git_buf(buf));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_branch_upstream_remote(native_buf, native_repo, native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_buf_contains_nul */
/* sha: 80b69670cbf042d826e5702c38eeb3d72818e23b1d305c86bc8b85718e959070 */
#if BIND_git_buf_contains_nul_FUNCTION
#define git_buf_contains_nul_REQUIRED_ARGC 1
#define git_buf_contains_nul_OPTIONAL_ARGC 0
/* git_buf_contains_nul
 *
 * Parameters:
 * - buf: const git_buf *
 * Return Type: int
 */
mrb_value
mrb_Git_git_buf_contains_nul(mrb_state* mrb, mrb_value self) {
  mrb_value buf;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &buf);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, buf, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: buf */
  const git_buf * native_buf = (mrb_nil_p(buf) ? NULL : mruby_unbox_git_buf(buf));

  /* Invocation */
  int native_return_value = git_buf_contains_nul(native_buf);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_buf_free */
/* sha: 5458fec5b3a192ed15c078d49342e1536980d4559bbfd5a7dc5a9ab023399023 */
#if BIND_git_buf_free_FUNCTION
#define git_buf_free_REQUIRED_ARGC 1
#define git_buf_free_OPTIONAL_ARGC 0
/* git_buf_free
 *
 * Parameters:
 * - buffer: git_buf *
 * Return Type: void
 */
mrb_value
mrb_Git_git_buf_free(mrb_state* mrb, mrb_value self) {
  mrb_value buffer;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &buffer);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, buffer, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: buffer */
  git_buf * native_buffer = (mrb_nil_p(buffer) ? NULL : mruby_unbox_git_buf(buffer));

  /* Invocation */
  git_buf_free(native_buffer);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_buf_grow */
/* sha: f98d7fd5c1848cc60accb50bb21031fb6d05caac6e1e876536bef4ec410304fb */
#if BIND_git_buf_grow_FUNCTION
#define git_buf_grow_REQUIRED_ARGC 2
#define git_buf_grow_OPTIONAL_ARGC 0
/* git_buf_grow
 *
 * Parameters:
 * - buffer: git_buf *
 * - target_size: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_buf_grow(mrb_state* mrb, mrb_value self) {
  mrb_value buffer;
  mrb_int native_target_size;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &buffer, &native_target_size);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, buffer, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: buffer */
  git_buf * native_buffer = (mrb_nil_p(buffer) ? NULL : mruby_unbox_git_buf(buffer));

  /* Invocation */
  int native_return_value = git_buf_grow(native_buffer, native_target_size);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_buf_is_binary */
/* sha: 9606c47b9a8393b86bfbacf3da66b02bfdf85ae02ca9d5f5cf4ef1fe0c8e2e23 */
#if BIND_git_buf_is_binary_FUNCTION
#define git_buf_is_binary_REQUIRED_ARGC 1
#define git_buf_is_binary_OPTIONAL_ARGC 0
/* git_buf_is_binary
 *
 * Parameters:
 * - buf: const git_buf *
 * Return Type: int
 */
mrb_value
mrb_Git_git_buf_is_binary(mrb_state* mrb, mrb_value self) {
  mrb_value buf;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &buf);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, buf, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: buf */
  const git_buf * native_buf = (mrb_nil_p(buf) ? NULL : mruby_unbox_git_buf(buf));

  /* Invocation */
  int native_return_value = git_buf_is_binary(native_buf);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_buf_set */
/* sha: 5334c24482065cf481809ac95cee32cda82db0dc6b34457579dab29061326fce */
#if BIND_git_buf_set_FUNCTION
#define git_buf_set_REQUIRED_ARGC 2
#define git_buf_set_OPTIONAL_ARGC 0
/* git_buf_set
 *
 * Parameters:
 * - buffer: git_buf *
 * - data: const void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_buf_set(mrb_state* mrb, mrb_value self) {
  mrb_value buffer;
  mrb_value native_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oS", &buffer, &native_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, buffer, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: buffer */
  git_buf * native_buffer = (mrb_nil_p(buffer) ? NULL : mruby_unbox_git_buf(buffer));

  /* Invocation */
  int native_return_value = git_buf_set(native_buffer, RSTRING_PTR(native_data), RSTRING_LEN(native_data));

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_checkout_head */
/* sha: 1ac3599d08aeffea37a2d59ee57b495f85321915501000ca0863f5869c3c6053 */
#if BIND_git_checkout_head_FUNCTION
#define git_checkout_head_REQUIRED_ARGC 2
#define git_checkout_head_OPTIONAL_ARGC 0
/* git_checkout_head
 *
 * Parameters:
 * - repo: git_repository *
 * - opts: const git_checkout_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_checkout_head(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, CheckoutOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CheckoutOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: opts */
  const git_checkout_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_checkout_options(opts));

  /* Invocation */
  int native_return_value = git_checkout_head(native_repo, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_checkout_index */
/* sha: 3b309998099fd047d4b7b4468fc06f234ae3b0e055e8a6db5c89c100744e1da0 */
#if BIND_git_checkout_index_FUNCTION
#define git_checkout_index_REQUIRED_ARGC 3
#define git_checkout_index_OPTIONAL_ARGC 0
/* git_checkout_index
 *
 * Parameters:
 * - repo: git_repository *
 * - index: git_index *
 * - opts: const git_checkout_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_checkout_index(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value index;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &index, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, CheckoutOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CheckoutOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: opts */
  const git_checkout_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_checkout_options(opts));

  /* Invocation */
  int native_return_value = git_checkout_index(native_repo, native_index, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_checkout_init_options */
/* sha: 30131555345f6d980638bcb026c3768469cfe47e1541fada8f99ef1ce38e15d1 */
#if BIND_git_checkout_init_options_FUNCTION
#define git_checkout_init_options_REQUIRED_ARGC 2
#define git_checkout_init_options_OPTIONAL_ARGC 0
/* git_checkout_init_options
 *
 * Parameters:
 * - opts: git_checkout_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_checkout_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, CheckoutOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CheckoutOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_checkout_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_checkout_options(opts));

  /* Invocation */
  int native_return_value = git_checkout_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_checkout_tree */
/* sha: 943fde459fc0bf47b861d18897898aa62f722cd409bc8af92e3b5e266446cbf7 */
#if BIND_git_checkout_tree_FUNCTION
#define git_checkout_tree_REQUIRED_ARGC 3
#define git_checkout_tree_OPTIONAL_ARGC 0
/* git_checkout_tree
 *
 * Parameters:
 * - repo: git_repository *
 * - treeish: const git_object *
 * - opts: const git_checkout_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_checkout_tree(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value treeish;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &treeish, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, treeish, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, CheckoutOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CheckoutOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: treeish */
  const git_object * native_treeish = (mrb_nil_p(treeish) ? NULL : mruby_unbox_git_object(treeish));

  /* Unbox param: opts */
  const git_checkout_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_checkout_options(opts));

  /* Invocation */
  int native_return_value = git_checkout_tree(native_repo, native_treeish, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cherrypick */
/* sha: 14cfe37d81de967110e917c655054168fa71da3ff88acdd8c52118865c926768 */
#if BIND_git_cherrypick_FUNCTION
#define git_cherrypick_REQUIRED_ARGC 3
#define git_cherrypick_OPTIONAL_ARGC 0
/* git_cherrypick
 *
 * Parameters:
 * - repo: git_repository *
 * - commit: git_commit *
 * - cherrypick_options: const git_cherrypick_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cherrypick(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value commit;
  mrb_value cherrypick_options;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &commit, &cherrypick_options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, cherrypick_options, CherrypickOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CherrypickOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: commit */
  git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Unbox param: cherrypick_options */
  const git_cherrypick_options * native_cherrypick_options = (mrb_nil_p(cherrypick_options) ? NULL : mruby_unbox_git_cherrypick_options(cherrypick_options));

  /* Invocation */
  int native_return_value = git_cherrypick(native_repo, native_commit, native_cherrypick_options);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cherrypick_commit */
/* sha: f500dc86c71cf356119bd1b6c8d96abc737ab93dfd4c7100fa1ca9fc02654f4d */
#if BIND_git_cherrypick_commit_FUNCTION
#define git_cherrypick_commit_REQUIRED_ARGC 5
#define git_cherrypick_commit_OPTIONAL_ARGC 0
/* git_cherrypick_commit
 *
 * Parameters:
 * - repo: git_repository *
 * - cherrypick_commit: git_commit *
 * - our_commit: git_commit *
 * - mainline: unsigned int
 * - merge_options: const git_merge_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cherrypick_commit(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_index * native_out = NULL;
  mrb_value repo;
  mrb_value cherrypick_commit;
  mrb_value our_commit;
  mrb_int native_mainline;
  mrb_value merge_options;

  /* Fetch the args */
  mrb_get_args(mrb, "oooio", &repo, &cherrypick_commit, &our_commit, &native_mainline, &merge_options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, cherrypick_commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, our_commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, merge_options, MergeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: cherrypick_commit */
  git_commit * native_cherrypick_commit = (mrb_nil_p(cherrypick_commit) ? NULL : mruby_unbox_git_commit(cherrypick_commit));

  /* Unbox param: our_commit */
  git_commit * native_our_commit = (mrb_nil_p(our_commit) ? NULL : mruby_unbox_git_commit(our_commit));

  /* Unbox param: merge_options */
  const git_merge_options * native_merge_options = (mrb_nil_p(merge_options) ? NULL : mruby_unbox_git_merge_options(merge_options));

  /* Invocation */
  int native_return_value = git_cherrypick_commit(&native_out, native_repo, native_cherrypick_commit, native_our_commit, native_mainline, native_merge_options);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cherrypick_init_options */
/* sha: 7d0f1d4c3f2d674370d5ee620d8225a8650afd46955bf0d6f6554b6d96fcea1f */
#if BIND_git_cherrypick_init_options_FUNCTION
#define git_cherrypick_init_options_REQUIRED_ARGC 2
#define git_cherrypick_init_options_OPTIONAL_ARGC 0
/* git_cherrypick_init_options
 *
 * Parameters:
 * - opts: git_cherrypick_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_cherrypick_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, CherrypickOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CherrypickOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_cherrypick_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_cherrypick_options(opts));

  /* Invocation */
  int native_return_value = git_cherrypick_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_clone */
/* sha: 3c5fd16785b807be2b801f2166e2b1b2992bb85024c4f24b13420f75064000f8 */
#if BIND_git_clone_FUNCTION
#define git_clone_REQUIRED_ARGC 3
#define git_clone_OPTIONAL_ARGC 0
/* git_clone
 *
 * Parameters:
 * - url: const char *
 * - local_path: const char *
 * - options: const git_clone_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_clone(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_repository * native_out = NULL;
  char * native_url = NULL;
  char * native_local_path = NULL;
  mrb_value options;

  /* Fetch the args */
  mrb_get_args(mrb, "zzo", &native_url, &native_local_path, &options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, options, CloneOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CloneOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: options */
  const git_clone_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_clone_options(options));

  /* Invocation */
  int native_return_value = git_clone(&native_out, native_url, native_local_path, native_options);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_clone_init_options */
/* sha: d91c1b35ab3829860cc1799983492520acaec2ac3997647f917646d3f5497b38 */
#if BIND_git_clone_init_options_FUNCTION
#define git_clone_init_options_REQUIRED_ARGC 2
#define git_clone_init_options_OPTIONAL_ARGC 0
/* git_clone_init_options
 *
 * Parameters:
 * - opts: git_clone_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_clone_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, CloneOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CloneOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_clone_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_clone_options(opts));

  /* Invocation */
  int native_return_value = git_clone_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_amend */
/* sha: d2847c9e26c82cd4fb7a3008306b7077b262f7ef73f20e74b04a6bcde7a70d96 */
#if BIND_git_commit_amend_FUNCTION
#define git_commit_amend_REQUIRED_ARGC 8
#define git_commit_amend_OPTIONAL_ARGC 0
/* git_commit_amend
 *
 * Parameters:
 * - id: git_oid *
 * - commit_to_amend: const git_commit *
 * - update_ref: const char *
 * - author: const git_signature *
 * - committer: const git_signature *
 * - message_encoding: const char *
 * - message: const char *
 * - tree: const git_tree *
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_amend(mrb_state* mrb, mrb_value self) {
  mrb_value id;
  mrb_value commit_to_amend;
  char * native_update_ref = NULL;
  mrb_value author;
  mrb_value committer;
  char * native_message_encoding = NULL;
  char * native_message = NULL;
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "oozoozzo", &id, &commit_to_amend, &native_update_ref, &author, &committer, &native_message_encoding, &native_message, &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit_to_amend, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, author, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, committer, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: id */
  git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Unbox param: commit_to_amend */
  const git_commit * native_commit_to_amend = (mrb_nil_p(commit_to_amend) ? NULL : mruby_unbox_git_commit(commit_to_amend));

  /* Unbox param: author */
  const git_signature * native_author = (mrb_nil_p(author) ? NULL : mruby_unbox_git_signature(author));

  /* Unbox param: committer */
  const git_signature * native_committer = (mrb_nil_p(committer) ? NULL : mruby_unbox_git_signature(committer));

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  int native_return_value = git_commit_amend(native_id, native_commit_to_amend, native_update_ref, native_author, native_committer, native_message_encoding, native_message, native_tree);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_author */
/* sha: 1f6aa41b5da02b22eb3bd373b6b9edb373a986e01c5974692bd9075c10d5fe40 */
#if BIND_git_commit_author_FUNCTION
#define git_commit_author_REQUIRED_ARGC 1
#define git_commit_author_OPTIONAL_ARGC 0
/* git_commit_author
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const git_signature *
 */
mrb_value
mrb_Git_git_commit_author(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const git_signature * native_return_value = git_commit_author(native_commit);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_signature(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_body */
/* sha: 0c49e748877cdbaa65c4ab674afe70869b4301364394a04d6e92a3034ec4f87a */
#if BIND_git_commit_body_FUNCTION
#define git_commit_body_REQUIRED_ARGC 1
#define git_commit_body_OPTIONAL_ARGC 0
/* git_commit_body
 *
 * Parameters:
 * - commit: git_commit *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_commit_body(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const char * native_return_value = git_commit_body(native_commit);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_committer */
/* sha: 02b88b6ee1641d6c619a2a99d5bb620ffa64afc654548be0d64991d72c6a29a6 */
#if BIND_git_commit_committer_FUNCTION
#define git_commit_committer_REQUIRED_ARGC 1
#define git_commit_committer_OPTIONAL_ARGC 0
/* git_commit_committer
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const git_signature *
 */
mrb_value
mrb_Git_git_commit_committer(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const git_signature * native_return_value = git_commit_committer(native_commit);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_signature(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_create */
/* sha: 1e7665d07c3f68baee3f0464eea3e0327932721b1e235cc33ff60a8a872677aa */
#if BIND_git_commit_create_FUNCTION
#define git_commit_create_REQUIRED_ARGC 10
#define git_commit_create_OPTIONAL_ARGC 0
/* git_commit_create
 *
 * Parameters:
 * - id: git_oid *
 * - repo: git_repository *
 * - update_ref: const char *
 * - author: const git_signature *
 * - committer: const git_signature *
 * - message_encoding: const char *
 * - message: const char *
 * - tree: const git_tree *
 * - parent_count: size_t
 * - parents: const git_commit *[]
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_create(mrb_state* mrb, mrb_value self) {
  mrb_value id;
  mrb_value repo;
  char * native_update_ref = NULL;
  mrb_value author;
  mrb_value committer;
  char * native_message_encoding = NULL;
  char * native_message = NULL;
  mrb_value tree;
  mrb_int native_parent_count;
  mrb_value parents;

  /* Fetch the args */
  mrb_get_args(mrb, "oozoozzoio", &id, &repo, &native_update_ref, &author, &committer, &native_message_encoding, &native_message, &tree, &native_parent_count, &parents);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, author, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, committer, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_commit_PTR_[](parents);

  /* Unbox param: id */
  git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: author */
  const git_signature * native_author = (mrb_nil_p(author) ? NULL : mruby_unbox_git_signature(author));

  /* Unbox param: committer */
  const git_signature * native_committer = (mrb_nil_p(committer) ? NULL : mruby_unbox_git_signature(committer));

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Unbox param: parents */
  const git_commit *[] native_parents = TODO_mruby_unbox_git_commit_PTR_[](parents);

  /* Invocation */
  int native_return_value = git_commit_create(native_id, native_repo, native_update_ref, native_author, native_committer, native_message_encoding, native_message, native_tree, native_parent_count, native_parents);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_create_v */
/* sha: e58146d469efc6cbab2315f071cb62628abd726708b4df46bb3e8e5f32dfbb0f */
#if BIND_git_commit_create_v_FUNCTION
#define git_commit_create_v_REQUIRED_ARGC 9
#define git_commit_create_v_OPTIONAL_ARGC 0
/* git_commit_create_v
 *
 * Parameters:
 * - id: git_oid *
 * - repo: git_repository *
 * - update_ref: const char *
 * - author: const git_signature *
 * - committer: const git_signature *
 * - message_encoding: const char *
 * - message: const char *
 * - tree: const git_tree *
 * - parent_count: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_create_v(mrb_state* mrb, mrb_value self) {
  mrb_value id;
  mrb_value repo;
  char * native_update_ref = NULL;
  mrb_value author;
  mrb_value committer;
  char * native_message_encoding = NULL;
  char * native_message = NULL;
  mrb_value tree;
  mrb_int native_parent_count;

  /* Fetch the args */
  mrb_get_args(mrb, "oozoozzoi", &id, &repo, &native_update_ref, &author, &committer, &native_message_encoding, &native_message, &tree, &native_parent_count);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, author, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, committer, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: id */
  git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: author */
  const git_signature * native_author = (mrb_nil_p(author) ? NULL : mruby_unbox_git_signature(author));

  /* Unbox param: committer */
  const git_signature * native_committer = (mrb_nil_p(committer) ? NULL : mruby_unbox_git_signature(committer));

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  int native_return_value = git_commit_create_v(native_id, native_repo, native_update_ref, native_author, native_committer, native_message_encoding, native_message, native_tree, native_parent_count);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_free */
/* sha: f70363f18aa37ea0ceabb563e6e45eacd21edf87974e5775a426e3a2660a2abe */
#if BIND_git_commit_free_FUNCTION
#define git_commit_free_REQUIRED_ARGC 1
#define git_commit_free_OPTIONAL_ARGC 0
/* git_commit_free
 *
 * Parameters:
 * - commit: git_commit *
 * Return Type: void
 */
mrb_value
mrb_Git_git_commit_free(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  git_commit_free(native_commit);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_header_field */
/* sha: 8ad474cbe32968dd80f4eb3a02adece3b3179eb1f49f2a6e95b40768cd80b5d3 */
#if BIND_git_commit_header_field_FUNCTION
#define git_commit_header_field_REQUIRED_ARGC 3
#define git_commit_header_field_OPTIONAL_ARGC 0
/* git_commit_header_field
 *
 * Parameters:
 * - out: git_buf *
 * - commit: const git_commit *
 * - field: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_header_field(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value commit;
  char * native_field = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &out, &commit, &native_field);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  int native_return_value = git_commit_header_field(native_out, native_commit, native_field);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_id */
/* sha: cc3f84d5d4846ae10bfa1537ee523c62a3549eb32ad06f3613cb00e87c43814a */
#if BIND_git_commit_id_FUNCTION
#define git_commit_id_REQUIRED_ARGC 1
#define git_commit_id_OPTIONAL_ARGC 0
/* git_commit_id
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_commit_id(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const git_oid * native_return_value = git_commit_id(native_commit);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_lookup */
/* sha: 168df6021f96ad0fd402b9a407e45cf2e9821e71acce4e791ad7929e4626b21e */
#if BIND_git_commit_lookup_FUNCTION
#define git_commit_lookup_REQUIRED_ARGC 2
#define git_commit_lookup_OPTIONAL_ARGC 0
/* git_commit_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_lookup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_commit * native_commit = NULL;
  mrb_value repo;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_commit_lookup(&native_commit, native_repo, native_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: commit */
  mrb_value commit = native_commit == NULL ? mrb_nil_value() : mruby_giftwrap_git_commit(mrb, native_commit);

  /* Add out params to results */
  mrb_ary_push(mrb, results, commit);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_lookup_prefix */
/* sha: 5b67374feb88574034e4d079fee9b048dcc9c92b64ae5417b63182c2d2eed9aa */
#if BIND_git_commit_lookup_prefix_FUNCTION
#define git_commit_lookup_prefix_REQUIRED_ARGC 3
#define git_commit_lookup_prefix_OPTIONAL_ARGC 0
/* git_commit_lookup_prefix
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_lookup_prefix(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_commit * native_commit = NULL;
  mrb_value repo;
  mrb_value id;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &repo, &id, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_commit_lookup_prefix(&native_commit, native_repo, native_id, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: commit */
  mrb_value commit = native_commit == NULL ? mrb_nil_value() : mruby_giftwrap_git_commit(mrb, native_commit);

  /* Add out params to results */
  mrb_ary_push(mrb, results, commit);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_message */
/* sha: ff1bad69213e76473efe7b2865bc0d21d9f89c76a49b91eb5c5b0ad8493ecbcc */
#if BIND_git_commit_message_FUNCTION
#define git_commit_message_REQUIRED_ARGC 1
#define git_commit_message_OPTIONAL_ARGC 0
/* git_commit_message
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_commit_message(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const char * native_return_value = git_commit_message(native_commit);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_message_encoding */
/* sha: c353517d5ec6ef938585e27ae5f4b4013029f13317e087da031f86866aec5292 */
#if BIND_git_commit_message_encoding_FUNCTION
#define git_commit_message_encoding_REQUIRED_ARGC 1
#define git_commit_message_encoding_OPTIONAL_ARGC 0
/* git_commit_message_encoding
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_commit_message_encoding(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const char * native_return_value = git_commit_message_encoding(native_commit);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_message_raw */
/* sha: 5154a7c34384a14a5c44cd97d9c8f598e80dcd5e8549e514844aa492169f19a9 */
#if BIND_git_commit_message_raw_FUNCTION
#define git_commit_message_raw_REQUIRED_ARGC 1
#define git_commit_message_raw_OPTIONAL_ARGC 0
/* git_commit_message_raw
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_commit_message_raw(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const char * native_return_value = git_commit_message_raw(native_commit);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_nth_gen_ancestor */
/* sha: 0b278b35d90744c5b27813a8937f7314c7c9ce22a9ea6f4c209f4a1ccc41aef2 */
#if BIND_git_commit_nth_gen_ancestor_FUNCTION
#define git_commit_nth_gen_ancestor_REQUIRED_ARGC 2
#define git_commit_nth_gen_ancestor_OPTIONAL_ARGC 0
/* git_commit_nth_gen_ancestor
 *
 * Parameters:
 * - commit: const git_commit *
 * - n: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_nth_gen_ancestor(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_commit * native_ancestor = NULL;
  mrb_value commit;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &commit, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  int native_return_value = git_commit_nth_gen_ancestor(&native_ancestor, native_commit, native_n);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: ancestor */
  mrb_value ancestor = native_ancestor == NULL ? mrb_nil_value() : mruby_giftwrap_git_commit(mrb, native_ancestor);

  /* Add out params to results */
  mrb_ary_push(mrb, results, ancestor);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_owner */
/* sha: 8304aec89de65b19830c942421cb7ee29f8e059ba2b758d56ba6260139a24bf0 */
#if BIND_git_commit_owner_FUNCTION
#define git_commit_owner_REQUIRED_ARGC 1
#define git_commit_owner_OPTIONAL_ARGC 0
/* git_commit_owner
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_commit_owner(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  git_repository * native_return_value = git_commit_owner(native_commit);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_parent */
/* sha: db2649284c2ca32dd2ece1af96a6fe3ca4ee5dcb15e49f4e96c355ed5bf638d2 */
#if BIND_git_commit_parent_FUNCTION
#define git_commit_parent_REQUIRED_ARGC 2
#define git_commit_parent_OPTIONAL_ARGC 0
/* git_commit_parent
 *
 * Parameters:
 * - commit: const git_commit *
 * - n: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_parent(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_commit * native_out = NULL;
  mrb_value commit;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &commit, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  int native_return_value = git_commit_parent(&native_out, native_commit, native_n);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_commit(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_parent_id */
/* sha: 5c5949f38fd5aa3337b609dea1cc85c1b379beec3d95598624d8452f20f405c8 */
#if BIND_git_commit_parent_id_FUNCTION
#define git_commit_parent_id_REQUIRED_ARGC 2
#define git_commit_parent_id_OPTIONAL_ARGC 0
/* git_commit_parent_id
 *
 * Parameters:
 * - commit: const git_commit *
 * - n: unsigned int
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_commit_parent_id(mrb_state* mrb, mrb_value self) {
  mrb_value commit;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &commit, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const git_oid * native_return_value = git_commit_parent_id(native_commit, native_n);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_parentcount */
/* sha: c35e39f49bcfcb01312b6028efb4b77a5ba1ca171287cbe9b338ecee5be40605 */
#if BIND_git_commit_parentcount_FUNCTION
#define git_commit_parentcount_REQUIRED_ARGC 1
#define git_commit_parentcount_OPTIONAL_ARGC 0
/* git_commit_parentcount
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: unsigned int
 */
mrb_value
mrb_Git_git_commit_parentcount(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  unsigned int native_return_value = git_commit_parentcount(native_commit);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_raw_header */
/* sha: b0612fa1c5daf9aad7aaf406b934a52a505d372ffd30dc00a5c7dd3fdb397c4e */
#if BIND_git_commit_raw_header_FUNCTION
#define git_commit_raw_header_REQUIRED_ARGC 1
#define git_commit_raw_header_OPTIONAL_ARGC 0
/* git_commit_raw_header
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_commit_raw_header(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const char * native_return_value = git_commit_raw_header(native_commit);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_summary */
/* sha: edc528da2e506accc2743d23989c2a29de3d0b77b727fbdf041f6027e2a70fe3 */
#if BIND_git_commit_summary_FUNCTION
#define git_commit_summary_REQUIRED_ARGC 1
#define git_commit_summary_OPTIONAL_ARGC 0
/* git_commit_summary
 *
 * Parameters:
 * - commit: git_commit *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_commit_summary(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const char * native_return_value = git_commit_summary(native_commit);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_time */
/* sha: 7b10a305e83289d2d81fe2ca30d9fd2e8ab49d44bcf3b9bde5a04ba36f980740 */
#if BIND_git_commit_time_FUNCTION
#define git_commit_time_REQUIRED_ARGC 1
#define git_commit_time_OPTIONAL_ARGC 0
/* git_commit_time
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: git_time_t
 */
mrb_value
mrb_Git_git_commit_time(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  git_time_t native_return_value = git_commit_time(native_commit);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_time_offset */
/* sha: e291e73fc818b190ed97da8e57f2404042c5aed6039026728ee664a778680d85 */
#if BIND_git_commit_time_offset_FUNCTION
#define git_commit_time_offset_REQUIRED_ARGC 1
#define git_commit_time_offset_OPTIONAL_ARGC 0
/* git_commit_time_offset
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_time_offset(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  int native_return_value = git_commit_time_offset(native_commit);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_tree */
/* sha: d3301de98f45a800fe83d4c222fbe52bea9737e79166626c14afbc6d9ce6c627 */
#if BIND_git_commit_tree_FUNCTION
#define git_commit_tree_REQUIRED_ARGC 1
#define git_commit_tree_OPTIONAL_ARGC 0
/* git_commit_tree
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_tree(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_tree * native_tree_out = NULL;
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  int native_return_value = git_commit_tree(&native_tree_out, native_commit);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: tree_out */
  mrb_value tree_out = native_tree_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_tree(mrb, native_tree_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, tree_out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_tree_id */
/* sha: 6012ae18fceaa498561b6cb024805262877794f831d17159402aea58b686c745 */
#if BIND_git_commit_tree_id_FUNCTION
#define git_commit_tree_id_REQUIRED_ARGC 1
#define git_commit_tree_id_OPTIONAL_ARGC 0
/* git_commit_tree_id
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_commit_tree_id(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const git_oid * native_return_value = git_commit_tree_id(native_commit);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_add_file_ondisk */
/* sha: bfcb271db4a9938fc0e6215bafd6b1a105f33c2231163d6ab59c982d7f5f5131 */
#if BIND_git_config_add_file_ondisk_FUNCTION
#define git_config_add_file_ondisk_REQUIRED_ARGC 4
#define git_config_add_file_ondisk_OPTIONAL_ARGC 0
/* git_config_add_file_ondisk
 *
 * Parameters:
 * - cfg: git_config *
 * - path: const char *
 * - level: git_config_level_t
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_add_file_ondisk(mrb_state* mrb, mrb_value self) {
  mrb_value cfg;
  char * native_path = NULL;
  mrb_int native_level;
  mrb_int native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "ozii", &cfg, &native_path, &native_level, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_add_file_ondisk(native_cfg, native_path, native_level, native_force);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_backend_foreach_match */
/* sha: 89df72269bc9140d76329e3d56e5ec1d6e788ae37f83413a5322201504839e18 */
#if BIND_git_config_backend_foreach_match_FUNCTION
#define git_config_backend_foreach_match_REQUIRED_ARGC 4
#define git_config_backend_foreach_match_OPTIONAL_ARGC 0
/* git_config_backend_foreach_match
 *
 * Parameters:
 * - backend: git_config_backend *
 * - regexp: const char *
 * - callback: git_config_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_backend_foreach_match(mrb_state* mrb, mrb_value self) {
  mrb_value backend;
  char * native_regexp = NULL;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoo", &backend, &native_regexp, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, backend, ConfigBackend_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ConfigBackend expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_config_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: backend */
  git_config_backend * native_backend = (mrb_nil_p(backend) ? NULL : mruby_unbox_git_config_backend(backend));

  /* Unbox param: callback */
  git_config_foreach_cb native_callback = TODO_mruby_unbox_git_config_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_config_backend_foreach_match(native_backend, native_regexp, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_delete_entry */
/* sha: 3993657edbcf03629c9a25400bc2a383e826eb17c75d8d8be0c7c84182356a08 */
#if BIND_git_config_delete_entry_FUNCTION
#define git_config_delete_entry_REQUIRED_ARGC 2
#define git_config_delete_entry_OPTIONAL_ARGC 0
/* git_config_delete_entry
 *
 * Parameters:
 * - cfg: git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_delete_entry(mrb_state* mrb, mrb_value self) {
  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_delete_entry(native_cfg, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_delete_multivar */
/* sha: 198f7b13a9966bd570e8d7043b43bc55a0695219a968c0d05ac6d8d539b2ce77 */
#if BIND_git_config_delete_multivar_FUNCTION
#define git_config_delete_multivar_REQUIRED_ARGC 3
#define git_config_delete_multivar_OPTIONAL_ARGC 0
/* git_config_delete_multivar
 *
 * Parameters:
 * - cfg: git_config *
 * - name: const char *
 * - regexp: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_delete_multivar(mrb_state* mrb, mrb_value self) {
  mrb_value cfg;
  char * native_name = NULL;
  char * native_regexp = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &cfg, &native_name, &native_regexp);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_delete_multivar(native_cfg, native_name, native_regexp);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_entry_free */
/* sha: d38ab356806e2f38e75869f6a813b5a4c381c70774bba5a50d6d4bfd686b4dff */
#if BIND_git_config_entry_free_FUNCTION
#define git_config_entry_free_REQUIRED_ARGC 1
#define git_config_entry_free_OPTIONAL_ARGC 0
/* git_config_entry_free
 *
 * Parameters:
 * - arg1: git_config_entry *
 * Return Type: void
 */
mrb_value
mrb_Git_git_config_entry_free(mrb_state* mrb, mrb_value self) {
  mrb_value arg1;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &arg1);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, arg1, ConfigEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ConfigEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: arg1 */
  git_config_entry * native_arg1 = (mrb_nil_p(arg1) ? NULL : mruby_unbox_git_config_entry(arg1));

  /* Invocation */
  git_config_entry_free(native_arg1);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_find_global */
/* sha: d7972c16895fd1b604b7b555e79a0d17220037ba0380250bbfcffe5ed78caf2c */
#if BIND_git_config_find_global_FUNCTION
#define git_config_find_global_REQUIRED_ARGC 1
#define git_config_find_global_OPTIONAL_ARGC 0
/* git_config_find_global
 *
 * Parameters:
 * - out: git_buf *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_find_global(mrb_state* mrb, mrb_value self) {
  mrb_value out;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &out);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Invocation */
  int native_return_value = git_config_find_global(native_out);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_find_programdata */
/* sha: 6fe51809aa2bb56be5ac0d857ef32d58218291ed32f292f23300ef5be35b4ca3 */
#if BIND_git_config_find_programdata_FUNCTION
#define git_config_find_programdata_REQUIRED_ARGC 1
#define git_config_find_programdata_OPTIONAL_ARGC 0
/* git_config_find_programdata
 *
 * Parameters:
 * - out: git_buf *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_find_programdata(mrb_state* mrb, mrb_value self) {
  mrb_value out;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &out);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Invocation */
  int native_return_value = git_config_find_programdata(native_out);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_find_system */
/* sha: 87f51f627287cf1a3420900a49a90e21343aee11cddb34067759686b5eda3690 */
#if BIND_git_config_find_system_FUNCTION
#define git_config_find_system_REQUIRED_ARGC 1
#define git_config_find_system_OPTIONAL_ARGC 0
/* git_config_find_system
 *
 * Parameters:
 * - out: git_buf *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_find_system(mrb_state* mrb, mrb_value self) {
  mrb_value out;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &out);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Invocation */
  int native_return_value = git_config_find_system(native_out);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_find_xdg */
/* sha: 6cbe31c04d4dc5faa7233bb195963025fbcd672725fccf7d6e481ff2b4f3945b */
#if BIND_git_config_find_xdg_FUNCTION
#define git_config_find_xdg_REQUIRED_ARGC 1
#define git_config_find_xdg_OPTIONAL_ARGC 0
/* git_config_find_xdg
 *
 * Parameters:
 * - out: git_buf *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_find_xdg(mrb_state* mrb, mrb_value self) {
  mrb_value out;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &out);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Invocation */
  int native_return_value = git_config_find_xdg(native_out);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_foreach */
/* sha: b064c9c6d8043fb248caceb715c5ec8f4687cab363b8b13cc67ff1f93d7f593c */
#if BIND_git_config_foreach_FUNCTION
#define git_config_foreach_REQUIRED_ARGC 3
#define git_config_foreach_OPTIONAL_ARGC 0
/* git_config_foreach
 *
 * Parameters:
 * - cfg: const git_config *
 * - callback: git_config_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value cfg;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &cfg, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_config_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Unbox param: callback */
  git_config_foreach_cb native_callback = TODO_mruby_unbox_git_config_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_config_foreach(native_cfg, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_foreach_match */
/* sha: 7bbe5964226ebee035a62cff2a4c1604e27262f08fad0de790bde52719a87c26 */
#if BIND_git_config_foreach_match_FUNCTION
#define git_config_foreach_match_REQUIRED_ARGC 4
#define git_config_foreach_match_OPTIONAL_ARGC 0
/* git_config_foreach_match
 *
 * Parameters:
 * - cfg: const git_config *
 * - regexp: const char *
 * - callback: git_config_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_foreach_match(mrb_state* mrb, mrb_value self) {
  mrb_value cfg;
  char * native_regexp = NULL;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoo", &cfg, &native_regexp, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_config_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Unbox param: callback */
  git_config_foreach_cb native_callback = TODO_mruby_unbox_git_config_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_config_foreach_match(native_cfg, native_regexp, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_free */
/* sha: d09f64fffd45922ab7f3c9125144edf2e7ee2365cd27e41db51d49a89e98ab9b */
#if BIND_git_config_free_FUNCTION
#define git_config_free_REQUIRED_ARGC 1
#define git_config_free_OPTIONAL_ARGC 0
/* git_config_free
 *
 * Parameters:
 * - cfg: git_config *
 * Return Type: void
 */
mrb_value
mrb_Git_git_config_free(mrb_state* mrb, mrb_value self) {
  mrb_value cfg;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &cfg);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  git_config_free(native_cfg);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_bool */
/* sha: f43d6d70eb7c8edbb26d0f5f17db261f54f9b8481abbeb4b17d835b43bcb615f */
#if BIND_git_config_get_bool_FUNCTION
#define git_config_get_bool_REQUIRED_ARGC 2
#define git_config_get_bool_OPTIONAL_ARGC 0
/* git_config_get_bool
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_bool(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_out;
  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_get_bool(&native_out, native_cfg, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == 0 ? mrb_false_value() : mrb_true_value();

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_entry */
/* sha: 78115a269f211c87a2bc7f2f3bd2e828f8a0eaac518315c4e8a0903624714f89 */
#if BIND_git_config_get_entry_FUNCTION
#define git_config_get_entry_REQUIRED_ARGC 2
#define git_config_get_entry_OPTIONAL_ARGC 0
/* git_config_get_entry
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_entry(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_config_entry * native_out = NULL;
  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_get_entry(&native_out, native_cfg, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config_entry(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_int32 */
/* sha: 24b9276574b67790fe22fb0191ecefc4c7367c7411dc7b47fe6b4885b0cd41da */
#if BIND_git_config_get_int32_FUNCTION
#define git_config_get_int32_REQUIRED_ARGC 2
#define git_config_get_int32_OPTIONAL_ARGC 0
/* git_config_get_int32
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_int32(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_out;
  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_get_int32(&native_out, native_cfg, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = mrb_fixnum_value(native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_int64 */
/* sha: f458ab555bcb04b83f89746e88e48a2d3282ecb16678f2bd649361c415f15a56 */
#if BIND_git_config_get_int64_FUNCTION
#define git_config_get_int64_REQUIRED_ARGC 2
#define git_config_get_int64_OPTIONAL_ARGC 0
/* git_config_get_int64
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_int64(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_out;
  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_get_int64(&native_out, native_cfg, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = mrb_fixnum_value(native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_mapped */
/* sha: 3b48014d0b0e3cedec6cd8219e16fd45790c0dabcee8679e013a7d68f77b9b86 */
#if BIND_git_config_get_mapped_FUNCTION
#define git_config_get_mapped_REQUIRED_ARGC 4
#define git_config_get_mapped_OPTIONAL_ARGC 0
/* git_config_get_mapped
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * - maps: const git_cvar_map *
 * - map_n: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_mapped(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_out;
  mrb_value cfg;
  char * native_name = NULL;
  mrb_value maps;
  mrb_int native_map_n;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoi", &cfg, &native_name, &maps, &native_map_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, maps, CvarMap_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CvarMap expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Unbox param: maps */
  const git_cvar_map * native_maps = (mrb_nil_p(maps) ? NULL : mruby_unbox_git_cvar_map(maps));

  /* Invocation */
  int native_return_value = git_config_get_mapped(&native_out, native_cfg, native_name, native_maps, native_map_n);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = mrb_fixnum_value(native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_multivar_foreach */
/* sha: 40c7e3be1b7abeffbd2a1db61e50292de792d1a442dde1b16b86c6e6caf216e4 */
#if BIND_git_config_get_multivar_foreach_FUNCTION
#define git_config_get_multivar_foreach_REQUIRED_ARGC 5
#define git_config_get_multivar_foreach_OPTIONAL_ARGC 0
/* git_config_get_multivar_foreach
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * - regexp: const char *
 * - callback: git_config_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_multivar_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value cfg;
  char * native_name = NULL;
  char * native_regexp = NULL;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzoo", &cfg, &native_name, &native_regexp, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_config_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Unbox param: callback */
  git_config_foreach_cb native_callback = TODO_mruby_unbox_git_config_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_config_get_multivar_foreach(native_cfg, native_name, native_regexp, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_path */
/* sha: 5abbd43f15c19ee5182c8f4a50fcc6719e4d5e5b692cc03c5b145c792b446ee0 */
#if BIND_git_config_get_path_FUNCTION
#define git_config_get_path_REQUIRED_ARGC 3
#define git_config_get_path_OPTIONAL_ARGC 0
/* git_config_get_path
 *
 * Parameters:
 * - out: git_buf *
 * - cfg: const git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_path(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &out, &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_get_path(native_out, native_cfg, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_string */
/* sha: bd77a17078b528b3a8456fbaf8d5b268796c211ba8c257d9f29ef11884272c8a */
#if BIND_git_config_get_string_FUNCTION
#define git_config_get_string_REQUIRED_ARGC 2
#define git_config_get_string_OPTIONAL_ARGC 0
/* git_config_get_string
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_string(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_out = NULL;
  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_get_string(&native_out, native_cfg, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out ==  NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_string_buf */
/* sha: ba99a4a9d3aaf8c91adc014796851c6e33b65d1bb4072162d0f9de260faaefa6 */
#if BIND_git_config_get_string_buf_FUNCTION
#define git_config_get_string_buf_REQUIRED_ARGC 3
#define git_config_get_string_buf_OPTIONAL_ARGC 0
/* git_config_get_string_buf
 *
 * Parameters:
 * - out: git_buf *
 * - cfg: const git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_string_buf(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &out, &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_get_string_buf(native_out, native_cfg, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_iterator_free */
/* sha: b52ea96b15f875471910e4261e115e2ff141a9f817852dcf52356a72e53e4188 */
#if BIND_git_config_iterator_free_FUNCTION
#define git_config_iterator_free_REQUIRED_ARGC 1
#define git_config_iterator_free_OPTIONAL_ARGC 0
/* git_config_iterator_free
 *
 * Parameters:
 * - iter: git_config_iterator *
 * Return Type: void
 */
mrb_value
mrb_Git_git_config_iterator_free(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, ConfigIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ConfigIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iter */
  git_config_iterator * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox_git_config_iterator(iter));

  /* Invocation */
  git_config_iterator_free(native_iter);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_iterator_glob_new */
/* sha: 89ad1ad000f2b6946ad12c21b03efdee07329c7722cd3c806839ee9dd3f5d851 */
#if BIND_git_config_iterator_glob_new_FUNCTION
#define git_config_iterator_glob_new_REQUIRED_ARGC 2
#define git_config_iterator_glob_new_OPTIONAL_ARGC 0
/* git_config_iterator_glob_new
 *
 * Parameters:
 * - cfg: const git_config *
 * - regexp: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_iterator_glob_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_config_iterator * native_out = NULL;
  mrb_value cfg;
  char * native_regexp = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_regexp);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_iterator_glob_new(&native_out, native_cfg, native_regexp);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config_iterator(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_iterator_new */
/* sha: dcec08b151a38d26638fcccf55a98df4bf9b4e7e07f90004174ce78fc53b164b */
#if BIND_git_config_iterator_new_FUNCTION
#define git_config_iterator_new_REQUIRED_ARGC 1
#define git_config_iterator_new_OPTIONAL_ARGC 0
/* git_config_iterator_new
 *
 * Parameters:
 * - cfg: const git_config *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_iterator_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_config_iterator * native_out = NULL;
  mrb_value cfg;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &cfg);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_iterator_new(&native_out, native_cfg);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config_iterator(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_lock */
/* sha: 68aa3951a85ed13cc16fd709c86e40ba1025b793a19462f4893f4b2338cb1505 */
#if BIND_git_config_lock_FUNCTION
#define git_config_lock_REQUIRED_ARGC 1
#define git_config_lock_OPTIONAL_ARGC 0
/* git_config_lock
 *
 * Parameters:
 * - cfg: git_config *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_lock(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_transaction * native_tx = NULL;
  mrb_value cfg;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &cfg);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_lock(&native_tx, native_cfg);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: tx */
  mrb_value tx = native_tx == NULL ? mrb_nil_value() : mruby_giftwrap_git_transaction(mrb, native_tx);

  /* Add out params to results */
  mrb_ary_push(mrb, results, tx);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_lookup_map_value */
/* sha: 1e343897e7301fc82230b96e2d2d5167577ad7aaaa1afb966749fe2c5dc7f76e */
#if BIND_git_config_lookup_map_value_FUNCTION
#define git_config_lookup_map_value_REQUIRED_ARGC 3
#define git_config_lookup_map_value_OPTIONAL_ARGC 0
/* git_config_lookup_map_value
 *
 * Parameters:
 * - maps: const git_cvar_map *
 * - map_n: size_t
 * - value: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_lookup_map_value(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_out;
  mrb_value maps;
  mrb_int native_map_n;
  char * native_value = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oiz", &maps, &native_map_n, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, maps, CvarMap_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CvarMap expected");
    return mrb_nil_value();
  }

  /* Unbox param: maps */
  const git_cvar_map * native_maps = (mrb_nil_p(maps) ? NULL : mruby_unbox_git_cvar_map(maps));

  /* Invocation */
  int native_return_value = git_config_lookup_map_value(&native_out, native_maps, native_map_n, native_value);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = mrb_fixnum_value(native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_multivar_iterator_new */
/* sha: 3e7ee82200ea5ea06d7f9ff69e0d5f4a2d5b3cba9a0d2be0aac8c7571e93b5ce */
#if BIND_git_config_multivar_iterator_new_FUNCTION
#define git_config_multivar_iterator_new_REQUIRED_ARGC 3
#define git_config_multivar_iterator_new_OPTIONAL_ARGC 0
/* git_config_multivar_iterator_new
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * - regexp: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_multivar_iterator_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_config_iterator * native_out = NULL;
  mrb_value cfg;
  char * native_name = NULL;
  char * native_regexp = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &cfg, &native_name, &native_regexp);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_multivar_iterator_new(&native_out, native_cfg, native_name, native_regexp);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config_iterator(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_new */
/* sha: 4fed3bb781a698dc8e22f3987582f6718675d3bda1fc6bb6a44fd246f421fb67 */
#if BIND_git_config_new_FUNCTION
#define git_config_new_REQUIRED_ARGC 0
#define git_config_new_OPTIONAL_ARGC 0
/* git_config_new
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_config * native_out = NULL;


  /* Invocation */
  int native_return_value = git_config_new(&native_out);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_next */
/* sha: b53f96589d26fcaddd768bba1e23fc7068e35cb6ae9f8cebf2b4500ca1907f1c */
#if BIND_git_config_next_FUNCTION
#define git_config_next_REQUIRED_ARGC 1
#define git_config_next_OPTIONAL_ARGC 0
/* git_config_next
 *
 * Parameters:
 * - iter: git_config_iterator *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_next(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_config_entry * native_entry = NULL;
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, ConfigIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ConfigIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iter */
  git_config_iterator * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox_git_config_iterator(iter));

  /* Invocation */
  int native_return_value = git_config_next(&native_entry, native_iter);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: entry */
  mrb_value entry = native_entry == NULL ? mrb_nil_value() : mruby_giftwrap_git_config_entry(mrb, native_entry);

  /* Add out params to results */
  mrb_ary_push(mrb, results, entry);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_open_default */
/* sha: 2c8db063d2d9d5b75208431648528f77f268599e4b42537c15ccf496e15f41f7 */
#if BIND_git_config_open_default_FUNCTION
#define git_config_open_default_REQUIRED_ARGC 0
#define git_config_open_default_OPTIONAL_ARGC 0
/* git_config_open_default
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_open_default(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_config * native_out = NULL;


  /* Invocation */
  int native_return_value = git_config_open_default(&native_out);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_open_global */
/* sha: ae45c80245e1c0c8fd1cae47b2f61779cd51ff4964a0da71491df47b05d2588a */
#if BIND_git_config_open_global_FUNCTION
#define git_config_open_global_REQUIRED_ARGC 1
#define git_config_open_global_OPTIONAL_ARGC 0
/* git_config_open_global
 *
 * Parameters:
 * - config: git_config *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_open_global(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_config * native_out = NULL;
  mrb_value config;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &config);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, config, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: config */
  git_config * native_config = (mrb_nil_p(config) ? NULL : mruby_unbox_git_config(config));

  /* Invocation */
  int native_return_value = git_config_open_global(&native_out, native_config);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_open_level */
/* sha: 4d3a59611ec6952e67f22e9bcb09b3601e38b2e602f5b63ab209c7b013f3f81a */
#if BIND_git_config_open_level_FUNCTION
#define git_config_open_level_REQUIRED_ARGC 2
#define git_config_open_level_OPTIONAL_ARGC 0
/* git_config_open_level
 *
 * Parameters:
 * - parent: const git_config *
 * - level: git_config_level_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_open_level(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_config * native_out = NULL;
  mrb_value parent;
  mrb_int native_level;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &parent, &native_level);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, parent, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: parent */
  const git_config * native_parent = (mrb_nil_p(parent) ? NULL : mruby_unbox_git_config(parent));

  /* Invocation */
  int native_return_value = git_config_open_level(&native_out, native_parent, native_level);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_open_ondisk */
/* sha: 90a1b27bfd0e30891ed522b049d91c14c95e42283eee55c9b2bc3da5090cee37 */
#if BIND_git_config_open_ondisk_FUNCTION
#define git_config_open_ondisk_REQUIRED_ARGC 1
#define git_config_open_ondisk_OPTIONAL_ARGC 0
/* git_config_open_ondisk
 *
 * Parameters:
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_open_ondisk(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_config * native_out = NULL;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_path);

  /* Invocation */
  int native_return_value = git_config_open_ondisk(&native_out, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_parse_bool */
/* sha: 7761a836e93f345670ecb79b4f53d99bb576bd31b973bf16e67e78b8505bd11a */
#if BIND_git_config_parse_bool_FUNCTION
#define git_config_parse_bool_REQUIRED_ARGC 1
#define git_config_parse_bool_OPTIONAL_ARGC 0
/* git_config_parse_bool
 *
 * Parameters:
 * - value: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_parse_bool(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_out;
  char * native_value = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_value);

  /* Invocation */
  int native_return_value = git_config_parse_bool(&native_out, native_value);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == 0 ? mrb_false_value() : mrb_true_value();

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_parse_int32 */
/* sha: f58892d2645112d1f1872d1507277d62407c075438c27030634043341d74d1f0 */
#if BIND_git_config_parse_int32_FUNCTION
#define git_config_parse_int32_REQUIRED_ARGC 1
#define git_config_parse_int32_OPTIONAL_ARGC 0
/* git_config_parse_int32
 *
 * Parameters:
 * - value: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_parse_int32(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_out;
  char * native_value = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_value);

  /* Invocation */
  int native_return_value = git_config_parse_int32(&native_out, native_value);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = mrb_fixnum_value(native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_parse_int64 */
/* sha: c5a848c33203933c1d4f2df3b585405bb028640ce589eb5d7cd51b950317897a */
#if BIND_git_config_parse_int64_FUNCTION
#define git_config_parse_int64_REQUIRED_ARGC 1
#define git_config_parse_int64_OPTIONAL_ARGC 0
/* git_config_parse_int64
 *
 * Parameters:
 * - value: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_parse_int64(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_out;
  char * native_value = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_value);

  /* Invocation */
  int native_return_value = git_config_parse_int64(&native_out, native_value);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = mrb_fixnum_value(native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_parse_path */
/* sha: 8db05df58e03353c0dc560dc98fa32b5b41bab2e351d0e6937c860f1919b6dd1 */
#if BIND_git_config_parse_path_FUNCTION
#define git_config_parse_path_REQUIRED_ARGC 2
#define git_config_parse_path_OPTIONAL_ARGC 0
/* git_config_parse_path
 *
 * Parameters:
 * - out: git_buf *
 * - value: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_parse_path(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  char * native_value = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &out, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Invocation */
  int native_return_value = git_config_parse_path(native_out, native_value);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_set_bool */
/* sha: eef068f505a8056286b5120d36a617c7c3fa1d1433de5520f191e430e7e2e61b */
#if BIND_git_config_set_bool_FUNCTION
#define git_config_set_bool_REQUIRED_ARGC 3
#define git_config_set_bool_OPTIONAL_ARGC 0
/* git_config_set_bool
 *
 * Parameters:
 * - cfg: git_config *
 * - name: const char *
 * - value: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_set_bool(mrb_state* mrb, mrb_value self) {
  mrb_value cfg;
  char * native_name = NULL;
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &cfg, &native_name, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_set_bool(native_cfg, native_name, native_value);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_set_int32 */
/* sha: 2e55447fb9ed0d1aab9b60d6d5f8adca7bf382c4e32ef594e399e8af09ceb9fc */
#if BIND_git_config_set_int32_FUNCTION
#define git_config_set_int32_REQUIRED_ARGC 3
#define git_config_set_int32_OPTIONAL_ARGC 0
/* git_config_set_int32
 *
 * Parameters:
 * - cfg: git_config *
 * - name: const char *
 * - value: int32_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_set_int32(mrb_state* mrb, mrb_value self) {
  mrb_value cfg;
  char * native_name = NULL;
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &cfg, &native_name, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_set_int32(native_cfg, native_name, native_value);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_set_int64 */
/* sha: 95e7ec7398fc77e49ad87a539c9550f9757b3752692b60925ff9435728e24bc7 */
#if BIND_git_config_set_int64_FUNCTION
#define git_config_set_int64_REQUIRED_ARGC 3
#define git_config_set_int64_OPTIONAL_ARGC 0
/* git_config_set_int64
 *
 * Parameters:
 * - cfg: git_config *
 * - name: const char *
 * - value: int64_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_set_int64(mrb_state* mrb, mrb_value self) {
  mrb_value cfg;
  char * native_name = NULL;
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &cfg, &native_name, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_set_int64(native_cfg, native_name, native_value);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_set_multivar */
/* sha: 5a73800e958fa5bd5b88bcd9455e42f6f9c17acff17c092a6bb45e92d3961dfc */
#if BIND_git_config_set_multivar_FUNCTION
#define git_config_set_multivar_REQUIRED_ARGC 4
#define git_config_set_multivar_OPTIONAL_ARGC 0
/* git_config_set_multivar
 *
 * Parameters:
 * - cfg: git_config *
 * - name: const char *
 * - regexp: const char *
 * - value: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_set_multivar(mrb_state* mrb, mrb_value self) {
  mrb_value cfg;
  char * native_name = NULL;
  char * native_regexp = NULL;
  char * native_value = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzz", &cfg, &native_name, &native_regexp, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_set_multivar(native_cfg, native_name, native_regexp, native_value);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_set_string */
/* sha: 00e8a94475eb81088cc1929e3e7d4d4d9fbbf9eec7efb59ade7a18dbec34ab6a */
#if BIND_git_config_set_string_FUNCTION
#define git_config_set_string_REQUIRED_ARGC 3
#define git_config_set_string_OPTIONAL_ARGC 0
/* git_config_set_string
 *
 * Parameters:
 * - cfg: git_config *
 * - name: const char *
 * - value: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_set_string(mrb_state* mrb, mrb_value self) {
  mrb_value cfg;
  char * native_name = NULL;
  char * native_value = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &cfg, &native_name, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_set_string(native_cfg, native_name, native_value);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_snapshot */
/* sha: cac2f36ca0eb485672cd242632d676bc2134341bbb88b3f56bd5e0f2c6b9d840 */
#if BIND_git_config_snapshot_FUNCTION
#define git_config_snapshot_REQUIRED_ARGC 1
#define git_config_snapshot_OPTIONAL_ARGC 0
/* git_config_snapshot
 *
 * Parameters:
 * - config: git_config *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_snapshot(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_config * native_out = NULL;
  mrb_value config;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &config);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, config, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: config */
  git_config * native_config = (mrb_nil_p(config) ? NULL : mruby_unbox_git_config(config));

  /* Invocation */
  int native_return_value = git_config_snapshot(&native_out, native_config);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_default_new */
/* sha: 17f9facd95c6c4bf6366d3771823baeb1677ecf8720a209eb0b88cffd568c2fc */
#if BIND_git_cred_default_new_FUNCTION
#define git_cred_default_new_REQUIRED_ARGC 0
#define git_cred_default_new_OPTIONAL_ARGC 0
/* git_cred_default_new
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_default_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_cred * native_out = NULL;


  /* Invocation */
  int native_return_value = git_cred_default_new(&native_out);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_free */
/* sha: e34b48b43361ce39ec0319d29373ab57cddcfaa31abf5d19522fc1533e1d7251 */
#if BIND_git_cred_free_FUNCTION
#define git_cred_free_REQUIRED_ARGC 1
#define git_cred_free_OPTIONAL_ARGC 0
/* git_cred_free
 *
 * Parameters:
 * - cred: git_cred *
 * Return Type: void
 */
mrb_value
mrb_Git_git_cred_free(mrb_state* mrb, mrb_value self) {
  mrb_value cred;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &cred);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cred, Cred_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Cred expected");
    return mrb_nil_value();
  }

  /* Unbox param: cred */
  git_cred * native_cred = (mrb_nil_p(cred) ? NULL : mruby_unbox_git_cred(cred));

  /* Invocation */
  git_cred_free(native_cred);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_has_username */
/* sha: 0e8f85e4f41940263fd735b99c448c20832153bdec11bcf9ba3ffc9f6d2e1968 */
#if BIND_git_cred_has_username_FUNCTION
#define git_cred_has_username_REQUIRED_ARGC 1
#define git_cred_has_username_OPTIONAL_ARGC 0
/* git_cred_has_username
 *
 * Parameters:
 * - cred: git_cred *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_has_username(mrb_state* mrb, mrb_value self) {
  mrb_value cred;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &cred);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cred, Cred_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Cred expected");
    return mrb_nil_value();
  }

  /* Unbox param: cred */
  git_cred * native_cred = (mrb_nil_p(cred) ? NULL : mruby_unbox_git_cred(cred));

  /* Invocation */
  int native_return_value = git_cred_has_username(native_cred);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_ssh_custom_new */
/* sha: 0399f991fa9c594aedc7b90ab9b6f117c12817ff05fb0ea567da58d61ee5fe96 */
#if BIND_git_cred_ssh_custom_new_FUNCTION
#define git_cred_ssh_custom_new_REQUIRED_ARGC 5
#define git_cred_ssh_custom_new_OPTIONAL_ARGC 0
/* git_cred_ssh_custom_new
 *
 * Parameters:
 * - username: const char *
 * - publickey: const char *
 * - publickey_len: size_t
 * - sign_callback: git_cred_sign_callback
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_ssh_custom_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_cred * native_out = NULL;
  char * native_username = NULL;
  char * native_publickey = NULL;
  mrb_int native_publickey_len;
  mrb_value sign_callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "zzioo", &native_username, &native_publickey, &native_publickey_len, &sign_callback, &payload);

  /* Type checking */
  TODO_type_check_git_cred_sign_callback(sign_callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: sign_callback */
  git_cred_sign_callback native_sign_callback = TODO_mruby_unbox_git_cred_sign_callback(sign_callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_cred_ssh_custom_new(&native_out, native_username, native_publickey, native_publickey_len, native_sign_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_ssh_interactive_new */
/* sha: 08b0f0ff3df7e446bcea03ffee1383884930380ebea9cf128bc3d8aa400eb7be */
#if BIND_git_cred_ssh_interactive_new_FUNCTION
#define git_cred_ssh_interactive_new_REQUIRED_ARGC 3
#define git_cred_ssh_interactive_new_OPTIONAL_ARGC 0
/* git_cred_ssh_interactive_new
 *
 * Parameters:
 * - username: const char *
 * - prompt_callback: git_cred_ssh_interactive_callback
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_ssh_interactive_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_cred * native_out = NULL;
  char * native_username = NULL;
  mrb_value prompt_callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "zoo", &native_username, &prompt_callback, &payload);

  /* Type checking */
  TODO_type_check_git_cred_ssh_interactive_callback(prompt_callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: prompt_callback */
  git_cred_ssh_interactive_callback native_prompt_callback = TODO_mruby_unbox_git_cred_ssh_interactive_callback(prompt_callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_cred_ssh_interactive_new(&native_out, native_username, native_prompt_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_ssh_key_from_agent */
/* sha: 49291a90af6311256286b4b4e96de73e20b81207b17c3811588470653f2e0f35 */
#if BIND_git_cred_ssh_key_from_agent_FUNCTION
#define git_cred_ssh_key_from_agent_REQUIRED_ARGC 1
#define git_cred_ssh_key_from_agent_OPTIONAL_ARGC 0
/* git_cred_ssh_key_from_agent
 *
 * Parameters:
 * - username: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_ssh_key_from_agent(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_cred * native_out = NULL;
  char * native_username = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_username);

  /* Invocation */
  int native_return_value = git_cred_ssh_key_from_agent(&native_out, native_username);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_ssh_key_memory_new */
/* sha: 8df778344e44c922c3bfd719d54b3fb608dee6d20ad5a83dde7c119358dcfb38 */
#if BIND_git_cred_ssh_key_memory_new_FUNCTION
#define git_cred_ssh_key_memory_new_REQUIRED_ARGC 4
#define git_cred_ssh_key_memory_new_OPTIONAL_ARGC 0
/* git_cred_ssh_key_memory_new
 *
 * Parameters:
 * - username: const char *
 * - publickey: const char *
 * - privatekey: const char *
 * - passphrase: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_ssh_key_memory_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_cred * native_out = NULL;
  char * native_username = NULL;
  char * native_publickey = NULL;
  char * native_privatekey = NULL;
  char * native_passphrase = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "zzzz", &native_username, &native_publickey, &native_privatekey, &native_passphrase);

  /* Invocation */
  int native_return_value = git_cred_ssh_key_memory_new(&native_out, native_username, native_publickey, native_privatekey, native_passphrase);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_ssh_key_new */
/* sha: b8acf75a38219b6a97d502b1d72e1b20be257581fe7ab808a57fd70767a4db35 */
#if BIND_git_cred_ssh_key_new_FUNCTION
#define git_cred_ssh_key_new_REQUIRED_ARGC 4
#define git_cred_ssh_key_new_OPTIONAL_ARGC 0
/* git_cred_ssh_key_new
 *
 * Parameters:
 * - username: const char *
 * - publickey: const char *
 * - privatekey: const char *
 * - passphrase: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_ssh_key_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_cred * native_out = NULL;
  char * native_username = NULL;
  char * native_publickey = NULL;
  char * native_privatekey = NULL;
  char * native_passphrase = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "zzzz", &native_username, &native_publickey, &native_privatekey, &native_passphrase);

  /* Invocation */
  int native_return_value = git_cred_ssh_key_new(&native_out, native_username, native_publickey, native_privatekey, native_passphrase);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_username_new */
/* sha: 0f4d3c8cb4bb412853dd84b7763ab1571b504c577dd280b765a559906dc9bdde */
#if BIND_git_cred_username_new_FUNCTION
#define git_cred_username_new_REQUIRED_ARGC 1
#define git_cred_username_new_OPTIONAL_ARGC 0
/* git_cred_username_new
 *
 * Parameters:
 * - username: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_username_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_cred * native_cred = NULL;
  char * native_username = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_username);

  /* Invocation */
  int native_return_value = git_cred_username_new(&native_cred, native_username);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: cred */
  mrb_value cred = native_cred == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_cred);

  /* Add out params to results */
  mrb_ary_push(mrb, results, cred);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_userpass */
/* sha: 17808dca7e54c2b171b4ccc5f1a16751989aa82cc017a9c2867dc3337e4e1779 */
#if BIND_git_cred_userpass_FUNCTION
#define git_cred_userpass_REQUIRED_ARGC 4
#define git_cred_userpass_OPTIONAL_ARGC 0
/* git_cred_userpass
 *
 * Parameters:
 * - url: const char *
 * - user_from_url: const char *
 * - allowed_types: unsigned int
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_userpass(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_cred * native_cred = NULL;
  char * native_url = NULL;
  char * native_user_from_url = NULL;
  mrb_int native_allowed_types;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "zzio", &native_url, &native_user_from_url, &native_allowed_types, &payload);

  /* Type checking */
  TODO_type_check_void_PTR(payload);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_cred_userpass(&native_cred, native_url, native_user_from_url, native_allowed_types, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: cred */
  mrb_value cred = native_cred == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_cred);

  /* Add out params to results */
  mrb_ary_push(mrb, results, cred);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_userpass_plaintext_new */
/* sha: 7496870c2e38f16865b98b7a3b1bcf49a8f7cbbec7da0ad50295d85fd72ce8e0 */
#if BIND_git_cred_userpass_plaintext_new_FUNCTION
#define git_cred_userpass_plaintext_new_REQUIRED_ARGC 2
#define git_cred_userpass_plaintext_new_OPTIONAL_ARGC 0
/* git_cred_userpass_plaintext_new
 *
 * Parameters:
 * - username: const char *
 * - password: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_userpass_plaintext_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_cred * native_out = NULL;
  char * native_username = NULL;
  char * native_password = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "zz", &native_username, &native_password);

  /* Invocation */
  int native_return_value = git_cred_userpass_plaintext_new(&native_out, native_username, native_password);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_describe_commit */
/* sha: c849e2203bc602e7db69481ad1fd06587dafb38e19afd6394158406d2b38d37b */
#if BIND_git_describe_commit_FUNCTION
#define git_describe_commit_REQUIRED_ARGC 2
#define git_describe_commit_OPTIONAL_ARGC 0
/* git_describe_commit
 *
 * Parameters:
 * - committish: git_object *
 * - opts: git_describe_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_describe_commit(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_describe_result * native_result = NULL;
  mrb_value committish;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &committish, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, committish, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DescribeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DescribeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: committish */
  git_object * native_committish = (mrb_nil_p(committish) ? NULL : mruby_unbox_git_object(committish));

  /* Unbox param: opts */
  git_describe_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_describe_options(opts));

  /* Invocation */
  int native_return_value = git_describe_commit(&native_result, native_committish, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: result */
  mrb_value result = native_result == NULL ? mrb_nil_value() : mruby_giftwrap_git_describe_result(mrb, native_result);

  /* Add out params to results */
  mrb_ary_push(mrb, results, result);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_describe_format */
/* sha: 04036de28f496d2559ba7ff17a6cf1100a8be2bbf8ec7ac089119d5f9c3ed004 */
#if BIND_git_describe_format_FUNCTION
#define git_describe_format_REQUIRED_ARGC 3
#define git_describe_format_OPTIONAL_ARGC 0
/* git_describe_format
 *
 * Parameters:
 * - out: git_buf *
 * - result: const git_describe_result *
 * - opts: const git_describe_format_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_describe_format(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value result;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &out, &result, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, result, DescribeResult_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DescribeResult expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DescribeFormatOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DescribeFormatOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: result */
  const git_describe_result * native_result = (mrb_nil_p(result) ? NULL : mruby_unbox_git_describe_result(result));

  /* Unbox param: opts */
  const git_describe_format_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_describe_format_options(opts));

  /* Invocation */
  int native_return_value = git_describe_format(native_out, native_result, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_describe_init_format_options */
/* sha: cde5213cf35fa2886b49ea1708bd58baab0bb1db8e31b18fdd26b6ac6ace4e22 */
#if BIND_git_describe_init_format_options_FUNCTION
#define git_describe_init_format_options_REQUIRED_ARGC 2
#define git_describe_init_format_options_OPTIONAL_ARGC 0
/* git_describe_init_format_options
 *
 * Parameters:
 * - opts: git_describe_format_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_describe_init_format_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, DescribeFormatOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DescribeFormatOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_describe_format_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_describe_format_options(opts));

  /* Invocation */
  int native_return_value = git_describe_init_format_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_describe_init_options */
/* sha: 02644ebe1ebcc5cd58ab518916fba0ac044ec6497d2d6783d4befa2affd7bf58 */
#if BIND_git_describe_init_options_FUNCTION
#define git_describe_init_options_REQUIRED_ARGC 2
#define git_describe_init_options_OPTIONAL_ARGC 0
/* git_describe_init_options
 *
 * Parameters:
 * - opts: git_describe_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_describe_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, DescribeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DescribeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_describe_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_describe_options(opts));

  /* Invocation */
  int native_return_value = git_describe_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_describe_result_free */
/* sha: 6a751bc73bbed1e228c1253634886342ffb4be397c4846a9c80717b06bc846a4 */
#if BIND_git_describe_result_free_FUNCTION
#define git_describe_result_free_REQUIRED_ARGC 1
#define git_describe_result_free_OPTIONAL_ARGC 0
/* git_describe_result_free
 *
 * Parameters:
 * - result: git_describe_result *
 * Return Type: void
 */
mrb_value
mrb_Git_git_describe_result_free(mrb_state* mrb, mrb_value self) {
  mrb_value result;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &result);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, result, DescribeResult_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DescribeResult expected");
    return mrb_nil_value();
  }

  /* Unbox param: result */
  git_describe_result * native_result = (mrb_nil_p(result) ? NULL : mruby_unbox_git_describe_result(result));

  /* Invocation */
  git_describe_result_free(native_result);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_describe_workdir */
/* sha: 56613f0a1fa625a43aed7756709cfa8949e6f3815a8a54b901b5c2189f180bf7 */
#if BIND_git_describe_workdir_FUNCTION
#define git_describe_workdir_REQUIRED_ARGC 2
#define git_describe_workdir_OPTIONAL_ARGC 0
/* git_describe_workdir
 *
 * Parameters:
 * - repo: git_repository *
 * - opts: git_describe_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_describe_workdir(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_describe_result * native_out = NULL;
  mrb_value repo;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DescribeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DescribeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: opts */
  git_describe_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_describe_options(opts));

  /* Invocation */
  int native_return_value = git_describe_workdir(&native_out, native_repo, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_describe_result(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_blob_to_buffer */
/* sha: d0376808bfbd60e1dbcc2d73397243c11064068f0b92524a2709979ec88e9be0 */
#if BIND_git_diff_blob_to_buffer_FUNCTION
#define git_diff_blob_to_buffer_REQUIRED_ARGC 11
#define git_diff_blob_to_buffer_OPTIONAL_ARGC 0
/* git_diff_blob_to_buffer
 *
 * Parameters:
 * - old_blob: const git_blob *
 * - old_as_path: const char *
 * - buffer: const char *
 * - buffer_len: size_t
 * - buffer_as_path: const char *
 * - options: const git_diff_options *
 * - file_cb: git_diff_file_cb
 * - binary_cb: git_diff_binary_cb
 * - hunk_cb: git_diff_hunk_cb
 * - line_cb: git_diff_line_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_blob_to_buffer(mrb_state* mrb, mrb_value self) {
  mrb_value old_blob;
  char * native_old_as_path = NULL;
  char * native_buffer = NULL;
  mrb_int native_buffer_len;
  char * native_buffer_as_path = NULL;
  mrb_value options;
  mrb_value file_cb;
  mrb_value binary_cb;
  mrb_value hunk_cb;
  mrb_value line_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzizoooooo", &old_blob, &native_old_as_path, &native_buffer, &native_buffer_len, &native_buffer_as_path, &options, &file_cb, &binary_cb, &hunk_cb, &line_cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, old_blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, options, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_diff_file_cb(file_cb);
  TODO_type_check_git_diff_binary_cb(binary_cb);
  TODO_type_check_git_diff_hunk_cb(hunk_cb);
  TODO_type_check_git_diff_line_cb(line_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: old_blob */
  const git_blob * native_old_blob = (mrb_nil_p(old_blob) ? NULL : mruby_unbox_git_blob(old_blob));

  /* Unbox param: options */
  const git_diff_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_diff_options(options));

  /* Unbox param: file_cb */
  git_diff_file_cb native_file_cb = TODO_mruby_unbox_git_diff_file_cb(file_cb);

  /* Unbox param: binary_cb */
  git_diff_binary_cb native_binary_cb = TODO_mruby_unbox_git_diff_binary_cb(binary_cb);

  /* Unbox param: hunk_cb */
  git_diff_hunk_cb native_hunk_cb = TODO_mruby_unbox_git_diff_hunk_cb(hunk_cb);

  /* Unbox param: line_cb */
  git_diff_line_cb native_line_cb = TODO_mruby_unbox_git_diff_line_cb(line_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_diff_blob_to_buffer(native_old_blob, native_old_as_path, native_buffer, native_buffer_len, native_buffer_as_path, native_options, native_file_cb, native_binary_cb, native_hunk_cb, native_line_cb, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_blobs */
/* sha: d2ef7b96299017d40b9525c273b421922788ad83fe38db7b8045d264ad597019 */
#if BIND_git_diff_blobs_FUNCTION
#define git_diff_blobs_REQUIRED_ARGC 10
#define git_diff_blobs_OPTIONAL_ARGC 0
/* git_diff_blobs
 *
 * Parameters:
 * - old_blob: const git_blob *
 * - old_as_path: const char *
 * - new_blob: const git_blob *
 * - new_as_path: const char *
 * - options: const git_diff_options *
 * - file_cb: git_diff_file_cb
 * - binary_cb: git_diff_binary_cb
 * - hunk_cb: git_diff_hunk_cb
 * - line_cb: git_diff_line_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_blobs(mrb_state* mrb, mrb_value self) {
  mrb_value old_blob;
  char * native_old_as_path = NULL;
  mrb_value new_blob;
  char * native_new_as_path = NULL;
  mrb_value options;
  mrb_value file_cb;
  mrb_value binary_cb;
  mrb_value hunk_cb;
  mrb_value line_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozozoooooo", &old_blob, &native_old_as_path, &new_blob, &native_new_as_path, &options, &file_cb, &binary_cb, &hunk_cb, &line_cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, old_blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, new_blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, options, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_diff_file_cb(file_cb);
  TODO_type_check_git_diff_binary_cb(binary_cb);
  TODO_type_check_git_diff_hunk_cb(hunk_cb);
  TODO_type_check_git_diff_line_cb(line_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: old_blob */
  const git_blob * native_old_blob = (mrb_nil_p(old_blob) ? NULL : mruby_unbox_git_blob(old_blob));

  /* Unbox param: new_blob */
  const git_blob * native_new_blob = (mrb_nil_p(new_blob) ? NULL : mruby_unbox_git_blob(new_blob));

  /* Unbox param: options */
  const git_diff_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_diff_options(options));

  /* Unbox param: file_cb */
  git_diff_file_cb native_file_cb = TODO_mruby_unbox_git_diff_file_cb(file_cb);

  /* Unbox param: binary_cb */
  git_diff_binary_cb native_binary_cb = TODO_mruby_unbox_git_diff_binary_cb(binary_cb);

  /* Unbox param: hunk_cb */
  git_diff_hunk_cb native_hunk_cb = TODO_mruby_unbox_git_diff_hunk_cb(hunk_cb);

  /* Unbox param: line_cb */
  git_diff_line_cb native_line_cb = TODO_mruby_unbox_git_diff_line_cb(line_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_diff_blobs(native_old_blob, native_old_as_path, native_new_blob, native_new_as_path, native_options, native_file_cb, native_binary_cb, native_hunk_cb, native_line_cb, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_buffers */
/* sha: e3eb2a48e5e2e111b27c63a044d1d37f45fa6567d2e15a4686bae5eca4af4b60 */
#if BIND_git_diff_buffers_FUNCTION
#define git_diff_buffers_REQUIRED_ARGC 12
#define git_diff_buffers_OPTIONAL_ARGC 0
/* git_diff_buffers
 *
 * Parameters:
 * - old_buffer: const void *
 * - old_len: size_t
 * - old_as_path: const char *
 * - new_buffer: const void *
 * - new_len: size_t
 * - new_as_path: const char *
 * - options: const git_diff_options *
 * - file_cb: git_diff_file_cb
 * - binary_cb: git_diff_binary_cb
 * - hunk_cb: git_diff_hunk_cb
 * - line_cb: git_diff_line_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_buffers(mrb_state* mrb, mrb_value self) {
  mrb_value old_buffer;
  mrb_int native_old_len;
  char * native_old_as_path = NULL;
  mrb_value new_buffer;
  mrb_int native_new_len;
  char * native_new_as_path = NULL;
  mrb_value options;
  mrb_value file_cb;
  mrb_value binary_cb;
  mrb_value hunk_cb;
  mrb_value line_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oizoizoooooo", &old_buffer, &native_old_len, &native_old_as_path, &new_buffer, &native_new_len, &native_new_as_path, &options, &file_cb, &binary_cb, &hunk_cb, &line_cb, &payload);

  /* Type checking */
  TODO_type_check_void_PTR(old_buffer);
  TODO_type_check_void_PTR(new_buffer);
  if (!mrb_obj_is_kind_of(mrb, options, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_diff_file_cb(file_cb);
  TODO_type_check_git_diff_binary_cb(binary_cb);
  TODO_type_check_git_diff_hunk_cb(hunk_cb);
  TODO_type_check_git_diff_line_cb(line_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: old_buffer */
  const void * native_old_buffer = TODO_mruby_unbox_void_PTR(old_buffer);

  /* Unbox param: new_buffer */
  const void * native_new_buffer = TODO_mruby_unbox_void_PTR(new_buffer);

  /* Unbox param: options */
  const git_diff_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_diff_options(options));

  /* Unbox param: file_cb */
  git_diff_file_cb native_file_cb = TODO_mruby_unbox_git_diff_file_cb(file_cb);

  /* Unbox param: binary_cb */
  git_diff_binary_cb native_binary_cb = TODO_mruby_unbox_git_diff_binary_cb(binary_cb);

  /* Unbox param: hunk_cb */
  git_diff_hunk_cb native_hunk_cb = TODO_mruby_unbox_git_diff_hunk_cb(hunk_cb);

  /* Unbox param: line_cb */
  git_diff_line_cb native_line_cb = TODO_mruby_unbox_git_diff_line_cb(line_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_diff_buffers(native_old_buffer, native_old_len, native_old_as_path, native_new_buffer, native_new_len, native_new_as_path, native_options, native_file_cb, native_binary_cb, native_hunk_cb, native_line_cb, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_commit_as_email */
/* sha: bf48c9d9be4584ec07f645c7128d19c3dcea6d73188b0c7856edbca23659f860 */
#if BIND_git_diff_commit_as_email_FUNCTION
#define git_diff_commit_as_email_REQUIRED_ARGC 7
#define git_diff_commit_as_email_OPTIONAL_ARGC 0
/* git_diff_commit_as_email
 *
 * Parameters:
 * - out: git_buf *
 * - repo: git_repository *
 * - commit: git_commit *
 * - patch_no: size_t
 * - total_patches: size_t
 * - flags: git_diff_format_email_flags_t
 * - diff_opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_commit_as_email(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;
  mrb_value commit;
  mrb_int native_patch_no;
  mrb_int native_total_patches;
  mrb_int native_flags;
  mrb_value diff_opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oooiiio", &out, &repo, &commit, &native_patch_no, &native_total_patches, &native_flags, &diff_opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, diff_opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: commit */
  git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Unbox param: diff_opts */
  const git_diff_options * native_diff_opts = (mrb_nil_p(diff_opts) ? NULL : mruby_unbox_git_diff_options(diff_opts));

  /* Invocation */
  int native_return_value = git_diff_commit_as_email(native_out, native_repo, native_commit, native_patch_no, native_total_patches, native_flags, native_diff_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_find_init_options */
/* sha: 0cc516c17c49ca70f2594f2c37dc4360c38f87bbc38d1b64faa08b98f3e533a3 */
#if BIND_git_diff_find_init_options_FUNCTION
#define git_diff_find_init_options_REQUIRED_ARGC 2
#define git_diff_find_init_options_OPTIONAL_ARGC 0
/* git_diff_find_init_options
 *
 * Parameters:
 * - opts: git_diff_find_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_find_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, DiffFindOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffFindOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_diff_find_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_find_options(opts));

  /* Invocation */
  int native_return_value = git_diff_find_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_find_similar */
/* sha: b6c1ee264d1189a94b501e9b78913f4ca4ea7a8683a4806f8394884fd14e0110 */
#if BIND_git_diff_find_similar_FUNCTION
#define git_diff_find_similar_REQUIRED_ARGC 2
#define git_diff_find_similar_OPTIONAL_ARGC 0
/* git_diff_find_similar
 *
 * Parameters:
 * - diff: git_diff *
 * - options: const git_diff_find_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_find_similar(mrb_state* mrb, mrb_value self) {
  mrb_value diff;
  mrb_value options;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &diff, &options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, options, DiffFindOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffFindOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Unbox param: options */
  const git_diff_find_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_diff_find_options(options));

  /* Invocation */
  int native_return_value = git_diff_find_similar(native_diff, native_options);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_foreach */
/* sha: 80b42033a06c95f2d63c0c83e01aaad0d584c988fab7821d831354a9ca73ed13 */
#if BIND_git_diff_foreach_FUNCTION
#define git_diff_foreach_REQUIRED_ARGC 6
#define git_diff_foreach_OPTIONAL_ARGC 0
/* git_diff_foreach
 *
 * Parameters:
 * - diff: git_diff *
 * - file_cb: git_diff_file_cb
 * - binary_cb: git_diff_binary_cb
 * - hunk_cb: git_diff_hunk_cb
 * - line_cb: git_diff_line_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value diff;
  mrb_value file_cb;
  mrb_value binary_cb;
  mrb_value hunk_cb;
  mrb_value line_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oooooo", &diff, &file_cb, &binary_cb, &hunk_cb, &line_cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_diff_file_cb(file_cb);
  TODO_type_check_git_diff_binary_cb(binary_cb);
  TODO_type_check_git_diff_hunk_cb(hunk_cb);
  TODO_type_check_git_diff_line_cb(line_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Unbox param: file_cb */
  git_diff_file_cb native_file_cb = TODO_mruby_unbox_git_diff_file_cb(file_cb);

  /* Unbox param: binary_cb */
  git_diff_binary_cb native_binary_cb = TODO_mruby_unbox_git_diff_binary_cb(binary_cb);

  /* Unbox param: hunk_cb */
  git_diff_hunk_cb native_hunk_cb = TODO_mruby_unbox_git_diff_hunk_cb(hunk_cb);

  /* Unbox param: line_cb */
  git_diff_line_cb native_line_cb = TODO_mruby_unbox_git_diff_line_cb(line_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_diff_foreach(native_diff, native_file_cb, native_binary_cb, native_hunk_cb, native_line_cb, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_format_email */
/* sha: c769314e7a0e2e4ed569205540965403acb314764ee778fe20615da88b86bc45 */
#if BIND_git_diff_format_email_FUNCTION
#define git_diff_format_email_REQUIRED_ARGC 3
#define git_diff_format_email_OPTIONAL_ARGC 0
/* git_diff_format_email
 *
 * Parameters:
 * - out: git_buf *
 * - diff: git_diff *
 * - opts: const git_diff_format_email_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_format_email(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value diff;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &out, &diff, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffFormatEmailOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffFormatEmailOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Unbox param: opts */
  const git_diff_format_email_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_format_email_options(opts));

  /* Invocation */
  int native_return_value = git_diff_format_email(native_out, native_diff, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_format_email_init_options */
/* sha: bfaaf7351ffe0e63a12fe9f0cfdb50585773098345fbf4d6f8bf658ab0e2ee1d */
#if BIND_git_diff_format_email_init_options_FUNCTION
#define git_diff_format_email_init_options_REQUIRED_ARGC 2
#define git_diff_format_email_init_options_OPTIONAL_ARGC 0
/* git_diff_format_email_init_options
 *
 * Parameters:
 * - opts: git_diff_format_email_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_format_email_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, DiffFormatEmailOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffFormatEmailOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_diff_format_email_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_format_email_options(opts));

  /* Invocation */
  int native_return_value = git_diff_format_email_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_free */
/* sha: f6f815e87023d5045c47584d10bb5f8e350a07e56e79fbff577f71bf763c62b3 */
#if BIND_git_diff_free_FUNCTION
#define git_diff_free_REQUIRED_ARGC 1
#define git_diff_free_OPTIONAL_ARGC 0
/* git_diff_free
 *
 * Parameters:
 * - diff: git_diff *
 * Return Type: void
 */
mrb_value
mrb_Git_git_diff_free(mrb_state* mrb, mrb_value self) {
  mrb_value diff;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &diff);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Invocation */
  git_diff_free(native_diff);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_get_delta */
/* sha: 255195e3f819c120797d923c670cfe25563181792797585cd535dd5bfdeb8bb9 */
#if BIND_git_diff_get_delta_FUNCTION
#define git_diff_get_delta_REQUIRED_ARGC 2
#define git_diff_get_delta_OPTIONAL_ARGC 0
/* git_diff_get_delta
 *
 * Parameters:
 * - diff: const git_diff *
 * - idx: size_t
 * Return Type: const git_diff_delta *
 */
mrb_value
mrb_Git_git_diff_get_delta(mrb_state* mrb, mrb_value self) {
  mrb_value diff;
  mrb_int native_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &diff, &native_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  const git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Invocation */
  const git_diff_delta * native_return_value = git_diff_get_delta(native_diff, native_idx);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_diff_delta(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_get_stats */
/* sha: c48a9a53f0337c6a8c3ffc84a65e9cae3e76335563c075930c70a488ad483522 */
#if BIND_git_diff_get_stats_FUNCTION
#define git_diff_get_stats_REQUIRED_ARGC 1
#define git_diff_get_stats_OPTIONAL_ARGC 0
/* git_diff_get_stats
 *
 * Parameters:
 * - diff: git_diff *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_get_stats(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_diff_stats * native_out = NULL;
  mrb_value diff;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &diff);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Invocation */
  int native_return_value = git_diff_get_stats(&native_out, native_diff);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_diff_stats(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_index_to_index */
/* sha: e22a4c70f4c99bf6b56453f5ec347bfba8f56f2004dbeb7478921f27ad617b4b */
#if BIND_git_diff_index_to_index_FUNCTION
#define git_diff_index_to_index_REQUIRED_ARGC 4
#define git_diff_index_to_index_OPTIONAL_ARGC 0
/* git_diff_index_to_index
 *
 * Parameters:
 * - repo: git_repository *
 * - old_index: git_index *
 * - new_index: git_index *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_index_to_index(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_diff * native_diff = NULL;
  mrb_value repo;
  mrb_value old_index;
  mrb_value new_index;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &repo, &old_index, &new_index, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, old_index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, new_index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: old_index */
  git_index * native_old_index = (mrb_nil_p(old_index) ? NULL : mruby_unbox_git_index(old_index));

  /* Unbox param: new_index */
  git_index * native_new_index = (mrb_nil_p(new_index) ? NULL : mruby_unbox_git_index(new_index));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_diff_index_to_index(&native_diff, native_repo, native_old_index, native_new_index, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: diff */
  mrb_value diff = native_diff == NULL ? mrb_nil_value() : mruby_giftwrap_git_diff(mrb, native_diff);

  /* Add out params to results */
  mrb_ary_push(mrb, results, diff);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_index_to_workdir */
/* sha: db4aa5b21191421e6928da610370ac8dcc58fb6c38b0907a34cea67cf474c629 */
#if BIND_git_diff_index_to_workdir_FUNCTION
#define git_diff_index_to_workdir_REQUIRED_ARGC 3
#define git_diff_index_to_workdir_OPTIONAL_ARGC 0
/* git_diff_index_to_workdir
 *
 * Parameters:
 * - repo: git_repository *
 * - index: git_index *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_index_to_workdir(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_diff * native_diff = NULL;
  mrb_value repo;
  mrb_value index;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &index, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_diff_index_to_workdir(&native_diff, native_repo, native_index, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: diff */
  mrb_value diff = native_diff == NULL ? mrb_nil_value() : mruby_giftwrap_git_diff(mrb, native_diff);

  /* Add out params to results */
  mrb_ary_push(mrb, results, diff);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_init_options */
/* sha: da731170a75046c298557641179688b0aa4242fccd3c3c38cf35a685613f8717 */
#if BIND_git_diff_init_options_FUNCTION
#define git_diff_init_options_REQUIRED_ARGC 2
#define git_diff_init_options_OPTIONAL_ARGC 0
/* git_diff_init_options
 *
 * Parameters:
 * - opts: git_diff_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_diff_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_is_sorted_icase */
/* sha: 376537f3472add08b09ba35c833b8247228a54bdb7b2160137950f1eb618a08a */
#if BIND_git_diff_is_sorted_icase_FUNCTION
#define git_diff_is_sorted_icase_REQUIRED_ARGC 1
#define git_diff_is_sorted_icase_OPTIONAL_ARGC 0
/* git_diff_is_sorted_icase
 *
 * Parameters:
 * - diff: const git_diff *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_is_sorted_icase(mrb_state* mrb, mrb_value self) {
  mrb_value diff;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &diff);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  const git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Invocation */
  int native_return_value = git_diff_is_sorted_icase(native_diff);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_merge */
/* sha: b4ad8015ff57208c203ede9c15db717b8fa1c120f798e10def838b0ae5a138c8 */
#if BIND_git_diff_merge_FUNCTION
#define git_diff_merge_REQUIRED_ARGC 2
#define git_diff_merge_OPTIONAL_ARGC 0
/* git_diff_merge
 *
 * Parameters:
 * - onto: git_diff *
 * - from: const git_diff *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_merge(mrb_state* mrb, mrb_value self) {
  mrb_value onto;
  mrb_value from;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &onto, &from);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, onto, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, from, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: onto */
  git_diff * native_onto = (mrb_nil_p(onto) ? NULL : mruby_unbox_git_diff(onto));

  /* Unbox param: from */
  const git_diff * native_from = (mrb_nil_p(from) ? NULL : mruby_unbox_git_diff(from));

  /* Invocation */
  int native_return_value = git_diff_merge(native_onto, native_from);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_num_deltas */
/* sha: db2c239b77d134d473a5d0790203d710782060c0efe455ec61e3defa47d0cbbc */
#if BIND_git_diff_num_deltas_FUNCTION
#define git_diff_num_deltas_REQUIRED_ARGC 1
#define git_diff_num_deltas_OPTIONAL_ARGC 0
/* git_diff_num_deltas
 *
 * Parameters:
 * - diff: const git_diff *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_diff_num_deltas(mrb_state* mrb, mrb_value self) {
  mrb_value diff;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &diff);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  const git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Invocation */
  size_t native_return_value = git_diff_num_deltas(native_diff);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_num_deltas_of_type */
/* sha: c96fa9701c14d76bc8605d01bb2c1ef96de6d1b7c20cfffe4c56832c69192077 */
#if BIND_git_diff_num_deltas_of_type_FUNCTION
#define git_diff_num_deltas_of_type_REQUIRED_ARGC 2
#define git_diff_num_deltas_of_type_OPTIONAL_ARGC 0
/* git_diff_num_deltas_of_type
 *
 * Parameters:
 * - diff: const git_diff *
 * - type: git_delta_t
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_diff_num_deltas_of_type(mrb_state* mrb, mrb_value self) {
  mrb_value diff;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &diff, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  const git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Invocation */
  size_t native_return_value = git_diff_num_deltas_of_type(native_diff, native_type);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_print */
/* sha: 49e4323625492b18277158b1e925aef577e3545308f8f83709ee81bb4aaf3567 */
#if BIND_git_diff_print_FUNCTION
#define git_diff_print_REQUIRED_ARGC 4
#define git_diff_print_OPTIONAL_ARGC 0
/* git_diff_print
 *
 * Parameters:
 * - diff: git_diff *
 * - format: git_diff_format_t
 * - print_cb: git_diff_line_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_print(mrb_state* mrb, mrb_value self) {
  mrb_value diff;
  mrb_int native_format;
  mrb_value print_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &diff, &native_format, &print_cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_diff_line_cb(print_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Unbox param: print_cb */
  git_diff_line_cb native_print_cb = TODO_mruby_unbox_git_diff_line_cb(print_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_diff_print(native_diff, native_format, native_print_cb, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_stats_deletions */
/* sha: 42017efb31f26c77a09c7ddb857975ceccf22ee2f53db875f55ae0313b44c8da */
#if BIND_git_diff_stats_deletions_FUNCTION
#define git_diff_stats_deletions_REQUIRED_ARGC 1
#define git_diff_stats_deletions_OPTIONAL_ARGC 0
/* git_diff_stats_deletions
 *
 * Parameters:
 * - stats: const git_diff_stats *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_diff_stats_deletions(mrb_state* mrb, mrb_value self) {
  mrb_value stats;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &stats);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, stats, DiffStats_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffStats expected");
    return mrb_nil_value();
  }

  /* Unbox param: stats */
  const git_diff_stats * native_stats = (mrb_nil_p(stats) ? NULL : mruby_unbox_git_diff_stats(stats));

  /* Invocation */
  size_t native_return_value = git_diff_stats_deletions(native_stats);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_stats_files_changed */
/* sha: 7865699faa2836a35302f73089f5511cc5d22e103714a01a5dc5666ce9016c09 */
#if BIND_git_diff_stats_files_changed_FUNCTION
#define git_diff_stats_files_changed_REQUIRED_ARGC 1
#define git_diff_stats_files_changed_OPTIONAL_ARGC 0
/* git_diff_stats_files_changed
 *
 * Parameters:
 * - stats: const git_diff_stats *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_diff_stats_files_changed(mrb_state* mrb, mrb_value self) {
  mrb_value stats;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &stats);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, stats, DiffStats_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffStats expected");
    return mrb_nil_value();
  }

  /* Unbox param: stats */
  const git_diff_stats * native_stats = (mrb_nil_p(stats) ? NULL : mruby_unbox_git_diff_stats(stats));

  /* Invocation */
  size_t native_return_value = git_diff_stats_files_changed(native_stats);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_stats_free */
/* sha: 6390bba07f449701ebacdf6f9a4cd204cb0c7b2a72cddf77d39426b39bc8f3bc */
#if BIND_git_diff_stats_free_FUNCTION
#define git_diff_stats_free_REQUIRED_ARGC 1
#define git_diff_stats_free_OPTIONAL_ARGC 0
/* git_diff_stats_free
 *
 * Parameters:
 * - stats: git_diff_stats *
 * Return Type: void
 */
mrb_value
mrb_Git_git_diff_stats_free(mrb_state* mrb, mrb_value self) {
  mrb_value stats;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &stats);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, stats, DiffStats_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffStats expected");
    return mrb_nil_value();
  }

  /* Unbox param: stats */
  git_diff_stats * native_stats = (mrb_nil_p(stats) ? NULL : mruby_unbox_git_diff_stats(stats));

  /* Invocation */
  git_diff_stats_free(native_stats);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_stats_insertions */
/* sha: 0ccdefb5bd24b438163dedc04f62939d573d5ffc8e7dda8a7ce78292b6329409 */
#if BIND_git_diff_stats_insertions_FUNCTION
#define git_diff_stats_insertions_REQUIRED_ARGC 1
#define git_diff_stats_insertions_OPTIONAL_ARGC 0
/* git_diff_stats_insertions
 *
 * Parameters:
 * - stats: const git_diff_stats *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_diff_stats_insertions(mrb_state* mrb, mrb_value self) {
  mrb_value stats;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &stats);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, stats, DiffStats_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffStats expected");
    return mrb_nil_value();
  }

  /* Unbox param: stats */
  const git_diff_stats * native_stats = (mrb_nil_p(stats) ? NULL : mruby_unbox_git_diff_stats(stats));

  /* Invocation */
  size_t native_return_value = git_diff_stats_insertions(native_stats);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_stats_to_buf */
/* sha: 3b7e1f5eaf83863a64465a65c935f28e46127f7947da1766a93a4126af10b084 */
#if BIND_git_diff_stats_to_buf_FUNCTION
#define git_diff_stats_to_buf_REQUIRED_ARGC 4
#define git_diff_stats_to_buf_OPTIONAL_ARGC 0
/* git_diff_stats_to_buf
 *
 * Parameters:
 * - out: git_buf *
 * - stats: const git_diff_stats *
 * - format: git_diff_stats_format_t
 * - width: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_stats_to_buf(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value stats;
  mrb_int native_format;
  mrb_int native_width;

  /* Fetch the args */
  mrb_get_args(mrb, "ooii", &out, &stats, &native_format, &native_width);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, stats, DiffStats_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffStats expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: stats */
  const git_diff_stats * native_stats = (mrb_nil_p(stats) ? NULL : mruby_unbox_git_diff_stats(stats));

  /* Invocation */
  int native_return_value = git_diff_stats_to_buf(native_out, native_stats, native_format, native_width);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_status_char */
/* sha: 978e6fe5505548057a593db4b367cf58c06055874f7fc6358698eeceab1e4c84 */
#if BIND_git_diff_status_char_FUNCTION
#define git_diff_status_char_REQUIRED_ARGC 1
#define git_diff_status_char_OPTIONAL_ARGC 0
/* git_diff_status_char
 *
 * Parameters:
 * - status: git_delta_t
 * Return Type: char
 */
mrb_value
mrb_Git_git_diff_status_char(mrb_state* mrb, mrb_value self) {
  mrb_int native_status;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_status);

  /* Invocation */
  char native_return_value = git_diff_status_char(native_status);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_tree_to_index */
/* sha: 7c368ac9f10df0987e83c5ef53529172065ec00cb009c7e479ae5974d269eed8 */
#if BIND_git_diff_tree_to_index_FUNCTION
#define git_diff_tree_to_index_REQUIRED_ARGC 4
#define git_diff_tree_to_index_OPTIONAL_ARGC 0
/* git_diff_tree_to_index
 *
 * Parameters:
 * - repo: git_repository *
 * - old_tree: git_tree *
 * - index: git_index *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_tree_to_index(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_diff * native_diff = NULL;
  mrb_value repo;
  mrb_value old_tree;
  mrb_value index;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &repo, &old_tree, &index, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, old_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: old_tree */
  git_tree * native_old_tree = (mrb_nil_p(old_tree) ? NULL : mruby_unbox_git_tree(old_tree));

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_diff_tree_to_index(&native_diff, native_repo, native_old_tree, native_index, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: diff */
  mrb_value diff = native_diff == NULL ? mrb_nil_value() : mruby_giftwrap_git_diff(mrb, native_diff);

  /* Add out params to results */
  mrb_ary_push(mrb, results, diff);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_tree_to_tree */
/* sha: 9e8640b300b647be88af00ab265480745343c5a2f10a27e4bbd7513f11d7d0cc */
#if BIND_git_diff_tree_to_tree_FUNCTION
#define git_diff_tree_to_tree_REQUIRED_ARGC 4
#define git_diff_tree_to_tree_OPTIONAL_ARGC 0
/* git_diff_tree_to_tree
 *
 * Parameters:
 * - repo: git_repository *
 * - old_tree: git_tree *
 * - new_tree: git_tree *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_tree_to_tree(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_diff * native_diff = NULL;
  mrb_value repo;
  mrb_value old_tree;
  mrb_value new_tree;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &repo, &old_tree, &new_tree, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, old_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, new_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: old_tree */
  git_tree * native_old_tree = (mrb_nil_p(old_tree) ? NULL : mruby_unbox_git_tree(old_tree));

  /* Unbox param: new_tree */
  git_tree * native_new_tree = (mrb_nil_p(new_tree) ? NULL : mruby_unbox_git_tree(new_tree));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_diff_tree_to_tree(&native_diff, native_repo, native_old_tree, native_new_tree, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: diff */
  mrb_value diff = native_diff == NULL ? mrb_nil_value() : mruby_giftwrap_git_diff(mrb, native_diff);

  /* Add out params to results */
  mrb_ary_push(mrb, results, diff);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_tree_to_workdir */
/* sha: e707d8af310ffabad7faf05809973d498d26798b21f1338166ece7c94afc2dc2 */
#if BIND_git_diff_tree_to_workdir_FUNCTION
#define git_diff_tree_to_workdir_REQUIRED_ARGC 3
#define git_diff_tree_to_workdir_OPTIONAL_ARGC 0
/* git_diff_tree_to_workdir
 *
 * Parameters:
 * - repo: git_repository *
 * - old_tree: git_tree *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_tree_to_workdir(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_diff * native_diff = NULL;
  mrb_value repo;
  mrb_value old_tree;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &old_tree, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, old_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: old_tree */
  git_tree * native_old_tree = (mrb_nil_p(old_tree) ? NULL : mruby_unbox_git_tree(old_tree));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_diff_tree_to_workdir(&native_diff, native_repo, native_old_tree, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: diff */
  mrb_value diff = native_diff == NULL ? mrb_nil_value() : mruby_giftwrap_git_diff(mrb, native_diff);

  /* Add out params to results */
  mrb_ary_push(mrb, results, diff);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_tree_to_workdir_with_index */
/* sha: bbad4d93ce9b114fe3c6318c7a36fcdd24c1c97db323af3947d266a2a5d7349f */
#if BIND_git_diff_tree_to_workdir_with_index_FUNCTION
#define git_diff_tree_to_workdir_with_index_REQUIRED_ARGC 3
#define git_diff_tree_to_workdir_with_index_OPTIONAL_ARGC 0
/* git_diff_tree_to_workdir_with_index
 *
 * Parameters:
 * - repo: git_repository *
 * - old_tree: git_tree *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_tree_to_workdir_with_index(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_diff * native_diff = NULL;
  mrb_value repo;
  mrb_value old_tree;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &old_tree, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, old_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: old_tree */
  git_tree * native_old_tree = (mrb_nil_p(old_tree) ? NULL : mruby_unbox_git_tree(old_tree));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_diff_tree_to_workdir_with_index(&native_diff, native_repo, native_old_tree, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: diff */
  mrb_value diff = native_diff == NULL ? mrb_nil_value() : mruby_giftwrap_git_diff(mrb, native_diff);

  /* Add out params to results */
  mrb_ary_push(mrb, results, diff);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_fetch_init_options */
/* sha: f0170e44204c6b612a43f8cc31d0ec98abe987afac36730b4fad7e28862216a1 */
#if BIND_git_fetch_init_options_FUNCTION
#define git_fetch_init_options_REQUIRED_ARGC 2
#define git_fetch_init_options_OPTIONAL_ARGC 0
/* git_fetch_init_options
 *
 * Parameters:
 * - opts: git_fetch_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_fetch_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, FetchOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FetchOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_fetch_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_fetch_options(opts));

  /* Invocation */
  int native_return_value = git_fetch_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_apply_to_blob */
/* sha: 1a382fa8642dde578b82f43cf9f232eaa0ef82f4d192dd3d972539601d321d64 */
#if BIND_git_filter_list_apply_to_blob_FUNCTION
#define git_filter_list_apply_to_blob_REQUIRED_ARGC 3
#define git_filter_list_apply_to_blob_OPTIONAL_ARGC 0
/* git_filter_list_apply_to_blob
 *
 * Parameters:
 * - out: git_buf *
 * - filters: git_filter_list *
 * - blob: git_blob *
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_apply_to_blob(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value filters;
  mrb_value blob;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &out, &filters, &blob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Unbox param: blob */
  git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  int native_return_value = git_filter_list_apply_to_blob(native_out, native_filters, native_blob);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_apply_to_data */
/* sha: b0939e2b131863527c21cde645254f303c80fef102f43286e5b2883fc4c9aa46 */
#if BIND_git_filter_list_apply_to_data_FUNCTION
#define git_filter_list_apply_to_data_REQUIRED_ARGC 3
#define git_filter_list_apply_to_data_OPTIONAL_ARGC 0
/* git_filter_list_apply_to_data
 *
 * Parameters:
 * - out: git_buf *
 * - filters: git_filter_list *
 * - in: git_buf *
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_apply_to_data(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value filters;
  mrb_value in;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &out, &filters, &in);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, in, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Unbox param: in */
  git_buf * native_in = (mrb_nil_p(in) ? NULL : mruby_unbox_git_buf(in));

  /* Invocation */
  int native_return_value = git_filter_list_apply_to_data(native_out, native_filters, native_in);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_apply_to_file */
/* sha: 156031b96ec4635a4d88ca169765f2b805a82d62d35f027dd476e9949b5653f8 */
#if BIND_git_filter_list_apply_to_file_FUNCTION
#define git_filter_list_apply_to_file_REQUIRED_ARGC 4
#define git_filter_list_apply_to_file_OPTIONAL_ARGC 0
/* git_filter_list_apply_to_file
 *
 * Parameters:
 * - out: git_buf *
 * - filters: git_filter_list *
 * - repo: git_repository *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_apply_to_file(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value filters;
  mrb_value repo;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oooz", &out, &filters, &repo, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_filter_list_apply_to_file(native_out, native_filters, native_repo, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_contains */
/* sha: 5205df6fd71651332f37c30a53fcc15d7a8cd2f6a13705aef03d26bb856fd971 */
#if BIND_git_filter_list_contains_FUNCTION
#define git_filter_list_contains_REQUIRED_ARGC 2
#define git_filter_list_contains_OPTIONAL_ARGC 0
/* git_filter_list_contains
 *
 * Parameters:
 * - filters: git_filter_list *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_contains(mrb_state* mrb, mrb_value self) {
  mrb_value filters;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &filters, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Invocation */
  int native_return_value = git_filter_list_contains(native_filters, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_free */
/* sha: a0adc786d30126a9c5a887f00d0de7418320066a1ba3cb81890cf157f73c4071 */
#if BIND_git_filter_list_free_FUNCTION
#define git_filter_list_free_REQUIRED_ARGC 1
#define git_filter_list_free_OPTIONAL_ARGC 0
/* git_filter_list_free
 *
 * Parameters:
 * - filters: git_filter_list *
 * Return Type: void
 */
mrb_value
mrb_Git_git_filter_list_free(mrb_state* mrb, mrb_value self) {
  mrb_value filters;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &filters);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Invocation */
  git_filter_list_free(native_filters);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_load */
/* sha: ad72e14386bdb0ed2ad0e612db8e9890bbd7ffe7106b9c4f1eb340bb1ddf3b53 */
#if BIND_git_filter_list_load_FUNCTION
#define git_filter_list_load_REQUIRED_ARGC 5
#define git_filter_list_load_OPTIONAL_ARGC 0
/* git_filter_list_load
 *
 * Parameters:
 * - repo: git_repository *
 * - blob: git_blob *
 * - path: const char *
 * - mode: git_filter_mode_t
 * - flags: uint32_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_load(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_filter_list * native_filters = NULL;
  mrb_value repo;
  mrb_value blob;
  char * native_path = NULL;
  mrb_int native_mode;
  mrb_int native_flags;

  /* Fetch the args */
  mrb_get_args(mrb, "oozii", &repo, &blob, &native_path, &native_mode, &native_flags);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: blob */
  git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  int native_return_value = git_filter_list_load(&native_filters, native_repo, native_blob, native_path, native_mode, native_flags);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: filters */
  mrb_value filters = native_filters == NULL ? mrb_nil_value() : mruby_giftwrap_git_filter_list(mrb, native_filters);

  /* Add out params to results */
  mrb_ary_push(mrb, results, filters);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_stream_blob */
/* sha: 95a0ba104a67a4d504d408ebc1ee8d2d53d7afaebb20b81ae7472db9e0071e07 */
#if BIND_git_filter_list_stream_blob_FUNCTION
#define git_filter_list_stream_blob_REQUIRED_ARGC 3
#define git_filter_list_stream_blob_OPTIONAL_ARGC 0
/* git_filter_list_stream_blob
 *
 * Parameters:
 * - filters: git_filter_list *
 * - blob: git_blob *
 * - target: git_writestream *
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_stream_blob(mrb_state* mrb, mrb_value self) {
  mrb_value filters;
  mrb_value blob;
  mrb_value target;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &filters, &blob, &target);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Writestream_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Writestream expected");
    return mrb_nil_value();
  }

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Unbox param: blob */
  git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Unbox param: target */
  git_writestream * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_writestream(target));

  /* Invocation */
  int native_return_value = git_filter_list_stream_blob(native_filters, native_blob, native_target);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_stream_data */
/* sha: 0390e273cb8a7ededafc95e8d0f080c903f90af839c377924de4a27b523a3a6a */
#if BIND_git_filter_list_stream_data_FUNCTION
#define git_filter_list_stream_data_REQUIRED_ARGC 3
#define git_filter_list_stream_data_OPTIONAL_ARGC 0
/* git_filter_list_stream_data
 *
 * Parameters:
 * - filters: git_filter_list *
 * - data: git_buf *
 * - target: git_writestream *
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_stream_data(mrb_state* mrb, mrb_value self) {
  mrb_value filters;
  mrb_value data;
  mrb_value target;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &filters, &data, &target);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, data, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Writestream_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Writestream expected");
    return mrb_nil_value();
  }

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Unbox param: data */
  git_buf * native_data = (mrb_nil_p(data) ? NULL : mruby_unbox_git_buf(data));

  /* Unbox param: target */
  git_writestream * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_writestream(target));

  /* Invocation */
  int native_return_value = git_filter_list_stream_data(native_filters, native_data, native_target);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_stream_file */
/* sha: 1b6cec8ff893966081d41d7a15765f4caf1e74a987753ac6dfd135bc5fe60154 */
#if BIND_git_filter_list_stream_file_FUNCTION
#define git_filter_list_stream_file_REQUIRED_ARGC 4
#define git_filter_list_stream_file_OPTIONAL_ARGC 0
/* git_filter_list_stream_file
 *
 * Parameters:
 * - filters: git_filter_list *
 * - repo: git_repository *
 * - path: const char *
 * - target: git_writestream *
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_stream_file(mrb_state* mrb, mrb_value self) {
  mrb_value filters;
  mrb_value repo;
  char * native_path = NULL;
  mrb_value target;

  /* Fetch the args */
  mrb_get_args(mrb, "oozo", &filters, &repo, &native_path, &target);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Writestream_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Writestream expected");
    return mrb_nil_value();
  }

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: target */
  git_writestream * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_writestream(target));

  /* Invocation */
  int native_return_value = git_filter_list_stream_file(native_filters, native_repo, native_path, native_target);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_graph_ahead_behind */
/* sha: 704eb75430132a3d698926d8ebabefd72fb243e16ec7b20c39a9f06ab9eeb1c6 */
#if BIND_git_graph_ahead_behind_FUNCTION
#define git_graph_ahead_behind_REQUIRED_ARGC 3
#define git_graph_ahead_behind_OPTIONAL_ARGC 0
/* git_graph_ahead_behind
 *
 * Parameters:
 * - repo: git_repository *
 * - local: const git_oid *
 * - upstream: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_graph_ahead_behind(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_ahead;
  int native_behind;
  mrb_value repo;
  mrb_value local;
  mrb_value upstream;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &local, &upstream);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, local, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, upstream, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: local */
  const git_oid * native_local = (mrb_nil_p(local) ? NULL : mruby_unbox_git_oid(local));

  /* Unbox param: upstream */
  const git_oid * native_upstream = (mrb_nil_p(upstream) ? NULL : mruby_unbox_git_oid(upstream));

  /* Invocation */
  int native_return_value = git_graph_ahead_behind(&native_ahead, &native_behind, native_repo, native_local, native_upstream);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: ahead */
  mrb_value ahead = mrb_fixnum_value(native_ahead);
  /* Box out param: behind */
  mrb_value behind = mrb_fixnum_value(native_behind);

  /* Add out params to results */
  mrb_ary_push(mrb, results, ahead);
  mrb_ary_push(mrb, results, behind);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_graph_descendant_of */
/* sha: 41ef13c35b4b83cd6788c133ba4d0180716ed3da13e154a6c308f8cbaa400263 */
#if BIND_git_graph_descendant_of_FUNCTION
#define git_graph_descendant_of_REQUIRED_ARGC 3
#define git_graph_descendant_of_OPTIONAL_ARGC 0
/* git_graph_descendant_of
 *
 * Parameters:
 * - repo: git_repository *
 * - commit: const git_oid *
 * - ancestor: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_graph_descendant_of(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value commit;
  mrb_value ancestor;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &commit, &ancestor);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ancestor, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: commit */
  const git_oid * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_oid(commit));

  /* Unbox param: ancestor */
  const git_oid * native_ancestor = (mrb_nil_p(ancestor) ? NULL : mruby_unbox_git_oid(ancestor));

  /* Invocation */
  int native_return_value = git_graph_descendant_of(native_repo, native_commit, native_ancestor);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_ignore_add_rule */
/* sha: 38c050eba51c635948f2ef5aaa085d73e31c573bce1dc41c36492dfb65d4c07c */
#if BIND_git_ignore_add_rule_FUNCTION
#define git_ignore_add_rule_REQUIRED_ARGC 2
#define git_ignore_add_rule_OPTIONAL_ARGC 0
/* git_ignore_add_rule
 *
 * Parameters:
 * - repo: git_repository *
 * - rules: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_ignore_add_rule(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_rules = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_rules);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_ignore_add_rule(native_repo, native_rules);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_ignore_clear_internal_rules */
/* sha: a323b6f39ebad34d53c9e894c466626691036c4e3c194adfd3fdf34f5962cfb8 */
#if BIND_git_ignore_clear_internal_rules_FUNCTION
#define git_ignore_clear_internal_rules_REQUIRED_ARGC 1
#define git_ignore_clear_internal_rules_OPTIONAL_ARGC 0
/* git_ignore_clear_internal_rules
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_ignore_clear_internal_rules(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_ignore_clear_internal_rules(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_ignore_path_is_ignored */
/* sha: 8c223a01d82f02fc224520c73cb243c71a3f980f14683035d2d3839d5229e7f2 */
#if BIND_git_ignore_path_is_ignored_FUNCTION
#define git_ignore_path_is_ignored_REQUIRED_ARGC 2
#define git_ignore_path_is_ignored_OPTIONAL_ARGC 0
/* git_ignore_path_is_ignored
 *
 * Parameters:
 * - repo: git_repository *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_ignore_path_is_ignored(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_ignored;
  mrb_value repo;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_ignore_path_is_ignored(&native_ignored, native_repo, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: ignored */
  mrb_value ignored = native_ignored == 0 ? mrb_false_value() : mrb_true_value();

  /* Add out params to results */
  mrb_ary_push(mrb, results, ignored);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_add */
/* sha: b543265d2c086df01a1757d35b662808e00f77328c49246038f7291c36fc6754 */
#if BIND_git_index_add_FUNCTION
#define git_index_add_REQUIRED_ARGC 2
#define git_index_add_OPTIONAL_ARGC 0
/* git_index_add
 *
 * Parameters:
 * - index: git_index *
 * - source_entry: const git_index_entry *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_add(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  mrb_value source_entry;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &index, &source_entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, source_entry, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: source_entry */
  const git_index_entry * native_source_entry = (mrb_nil_p(source_entry) ? NULL : mruby_unbox_git_index_entry(source_entry));

  /* Invocation */
  int native_return_value = git_index_add(native_index, native_source_entry);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_add_all */
/* sha: d66fc2e43de41a419ab5646a8c926a530602fe8fba50cb4076bf94fbce727c29 */
#if BIND_git_index_add_all_FUNCTION
#define git_index_add_all_REQUIRED_ARGC 5
#define git_index_add_all_OPTIONAL_ARGC 0
/* git_index_add_all
 *
 * Parameters:
 * - index: git_index *
 * - pathspec: const git_strarray *
 * - flags: unsigned int
 * - callback: git_index_matched_path_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_add_all(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  mrb_value pathspec;
  mrb_int native_flags;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooioo", &index, &pathspec, &native_flags, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, pathspec, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: pathspec */
  const git_strarray * native_pathspec = (mrb_nil_p(pathspec) ? NULL : mruby_unbox_git_strarray(pathspec));

  /* Unbox param: callback */
  int (*native_callback)(const char *, const char *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_index_add_all(native_index, native_pathspec, native_flags, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_add_bypath */
/* sha: 3a9e5823ef38deb6a9ed272ea75aa994b9d1cfe8a517ed4ada99407f0c916c52 */
#if BIND_git_index_add_bypath_FUNCTION
#define git_index_add_bypath_REQUIRED_ARGC 2
#define git_index_add_bypath_OPTIONAL_ARGC 0
/* git_index_add_bypath
 *
 * Parameters:
 * - index: git_index *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_add_bypath(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &index, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_add_bypath(native_index, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_add_frombuffer */
/* sha: 2a9dbd6cfcdac589631d59aad3394c2995eec898dec1ec7e3654a309cdcaa832 */
#if BIND_git_index_add_frombuffer_FUNCTION
#define git_index_add_frombuffer_REQUIRED_ARGC 4
#define git_index_add_frombuffer_OPTIONAL_ARGC 0
/* git_index_add_frombuffer
 *
 * Parameters:
 * - index: git_index *
 * - entry: const git_index_entry *
 * - buffer: const void *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_add_frombuffer(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  mrb_value entry;
  mrb_value buffer;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oooi", &index, &entry, &buffer, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, entry, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(buffer);

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: entry */
  const git_index_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_index_entry(entry));

  /* Unbox param: buffer */
  const void * native_buffer = TODO_mruby_unbox_void_PTR(buffer);

  /* Invocation */
  int native_return_value = git_index_add_frombuffer(native_index, native_entry, native_buffer, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_caps */
/* sha: ce3ef212e6e5dde299d070354f6e549b1b81e19fdb33d13a53bae9fbf95a0b4a */
#if BIND_git_index_caps_FUNCTION
#define git_index_caps_REQUIRED_ARGC 1
#define git_index_caps_OPTIONAL_ARGC 0
/* git_index_caps
 *
 * Parameters:
 * - index: const git_index *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_caps(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  const git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_caps(native_index);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_checksum */
/* sha: 355ede8d7103249710bf77ce90a6fd20d3aba270cae62bfddf86b1befecda868 */
#if BIND_git_index_checksum_FUNCTION
#define git_index_checksum_REQUIRED_ARGC 1
#define git_index_checksum_OPTIONAL_ARGC 0
/* git_index_checksum
 *
 * Parameters:
 * - index: git_index *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_index_checksum(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  const git_oid * native_return_value = git_index_checksum(native_index);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_clear */
/* sha: 968596d7ffea625cf0c2968446be87787f26f38168c89b87d0f152e49cfe4376 */
#if BIND_git_index_clear_FUNCTION
#define git_index_clear_REQUIRED_ARGC 1
#define git_index_clear_OPTIONAL_ARGC 0
/* git_index_clear
 *
 * Parameters:
 * - index: git_index *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_clear(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_clear(native_index);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_conflict_add */
/* sha: dab0219a452af1619e1b4da5e8205b8e0766294bf91fd5fceac24e992d10b687 */
#if BIND_git_index_conflict_add_FUNCTION
#define git_index_conflict_add_REQUIRED_ARGC 4
#define git_index_conflict_add_OPTIONAL_ARGC 0
/* git_index_conflict_add
 *
 * Parameters:
 * - index: git_index *
 * - ancestor_entry: const git_index_entry *
 * - our_entry: const git_index_entry *
 * - their_entry: const git_index_entry *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_conflict_add(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  mrb_value ancestor_entry;
  mrb_value our_entry;
  mrb_value their_entry;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &index, &ancestor_entry, &our_entry, &their_entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ancestor_entry, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, our_entry, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, their_entry, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: ancestor_entry */
  const git_index_entry * native_ancestor_entry = (mrb_nil_p(ancestor_entry) ? NULL : mruby_unbox_git_index_entry(ancestor_entry));

  /* Unbox param: our_entry */
  const git_index_entry * native_our_entry = (mrb_nil_p(our_entry) ? NULL : mruby_unbox_git_index_entry(our_entry));

  /* Unbox param: their_entry */
  const git_index_entry * native_their_entry = (mrb_nil_p(their_entry) ? NULL : mruby_unbox_git_index_entry(their_entry));

  /* Invocation */
  int native_return_value = git_index_conflict_add(native_index, native_ancestor_entry, native_our_entry, native_their_entry);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_conflict_cleanup */
/* sha: a97aacf81b9c2231561992901348b67a4bfb2697973851094c7d0004e8e55614 */
#if BIND_git_index_conflict_cleanup_FUNCTION
#define git_index_conflict_cleanup_REQUIRED_ARGC 1
#define git_index_conflict_cleanup_OPTIONAL_ARGC 0
/* git_index_conflict_cleanup
 *
 * Parameters:
 * - index: git_index *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_conflict_cleanup(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_conflict_cleanup(native_index);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_conflict_get */
/* sha: a6f0b71f5a8aac63f2b110bca98d0ae1c2b29c4bbcb384f4cf3b9e40f7d1da7c */
#if BIND_git_index_conflict_get_FUNCTION
#define git_index_conflict_get_REQUIRED_ARGC 2
#define git_index_conflict_get_OPTIONAL_ARGC 0
/* git_index_conflict_get
 *
 * Parameters:
 * - index: git_index *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_conflict_get(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_index_entry * native_ancestor_out;
  git_index_entry * native_our_out;
  git_index_entry * native_their_out;
  mrb_value index;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &index, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_conflict_get(&native_ancestor_out, &native_our_out, &native_their_out, native_index, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: ancestor_out */
  mrb_value ancestor_out = mruby_box_git_index_entry(mrb, native_ancestor_out);
  /* Box out param: our_out */
  mrb_value our_out = mruby_box_git_index_entry(mrb, native_our_out);
  /* Box out param: their_out */
  mrb_value their_out = mruby_box_git_index_entry(mrb, native_their_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, ancestor_out);
  mrb_ary_push(mrb, results, our_out);
  mrb_ary_push(mrb, results, their_out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_conflict_iterator_free */
/* sha: bd37efaba553213fd9b7d8fb3fa7901f241998a968fba0c7827a925c9fcaa1a0 */
#if BIND_git_index_conflict_iterator_free_FUNCTION
#define git_index_conflict_iterator_free_REQUIRED_ARGC 1
#define git_index_conflict_iterator_free_OPTIONAL_ARGC 0
/* git_index_conflict_iterator_free
 *
 * Parameters:
 * - iterator: git_index_conflict_iterator *
 * Return Type: void
 */
mrb_value
mrb_Git_git_index_conflict_iterator_free(mrb_state* mrb, mrb_value self) {
  mrb_value iterator;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iterator);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iterator, IndexConflictIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexConflictIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iterator */
  git_index_conflict_iterator * native_iterator = (mrb_nil_p(iterator) ? NULL : mruby_unbox_git_index_conflict_iterator(iterator));

  /* Invocation */
  git_index_conflict_iterator_free(native_iterator);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_conflict_iterator_new */
/* sha: 13f1dd3fb77111faac86dcabcae26dd3d262e5a1d77e5aa9b64592ab741377c5 */
#if BIND_git_index_conflict_iterator_new_FUNCTION
#define git_index_conflict_iterator_new_REQUIRED_ARGC 1
#define git_index_conflict_iterator_new_OPTIONAL_ARGC 0
/* git_index_conflict_iterator_new
 *
 * Parameters:
 * - index: git_index *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_conflict_iterator_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_index_conflict_iterator * native_iterator_out = NULL;
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_conflict_iterator_new(&native_iterator_out, native_index);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: iterator_out */
  mrb_value iterator_out = native_iterator_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index_conflict_iterator(mrb, native_iterator_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, iterator_out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_conflict_next */
/* sha: 21d4c36ec2a0494ac5f742c36023449ebd93937cbd002a8a9ce37975ca51b93e */
#if BIND_git_index_conflict_next_FUNCTION
#define git_index_conflict_next_REQUIRED_ARGC 1
#define git_index_conflict_next_OPTIONAL_ARGC 0
/* git_index_conflict_next
 *
 * Parameters:
 * - iterator: git_index_conflict_iterator *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_conflict_next(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_index_entry * native_ancestor_out;
  git_index_entry * native_our_out;
  git_index_entry * native_their_out;
  mrb_value iterator;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iterator);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iterator, IndexConflictIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexConflictIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iterator */
  git_index_conflict_iterator * native_iterator = (mrb_nil_p(iterator) ? NULL : mruby_unbox_git_index_conflict_iterator(iterator));

  /* Invocation */
  int native_return_value = git_index_conflict_next(&native_ancestor_out, &native_our_out, &native_their_out, native_iterator);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: ancestor_out */
  mrb_value ancestor_out = mruby_box_git_index_entry(mrb, native_ancestor_out);
  /* Box out param: our_out */
  mrb_value our_out = mruby_box_git_index_entry(mrb, native_our_out);
  /* Box out param: their_out */
  mrb_value their_out = mruby_box_git_index_entry(mrb, native_their_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, ancestor_out);
  mrb_ary_push(mrb, results, our_out);
  mrb_ary_push(mrb, results, their_out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_conflict_remove */
/* sha: 9d59ba2f14df26f99e5e08ea15aa3a08840004367711fcf173c2ad427bf4870a */
#if BIND_git_index_conflict_remove_FUNCTION
#define git_index_conflict_remove_REQUIRED_ARGC 2
#define git_index_conflict_remove_OPTIONAL_ARGC 0
/* git_index_conflict_remove
 *
 * Parameters:
 * - index: git_index *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_conflict_remove(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &index, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_conflict_remove(native_index, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_entry_is_conflict */
/* sha: 0e4917bc6cd5a9915f12a3b4a2bb2c6382c15ba3fcc23e8f9ac5d9aac383fdf4 */
#if BIND_git_index_entry_is_conflict_FUNCTION
#define git_index_entry_is_conflict_REQUIRED_ARGC 1
#define git_index_entry_is_conflict_OPTIONAL_ARGC 0
/* git_index_entry_is_conflict
 *
 * Parameters:
 * - entry: const git_index_entry *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_entry_is_conflict(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_index_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_index_entry(entry));

  /* Invocation */
  int native_return_value = git_index_entry_is_conflict(native_entry);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_entry_stage */
/* sha: 51fc2508afae3484aa504b7f9d54c978008b88956395cc1c2f925b2297412bdb */
#if BIND_git_index_entry_stage_FUNCTION
#define git_index_entry_stage_REQUIRED_ARGC 1
#define git_index_entry_stage_OPTIONAL_ARGC 0
/* git_index_entry_stage
 *
 * Parameters:
 * - entry: const git_index_entry *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_entry_stage(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_index_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_index_entry(entry));

  /* Invocation */
  int native_return_value = git_index_entry_stage(native_entry);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_entrycount */
/* sha: 77829fa183ee2edcce60da8f0e297776d83f428ff5b16a0b701adbbcd6e2d349 */
#if BIND_git_index_entrycount_FUNCTION
#define git_index_entrycount_REQUIRED_ARGC 1
#define git_index_entrycount_OPTIONAL_ARGC 0
/* git_index_entrycount
 *
 * Parameters:
 * - index: const git_index *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_index_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  const git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  size_t native_return_value = git_index_entrycount(native_index);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_find */
/* sha: f1e9594599c5f2d6dd6c1507cd3a559e30c28cc15c8233d221a1587927f27a2f */
#if BIND_git_index_find_FUNCTION
#define git_index_find_REQUIRED_ARGC 2
#define git_index_find_OPTIONAL_ARGC 0
/* git_index_find
 *
 * Parameters:
 * - index: git_index *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_find(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_at_pos;
  mrb_value index;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &index, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_find(&native_at_pos, native_index, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: at_pos */
  mrb_value at_pos = mrb_fixnum_value(native_at_pos);

  /* Add out params to results */
  mrb_ary_push(mrb, results, at_pos);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_find_prefix */
/* sha: a002eb1f94a88988dae88949abf46f8f637c1786bbc208cce1931f36cedb1a93 */
#if BIND_git_index_find_prefix_FUNCTION
#define git_index_find_prefix_REQUIRED_ARGC 2
#define git_index_find_prefix_OPTIONAL_ARGC 0
/* git_index_find_prefix
 *
 * Parameters:
 * - index: git_index *
 * - prefix: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_find_prefix(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_at_pos;
  mrb_value index;
  char * native_prefix = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &index, &native_prefix);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_find_prefix(&native_at_pos, native_index, native_prefix);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: at_pos */
  mrb_value at_pos = mrb_fixnum_value(native_at_pos);

  /* Add out params to results */
  mrb_ary_push(mrb, results, at_pos);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_free */
/* sha: 31cebb3d311bef4107f73ffe5836e7078aeb5b820d3f538cd3e2f4d752c3516e */
#if BIND_git_index_free_FUNCTION
#define git_index_free_REQUIRED_ARGC 1
#define git_index_free_OPTIONAL_ARGC 0
/* git_index_free
 *
 * Parameters:
 * - index: git_index *
 * Return Type: void
 */
mrb_value
mrb_Git_git_index_free(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  git_index_free(native_index);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_get_byindex */
/* sha: d5baec111cd0ee8f2b698c969ec075747c38274110b35d6d285076e102679bc4 */
#if BIND_git_index_get_byindex_FUNCTION
#define git_index_get_byindex_REQUIRED_ARGC 2
#define git_index_get_byindex_OPTIONAL_ARGC 0
/* git_index_get_byindex
 *
 * Parameters:
 * - index: git_index *
 * - n: size_t
 * Return Type: const git_index_entry *
 */
mrb_value
mrb_Git_git_index_get_byindex(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &index, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  const git_index_entry * native_return_value = git_index_get_byindex(native_index, native_n);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_index_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_get_bypath */
/* sha: 475633439a55e1fd01c9e8d3480af513d564f39cf355737560669651e451e45b */
#if BIND_git_index_get_bypath_FUNCTION
#define git_index_get_bypath_REQUIRED_ARGC 3
#define git_index_get_bypath_OPTIONAL_ARGC 0
/* git_index_get_bypath
 *
 * Parameters:
 * - index: git_index *
 * - path: const char *
 * - stage: int
 * Return Type: const git_index_entry *
 */
mrb_value
mrb_Git_git_index_get_bypath(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  char * native_path = NULL;
  mrb_int native_stage;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &index, &native_path, &native_stage);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  const git_index_entry * native_return_value = git_index_get_bypath(native_index, native_path, native_stage);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_index_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_has_conflicts */
/* sha: 8b0daf3d66cbd43320699c43c8606fc1c9b0fb1f12ad1da11eb1c8b0c1650f7b */
#if BIND_git_index_has_conflicts_FUNCTION
#define git_index_has_conflicts_REQUIRED_ARGC 1
#define git_index_has_conflicts_OPTIONAL_ARGC 0
/* git_index_has_conflicts
 *
 * Parameters:
 * - index: const git_index *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_has_conflicts(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  const git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_has_conflicts(native_index);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_new */
/* sha: 266c3d3820457d04294df1a422d3324bba14c2e518f82dddd30994f9b7c65e96 */
#if BIND_git_index_new_FUNCTION
#define git_index_new_REQUIRED_ARGC 0
#define git_index_new_OPTIONAL_ARGC 0
/* git_index_new
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_index * native_out = NULL;


  /* Invocation */
  int native_return_value = git_index_new(&native_out);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_open */
/* sha: cc40782c2afe9337fc6d68deef92342d85b6b4a2ed7baf8f878bdc3851455002 */
#if BIND_git_index_open_FUNCTION
#define git_index_open_REQUIRED_ARGC 1
#define git_index_open_OPTIONAL_ARGC 0
/* git_index_open
 *
 * Parameters:
 * - index_path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_open(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_index * native_out = NULL;
  char * native_index_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_index_path);

  /* Invocation */
  int native_return_value = git_index_open(&native_out, native_index_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_owner */
/* sha: e1e82253a6ede8bc4e007f7e31fea73449a4d3f8d29b822f7eb02c86e368aeee */
#if BIND_git_index_owner_FUNCTION
#define git_index_owner_REQUIRED_ARGC 1
#define git_index_owner_OPTIONAL_ARGC 0
/* git_index_owner
 *
 * Parameters:
 * - index: const git_index *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_index_owner(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  const git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  git_repository * native_return_value = git_index_owner(native_index);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_path */
/* sha: bfcad89b749dc1552d379a58033b736908f6c660eb423407c2f5124266c656b5 */
#if BIND_git_index_path_FUNCTION
#define git_index_path_REQUIRED_ARGC 1
#define git_index_path_OPTIONAL_ARGC 0
/* git_index_path
 *
 * Parameters:
 * - index: const git_index *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_index_path(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  const git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  const char * native_return_value = git_index_path(native_index);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_read */
/* sha: 2656b5edc1e792c8f083fba0348fe41d924930893c4ba2396da313c2b1c4df78 */
#if BIND_git_index_read_FUNCTION
#define git_index_read_REQUIRED_ARGC 2
#define git_index_read_OPTIONAL_ARGC 0
/* git_index_read
 *
 * Parameters:
 * - index: git_index *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_read(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  mrb_int native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &index, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_read(native_index, native_force);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_read_tree */
/* sha: 42fffa8f84c6d66f7cdbd4ac63d1792aa89dac4319dc811292d0270af45849cc */
#if BIND_git_index_read_tree_FUNCTION
#define git_index_read_tree_REQUIRED_ARGC 2
#define git_index_read_tree_OPTIONAL_ARGC 0
/* git_index_read_tree
 *
 * Parameters:
 * - index: git_index *
 * - tree: const git_tree *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_read_tree(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &index, &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  int native_return_value = git_index_read_tree(native_index, native_tree);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_remove */
/* sha: efe1db86adb0ea28bd75e52f5175911795ec3e88dd767ba37c0949189add550e */
#if BIND_git_index_remove_FUNCTION
#define git_index_remove_REQUIRED_ARGC 3
#define git_index_remove_OPTIONAL_ARGC 0
/* git_index_remove
 *
 * Parameters:
 * - index: git_index *
 * - path: const char *
 * - stage: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_remove(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  char * native_path = NULL;
  mrb_int native_stage;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &index, &native_path, &native_stage);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_remove(native_index, native_path, native_stage);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_remove_all */
/* sha: b124098c54bb02b862751ace70c168f9f3f46ce0037ba09a66ebd70bb2841fe9 */
#if BIND_git_index_remove_all_FUNCTION
#define git_index_remove_all_REQUIRED_ARGC 4
#define git_index_remove_all_OPTIONAL_ARGC 0
/* git_index_remove_all
 *
 * Parameters:
 * - index: git_index *
 * - pathspec: const git_strarray *
 * - callback: git_index_matched_path_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_remove_all(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  mrb_value pathspec;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &index, &pathspec, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, pathspec, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: pathspec */
  const git_strarray * native_pathspec = (mrb_nil_p(pathspec) ? NULL : mruby_unbox_git_strarray(pathspec));

  /* Unbox param: callback */
  int (*native_callback)(const char *, const char *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_index_remove_all(native_index, native_pathspec, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_remove_bypath */
/* sha: 9413ba0be31f6c03c94efd7c10d0fe2421b5e2b7f9dd02c98858c45f671a88d5 */
#if BIND_git_index_remove_bypath_FUNCTION
#define git_index_remove_bypath_REQUIRED_ARGC 2
#define git_index_remove_bypath_OPTIONAL_ARGC 0
/* git_index_remove_bypath
 *
 * Parameters:
 * - index: git_index *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_remove_bypath(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &index, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_remove_bypath(native_index, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_remove_directory */
/* sha: 1c93de998bb3b1099975495db14c761be79a2b3a565bd8ea56617ab6803aa8c8 */
#if BIND_git_index_remove_directory_FUNCTION
#define git_index_remove_directory_REQUIRED_ARGC 3
#define git_index_remove_directory_OPTIONAL_ARGC 0
/* git_index_remove_directory
 *
 * Parameters:
 * - index: git_index *
 * - dir: const char *
 * - stage: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_remove_directory(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  char * native_dir = NULL;
  mrb_int native_stage;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &index, &native_dir, &native_stage);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_remove_directory(native_index, native_dir, native_stage);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_set_caps */
/* sha: 4a82e7febe1813c30b86d6517999ac4066a317f3e62d84ae36f31c3ba31812ae */
#if BIND_git_index_set_caps_FUNCTION
#define git_index_set_caps_REQUIRED_ARGC 2
#define git_index_set_caps_OPTIONAL_ARGC 0
/* git_index_set_caps
 *
 * Parameters:
 * - index: git_index *
 * - caps: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_set_caps(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  mrb_int native_caps;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &index, &native_caps);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_set_caps(native_index, native_caps);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_update_all */
/* sha: b8c982db720cc802a13c6693706234aa80eb13f73c3782f2a48668ffdf30dfca */
#if BIND_git_index_update_all_FUNCTION
#define git_index_update_all_REQUIRED_ARGC 4
#define git_index_update_all_OPTIONAL_ARGC 0
/* git_index_update_all
 *
 * Parameters:
 * - index: git_index *
 * - pathspec: const git_strarray *
 * - callback: git_index_matched_path_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_update_all(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  mrb_value pathspec;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &index, &pathspec, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, pathspec, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: pathspec */
  const git_strarray * native_pathspec = (mrb_nil_p(pathspec) ? NULL : mruby_unbox_git_strarray(pathspec));

  /* Unbox param: callback */
  int (*native_callback)(const char *, const char *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_index_update_all(native_index, native_pathspec, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_write */
/* sha: c8e9395e2448ff0945bddb9269ebe1e1c11f4770b77ca8a9eed5e5dfdeb5cca2 */
#if BIND_git_index_write_FUNCTION
#define git_index_write_REQUIRED_ARGC 1
#define git_index_write_OPTIONAL_ARGC 0
/* git_index_write
 *
 * Parameters:
 * - index: git_index *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_write(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_write(native_index);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_write_tree */
/* sha: 95737a71d47baf604a8f1704a4bd03f69cc595a71de7e24215937218b8af2d1e */
#if BIND_git_index_write_tree_FUNCTION
#define git_index_write_tree_REQUIRED_ARGC 2
#define git_index_write_tree_OPTIONAL_ARGC 0
/* git_index_write_tree
 *
 * Parameters:
 * - out: git_oid *
 * - index: git_index *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_write_tree(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_write_tree(native_out, native_index);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_write_tree_to */
/* sha: b12db2c66b10f68f5bceaf04a7053f4aae0ef118c1f02749dd07a3ed91ed0f21 */
#if BIND_git_index_write_tree_to_FUNCTION
#define git_index_write_tree_to_REQUIRED_ARGC 3
#define git_index_write_tree_to_OPTIONAL_ARGC 0
/* git_index_write_tree_to
 *
 * Parameters:
 * - out: git_oid *
 * - index: git_index *
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_write_tree_to(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value index;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &out, &index, &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_index_write_tree_to(native_out, native_index, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_indexer_append */
/* sha: 578d34508fe546823ccce2f5a610b0a6e982dee7a5cff51bfc0513a5a0d4afc6 */
#if BIND_git_indexer_append_FUNCTION
#define git_indexer_append_REQUIRED_ARGC 4
#define git_indexer_append_OPTIONAL_ARGC 0
/* git_indexer_append
 *
 * Parameters:
 * - idx: git_indexer *
 * - data: const void *
 * - size: size_t
 * - stats: git_transfer_progress *
 * Return Type: int
 */
mrb_value
mrb_Git_git_indexer_append(mrb_state* mrb, mrb_value self) {
  mrb_value idx;
  mrb_value data;
  mrb_int native_size;
  mrb_value stats;

  /* Fetch the args */
  mrb_get_args(mrb, "ooio", &idx, &data, &native_size, &stats);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, idx, Indexer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Indexer expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  if (!mrb_obj_is_kind_of(mrb, stats, TransferProgress_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TransferProgress expected");
    return mrb_nil_value();
  }

  /* Unbox param: idx */
  git_indexer * native_idx = (mrb_nil_p(idx) ? NULL : mruby_unbox_git_indexer(idx));

  /* Unbox param: data */
  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Unbox param: stats */
  git_transfer_progress * native_stats = (mrb_nil_p(stats) ? NULL : mruby_unbox_git_transfer_progress(stats));

  /* Invocation */
  int native_return_value = git_indexer_append(native_idx, native_data, native_size, native_stats);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_indexer_commit */
/* sha: 7c0c9d6ffaff538c3faa2a9c7378a458ae9d3ed6ea721a3164a45803874e1507 */
#if BIND_git_indexer_commit_FUNCTION
#define git_indexer_commit_REQUIRED_ARGC 2
#define git_indexer_commit_OPTIONAL_ARGC 0
/* git_indexer_commit
 *
 * Parameters:
 * - idx: git_indexer *
 * - stats: git_transfer_progress *
 * Return Type: int
 */
mrb_value
mrb_Git_git_indexer_commit(mrb_state* mrb, mrb_value self) {
  mrb_value idx;
  mrb_value stats;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &idx, &stats);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, idx, Indexer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Indexer expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, stats, TransferProgress_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TransferProgress expected");
    return mrb_nil_value();
  }

  /* Unbox param: idx */
  git_indexer * native_idx = (mrb_nil_p(idx) ? NULL : mruby_unbox_git_indexer(idx));

  /* Unbox param: stats */
  git_transfer_progress * native_stats = (mrb_nil_p(stats) ? NULL : mruby_unbox_git_transfer_progress(stats));

  /* Invocation */
  int native_return_value = git_indexer_commit(native_idx, native_stats);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_indexer_free */
/* sha: 45e7ad4538dc1c0c58d79af54e6adc841d009d62467005317ea048a241a05712 */
#if BIND_git_indexer_free_FUNCTION
#define git_indexer_free_REQUIRED_ARGC 1
#define git_indexer_free_OPTIONAL_ARGC 0
/* git_indexer_free
 *
 * Parameters:
 * - idx: git_indexer *
 * Return Type: void
 */
mrb_value
mrb_Git_git_indexer_free(mrb_state* mrb, mrb_value self) {
  mrb_value idx;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, idx, Indexer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Indexer expected");
    return mrb_nil_value();
  }

  /* Unbox param: idx */
  git_indexer * native_idx = (mrb_nil_p(idx) ? NULL : mruby_unbox_git_indexer(idx));

  /* Invocation */
  git_indexer_free(native_idx);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_indexer_hash */
/* sha: 2b862ef1346219eddab419adebeba2e6d02dbdf5641ce8a72153a8812fd940fb */
#if BIND_git_indexer_hash_FUNCTION
#define git_indexer_hash_REQUIRED_ARGC 1
#define git_indexer_hash_OPTIONAL_ARGC 0
/* git_indexer_hash
 *
 * Parameters:
 * - idx: const git_indexer *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_indexer_hash(mrb_state* mrb, mrb_value self) {
  mrb_value idx;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, idx, Indexer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Indexer expected");
    return mrb_nil_value();
  }

  /* Unbox param: idx */
  const git_indexer * native_idx = (mrb_nil_p(idx) ? NULL : mruby_unbox_git_indexer(idx));

  /* Invocation */
  const git_oid * native_return_value = git_indexer_hash(native_idx);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_indexer_new */
/* sha: c7512acc1036bf88b4740f2a287474899feb4c22648a4ce668fdb916f9a26ed9 */
#if BIND_git_indexer_new_FUNCTION
#define git_indexer_new_REQUIRED_ARGC 5
#define git_indexer_new_OPTIONAL_ARGC 0
/* git_indexer_new
 *
 * Parameters:
 * - path: const char *
 * - mode: unsigned int
 * - odb: git_odb *
 * - progress_cb: git_transfer_progress_cb
 * - progress_cb_payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_indexer_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_indexer * native_out = NULL;
  char * native_path = NULL;
  mrb_int native_mode;
  mrb_value odb;
  mrb_value progress_cb;
  mrb_value progress_cb_payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ziooo", &native_path, &native_mode, &odb, &progress_cb, &progress_cb_payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_transfer_progress_cb(progress_cb);
  TODO_type_check_void_PTR(progress_cb_payload);

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Unbox param: progress_cb */
  git_transfer_progress_cb native_progress_cb = TODO_mruby_unbox_git_transfer_progress_cb(progress_cb);

  /* Unbox param: progress_cb_payload */
  void * native_progress_cb_payload = TODO_mruby_unbox_void_PTR(progress_cb_payload);

  /* Invocation */
  int native_return_value = git_indexer_new(&native_out, native_path, native_mode, native_odb, native_progress_cb, native_progress_cb_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_indexer(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_libgit2_features */
/* sha: 1cc5838dc0128c4d9a089635132b498141d47d6857aec4d0901a025dc843dab7 */
#if BIND_git_libgit2_features_FUNCTION
#define git_libgit2_features_REQUIRED_ARGC 0
#define git_libgit2_features_OPTIONAL_ARGC 0
/* git_libgit2_features
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_libgit2_features(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  int native_return_value = git_libgit2_features();

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_libgit2_init */
/* sha: fbbc2d6d3cc7da411af396e2453186f6a78255b67f82f96a3daa0192a399c06d */
#if BIND_git_libgit2_init_FUNCTION
#define git_libgit2_init_REQUIRED_ARGC 0
#define git_libgit2_init_OPTIONAL_ARGC 0
/* git_libgit2_init
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_libgit2_init(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  int native_return_value = git_libgit2_init();

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_libgit2_opts */
/* sha: 1f0e9a68a5c03808c031204becfc64b799f3474a370e1b3994039d30d4c3109c */
#if BIND_git_libgit2_opts_FUNCTION
#define git_libgit2_opts_REQUIRED_ARGC 1
#define git_libgit2_opts_OPTIONAL_ARGC 0
/* git_libgit2_opts
 *
 * Parameters:
 * - option: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_libgit2_opts(mrb_state* mrb, mrb_value self) {
  mrb_int native_option;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_option);

  /* Invocation */
  int native_return_value = git_libgit2_opts(native_option);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_libgit2_shutdown */
/* sha: d3a64c1e1cc286120f83e77f69c910398eccc812155522cf664d14fc4b714ae7 */
#if BIND_git_libgit2_shutdown_FUNCTION
#define git_libgit2_shutdown_REQUIRED_ARGC 0
#define git_libgit2_shutdown_OPTIONAL_ARGC 0
/* git_libgit2_shutdown
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_libgit2_shutdown(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  int native_return_value = git_libgit2_shutdown();

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_libgit2_version */
/* sha: 7ba7f67c94106c17beae372b35e858112d1403fc6ae715b849ae24e98feac8bd */
#if BIND_git_libgit2_version_FUNCTION
#define git_libgit2_version_REQUIRED_ARGC 0
#define git_libgit2_version_OPTIONAL_ARGC 0
/* git_libgit2_version
 *
 * Parameters: None
 * Return Type: void
 */
mrb_value
mrb_Git_git_libgit2_version(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_major;
  int native_minor;
  int native_rev;


  /* Invocation */
  git_libgit2_version(&native_major, &native_minor, &native_rev);

  /* Box out param: major */
  mrb_value major = mrb_fixnum_value(native_major);
  /* Box out param: minor */
  mrb_value minor = mrb_fixnum_value(native_minor);
  /* Box out param: rev */
  mrb_value rev = mrb_fixnum_value(native_rev);

  /* Add out params to results */
  mrb_ary_push(mrb, results, major);
  mrb_ary_push(mrb, results, minor);
  mrb_ary_push(mrb, results, rev);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge */
/* sha: 05fc40a4268e25b27c855a52378913a55098d87519c5877bbfd0d5f8c2ea30d6 */
#if BIND_git_merge_FUNCTION
#define git_merge_REQUIRED_ARGC 4
#define git_merge_OPTIONAL_ARGC 0
/* git_merge
 *
 * Parameters:
 * - repo: git_repository *
 * - their_heads_len: size_t
 * - merge_opts: const git_merge_options *
 * - checkout_opts: const git_checkout_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value repo;
  git_annotated_commit * native_their_heads;
  mrb_int native_their_heads_len;
  mrb_value merge_opts;
  mrb_value checkout_opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &repo, &native_their_heads_len, &merge_opts, &checkout_opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, merge_opts, MergeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeOptions expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, checkout_opts, CheckoutOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CheckoutOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: merge_opts */
  const git_merge_options * native_merge_opts = (mrb_nil_p(merge_opts) ? NULL : mruby_unbox_git_merge_options(merge_opts));

  /* Unbox param: checkout_opts */
  const git_checkout_options * native_checkout_opts = (mrb_nil_p(checkout_opts) ? NULL : mruby_unbox_git_checkout_options(checkout_opts));

  /* Invocation */
  int native_return_value = git_merge(native_repo, &native_their_heads, native_their_heads_len, native_merge_opts, native_checkout_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: their_heads */
  mrb_value their_heads = mruby_box_git_annotated_commit(mrb, native_their_heads);

  /* Add out params to results */
  mrb_ary_push(mrb, results, their_heads);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_analysis */
/* sha: 2ab4be05b3cf6d84045af8aeefc3e26597cc645be1a17bba66df0577e451bfa2 */
#if BIND_git_merge_analysis_FUNCTION
#define git_merge_analysis_REQUIRED_ARGC 2
#define git_merge_analysis_OPTIONAL_ARGC 0
/* git_merge_analysis
 *
 * Parameters:
 * - repo: git_repository *
 * - their_heads_len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_analysis(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_analysis_out;
  int native_preference_out;
  mrb_value repo;
  git_annotated_commit * native_their_heads;
  mrb_int native_their_heads_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &repo, &native_their_heads_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_merge_analysis(&native_analysis_out, &native_preference_out, native_repo, &native_their_heads, native_their_heads_len);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: analysis_out */
  mrb_value analysis_out = mrb_fixnum_value(native_analysis_out);
  /* Box out param: preference_out */
  mrb_value preference_out = mrb_fixnum_value(native_preference_out);
  /* Box out param: their_heads */
  mrb_value their_heads = mruby_box_git_annotated_commit(mrb, native_their_heads);

  /* Add out params to results */
  mrb_ary_push(mrb, results, analysis_out);
  mrb_ary_push(mrb, results, preference_out);
  mrb_ary_push(mrb, results, their_heads);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_base */
/* sha: 35126111ac68193eb9c233529ede680400834cab9b4fa15248c9cc082c4fbe01 */
#if BIND_git_merge_base_FUNCTION
#define git_merge_base_REQUIRED_ARGC 4
#define git_merge_base_OPTIONAL_ARGC 0
/* git_merge_base
 *
 * Parameters:
 * - out: git_oid *
 * - repo: git_repository *
 * - one: const git_oid *
 * - two: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_base(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;
  mrb_value one;
  mrb_value two;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &out, &repo, &one, &two);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, one, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, two, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: one */
  const git_oid * native_one = (mrb_nil_p(one) ? NULL : mruby_unbox_git_oid(one));

  /* Unbox param: two */
  const git_oid * native_two = (mrb_nil_p(two) ? NULL : mruby_unbox_git_oid(two));

  /* Invocation */
  int native_return_value = git_merge_base(native_out, native_repo, native_one, native_two);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_base_many */
/* sha: fd2f52070d245d29bfc54e8ac72f869b5b801efd76b35fd059e40b4c4b0d0e39 */
#if BIND_git_merge_base_many_FUNCTION
#define git_merge_base_many_REQUIRED_ARGC 4
#define git_merge_base_many_OPTIONAL_ARGC 0
/* git_merge_base_many
 *
 * Parameters:
 * - out: git_oid *
 * - repo: git_repository *
 * - length: size_t
 * - input_array: const git_oid []
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_base_many(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;
  mrb_int native_length;
  mrb_value input_array;

  /* Fetch the args */
  mrb_get_args(mrb, "ooio", &out, &repo, &native_length, &input_array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_oid_[](input_array);

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: input_array */
  const git_oid [] native_input_array = TODO_mruby_unbox_git_oid_[](input_array);

  /* Invocation */
  int native_return_value = git_merge_base_many(native_out, native_repo, native_length, native_input_array);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_base_octopus */
/* sha: 2d112e422a39e252f5dc542b07eef2ad93c85964acf8399c2f965188eeb412b7 */
#if BIND_git_merge_base_octopus_FUNCTION
#define git_merge_base_octopus_REQUIRED_ARGC 4
#define git_merge_base_octopus_OPTIONAL_ARGC 0
/* git_merge_base_octopus
 *
 * Parameters:
 * - out: git_oid *
 * - repo: git_repository *
 * - length: size_t
 * - input_array: const git_oid []
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_base_octopus(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;
  mrb_int native_length;
  mrb_value input_array;

  /* Fetch the args */
  mrb_get_args(mrb, "ooio", &out, &repo, &native_length, &input_array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_oid_[](input_array);

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: input_array */
  const git_oid [] native_input_array = TODO_mruby_unbox_git_oid_[](input_array);

  /* Invocation */
  int native_return_value = git_merge_base_octopus(native_out, native_repo, native_length, native_input_array);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_bases */
/* sha: e192877bbf66531ea3776f643e44125c6e107f860e22f8bb2ca5f25aa1c2a661 */
#if BIND_git_merge_bases_FUNCTION
#define git_merge_bases_REQUIRED_ARGC 4
#define git_merge_bases_OPTIONAL_ARGC 0
/* git_merge_bases
 *
 * Parameters:
 * - out: git_oidarray *
 * - repo: git_repository *
 * - one: const git_oid *
 * - two: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_bases(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;
  mrb_value one;
  mrb_value two;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &out, &repo, &one, &two);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oidarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oidarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, one, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, two, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oidarray * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oidarray(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: one */
  const git_oid * native_one = (mrb_nil_p(one) ? NULL : mruby_unbox_git_oid(one));

  /* Unbox param: two */
  const git_oid * native_two = (mrb_nil_p(two) ? NULL : mruby_unbox_git_oid(two));

  /* Invocation */
  int native_return_value = git_merge_bases(native_out, native_repo, native_one, native_two);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_bases_many */
/* sha: 750fc266ffe0ac060105e1916992564cfd139dc158dc7983fe69e1b79890a688 */
#if BIND_git_merge_bases_many_FUNCTION
#define git_merge_bases_many_REQUIRED_ARGC 4
#define git_merge_bases_many_OPTIONAL_ARGC 0
/* git_merge_bases_many
 *
 * Parameters:
 * - out: git_oidarray *
 * - repo: git_repository *
 * - length: size_t
 * - input_array: const git_oid []
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_bases_many(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;
  mrb_int native_length;
  mrb_value input_array;

  /* Fetch the args */
  mrb_get_args(mrb, "ooio", &out, &repo, &native_length, &input_array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oidarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oidarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_oid_[](input_array);

  /* Unbox param: out */
  git_oidarray * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oidarray(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: input_array */
  const git_oid [] native_input_array = TODO_mruby_unbox_git_oid_[](input_array);

  /* Invocation */
  int native_return_value = git_merge_bases_many(native_out, native_repo, native_length, native_input_array);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_commits */
/* sha: 1129eda051aa2e575a6e5d616b29f6660f3b347933b09b1b689dd934baddfba0 */
#if BIND_git_merge_commits_FUNCTION
#define git_merge_commits_REQUIRED_ARGC 4
#define git_merge_commits_OPTIONAL_ARGC 0
/* git_merge_commits
 *
 * Parameters:
 * - repo: git_repository *
 * - our_commit: const git_commit *
 * - their_commit: const git_commit *
 * - opts: const git_merge_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_commits(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_index * native_out = NULL;
  mrb_value repo;
  mrb_value our_commit;
  mrb_value their_commit;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &repo, &our_commit, &their_commit, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, our_commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, their_commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, MergeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: our_commit */
  const git_commit * native_our_commit = (mrb_nil_p(our_commit) ? NULL : mruby_unbox_git_commit(our_commit));

  /* Unbox param: their_commit */
  const git_commit * native_their_commit = (mrb_nil_p(their_commit) ? NULL : mruby_unbox_git_commit(their_commit));

  /* Unbox param: opts */
  const git_merge_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_merge_options(opts));

  /* Invocation */
  int native_return_value = git_merge_commits(&native_out, native_repo, native_our_commit, native_their_commit, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_file */
/* sha: 008b170de1a080271222ef3242a6156f0084c5d0cdb89d83d42253a4eb2b8c66 */
#if BIND_git_merge_file_FUNCTION
#define git_merge_file_REQUIRED_ARGC 5
#define git_merge_file_OPTIONAL_ARGC 0
/* git_merge_file
 *
 * Parameters:
 * - out: git_merge_file_result *
 * - ancestor: const git_merge_file_input *
 * - ours: const git_merge_file_input *
 * - theirs: const git_merge_file_input *
 * - opts: const git_merge_file_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_file(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value ancestor;
  mrb_value ours;
  mrb_value theirs;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooooo", &out, &ancestor, &ours, &theirs, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, MergeFileResult_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileResult expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ancestor, MergeFileInput_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileInput expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ours, MergeFileInput_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileInput expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, theirs, MergeFileInput_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileInput expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, MergeFileOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_merge_file_result * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_merge_file_result(out));

  /* Unbox param: ancestor */
  const git_merge_file_input * native_ancestor = (mrb_nil_p(ancestor) ? NULL : mruby_unbox_git_merge_file_input(ancestor));

  /* Unbox param: ours */
  const git_merge_file_input * native_ours = (mrb_nil_p(ours) ? NULL : mruby_unbox_git_merge_file_input(ours));

  /* Unbox param: theirs */
  const git_merge_file_input * native_theirs = (mrb_nil_p(theirs) ? NULL : mruby_unbox_git_merge_file_input(theirs));

  /* Unbox param: opts */
  const git_merge_file_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_merge_file_options(opts));

  /* Invocation */
  int native_return_value = git_merge_file(native_out, native_ancestor, native_ours, native_theirs, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_file_from_index */
/* sha: 48b38c739ab74c43c93be34b1bd85ad7b0b5aab14ca4b77c7979f7cc667d3293 */
#if BIND_git_merge_file_from_index_FUNCTION
#define git_merge_file_from_index_REQUIRED_ARGC 6
#define git_merge_file_from_index_OPTIONAL_ARGC 0
/* git_merge_file_from_index
 *
 * Parameters:
 * - out: git_merge_file_result *
 * - repo: git_repository *
 * - ancestor: const git_index_entry *
 * - ours: const git_index_entry *
 * - theirs: const git_index_entry *
 * - opts: const git_merge_file_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_file_from_index(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;
  mrb_value ancestor;
  mrb_value ours;
  mrb_value theirs;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oooooo", &out, &repo, &ancestor, &ours, &theirs, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, MergeFileResult_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileResult expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ancestor, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ours, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, theirs, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, MergeFileOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_merge_file_result * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_merge_file_result(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: ancestor */
  const git_index_entry * native_ancestor = (mrb_nil_p(ancestor) ? NULL : mruby_unbox_git_index_entry(ancestor));

  /* Unbox param: ours */
  const git_index_entry * native_ours = (mrb_nil_p(ours) ? NULL : mruby_unbox_git_index_entry(ours));

  /* Unbox param: theirs */
  const git_index_entry * native_theirs = (mrb_nil_p(theirs) ? NULL : mruby_unbox_git_index_entry(theirs));

  /* Unbox param: opts */
  const git_merge_file_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_merge_file_options(opts));

  /* Invocation */
  int native_return_value = git_merge_file_from_index(native_out, native_repo, native_ancestor, native_ours, native_theirs, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_file_init_input */
/* sha: de777bdaf247c1dda78e7be2709b44b0f90f17078316d8d79b89030bff8f0133 */
#if BIND_git_merge_file_init_input_FUNCTION
#define git_merge_file_init_input_REQUIRED_ARGC 2
#define git_merge_file_init_input_OPTIONAL_ARGC 0
/* git_merge_file_init_input
 *
 * Parameters:
 * - opts: git_merge_file_input *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_file_init_input(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, MergeFileInput_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileInput expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_merge_file_input * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_merge_file_input(opts));

  /* Invocation */
  int native_return_value = git_merge_file_init_input(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_file_init_options */
/* sha: f5dfd73edb18fc2d69d5bd5beae0d7d1e9a50e660bee67542752f0c9c54bb33f */
#if BIND_git_merge_file_init_options_FUNCTION
#define git_merge_file_init_options_REQUIRED_ARGC 2
#define git_merge_file_init_options_OPTIONAL_ARGC 0
/* git_merge_file_init_options
 *
 * Parameters:
 * - opts: git_merge_file_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_file_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, MergeFileOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_merge_file_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_merge_file_options(opts));

  /* Invocation */
  int native_return_value = git_merge_file_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_file_result_free */
/* sha: 53eb515fbbfbb06bd11d3397e82d5b0587d0ee5942b5612eeb0c8ab63343ac53 */
#if BIND_git_merge_file_result_free_FUNCTION
#define git_merge_file_result_free_REQUIRED_ARGC 1
#define git_merge_file_result_free_OPTIONAL_ARGC 0
/* git_merge_file_result_free
 *
 * Parameters:
 * - result: git_merge_file_result *
 * Return Type: void
 */
mrb_value
mrb_Git_git_merge_file_result_free(mrb_state* mrb, mrb_value self) {
  mrb_value result;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &result);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, result, MergeFileResult_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileResult expected");
    return mrb_nil_value();
  }

  /* Unbox param: result */
  git_merge_file_result * native_result = (mrb_nil_p(result) ? NULL : mruby_unbox_git_merge_file_result(result));

  /* Invocation */
  git_merge_file_result_free(native_result);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_init_options */
/* sha: e265ac9f338835002c00288bbcc24505881037eb0fdecc3faa992d92a733aac8 */
#if BIND_git_merge_init_options_FUNCTION
#define git_merge_init_options_REQUIRED_ARGC 2
#define git_merge_init_options_OPTIONAL_ARGC 0
/* git_merge_init_options
 *
 * Parameters:
 * - opts: git_merge_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, MergeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_merge_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_merge_options(opts));

  /* Invocation */
  int native_return_value = git_merge_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_trees */
/* sha: 7bebf06b968ed212b7d9e16222e84edb519724bb07ec3a4e2271b97916b1c49d */
#if BIND_git_merge_trees_FUNCTION
#define git_merge_trees_REQUIRED_ARGC 5
#define git_merge_trees_OPTIONAL_ARGC 0
/* git_merge_trees
 *
 * Parameters:
 * - repo: git_repository *
 * - ancestor_tree: const git_tree *
 * - our_tree: const git_tree *
 * - their_tree: const git_tree *
 * - opts: const git_merge_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_trees(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_index * native_out = NULL;
  mrb_value repo;
  mrb_value ancestor_tree;
  mrb_value our_tree;
  mrb_value their_tree;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooooo", &repo, &ancestor_tree, &our_tree, &their_tree, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ancestor_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, our_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, their_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, MergeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: ancestor_tree */
  const git_tree * native_ancestor_tree = (mrb_nil_p(ancestor_tree) ? NULL : mruby_unbox_git_tree(ancestor_tree));

  /* Unbox param: our_tree */
  const git_tree * native_our_tree = (mrb_nil_p(our_tree) ? NULL : mruby_unbox_git_tree(our_tree));

  /* Unbox param: their_tree */
  const git_tree * native_their_tree = (mrb_nil_p(their_tree) ? NULL : mruby_unbox_git_tree(their_tree));

  /* Unbox param: opts */
  const git_merge_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_merge_options(opts));

  /* Invocation */
  int native_return_value = git_merge_trees(&native_out, native_repo, native_ancestor_tree, native_our_tree, native_their_tree, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_message_prettify */
/* sha: 9d431880b4ba70c827e47434e832040ea1cdf4727955af11df1a3daa1bab253e */
#if BIND_git_message_prettify_FUNCTION
#define git_message_prettify_REQUIRED_ARGC 4
#define git_message_prettify_OPTIONAL_ARGC 0
/* git_message_prettify
 *
 * Parameters:
 * - out: git_buf *
 * - message: const char *
 * - strip_comments: int
 * - comment_char: char
 * Return Type: int
 */
mrb_value
mrb_Git_git_message_prettify(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  char * native_message = NULL;
  mrb_int native_strip_comments;
  mrb_int native_comment_char;

  /* Fetch the args */
  mrb_get_args(mrb, "ozii", &out, &native_message, &native_strip_comments, &native_comment_char);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Invocation */
  int native_return_value = git_message_prettify(native_out, native_message, native_strip_comments, native_comment_char);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_author */
/* sha: 0daa74ce2fec286427cf02ff770be760d6d8122c44a4be1a6bc0b99dd1ec9f94 */
#if BIND_git_note_author_FUNCTION
#define git_note_author_REQUIRED_ARGC 1
#define git_note_author_OPTIONAL_ARGC 0
/* git_note_author
 *
 * Parameters:
 * - note: const git_note *
 * Return Type: const git_signature *
 */
mrb_value
mrb_Git_git_note_author(mrb_state* mrb, mrb_value self) {
  mrb_value note;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &note);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, note, Note_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Note expected");
    return mrb_nil_value();
  }

  /* Unbox param: note */
  const git_note * native_note = (mrb_nil_p(note) ? NULL : mruby_unbox_git_note(note));

  /* Invocation */
  const git_signature * native_return_value = git_note_author(native_note);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_signature(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_committer */
/* sha: 1a33fd5e73c06e604603d3509cd53682645df50a7aa14e477ecbed69c78ec410 */
#if BIND_git_note_committer_FUNCTION
#define git_note_committer_REQUIRED_ARGC 1
#define git_note_committer_OPTIONAL_ARGC 0
/* git_note_committer
 *
 * Parameters:
 * - note: const git_note *
 * Return Type: const git_signature *
 */
mrb_value
mrb_Git_git_note_committer(mrb_state* mrb, mrb_value self) {
  mrb_value note;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &note);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, note, Note_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Note expected");
    return mrb_nil_value();
  }

  /* Unbox param: note */
  const git_note * native_note = (mrb_nil_p(note) ? NULL : mruby_unbox_git_note(note));

  /* Invocation */
  const git_signature * native_return_value = git_note_committer(native_note);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_signature(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_create */
/* sha: 294ee3a18366bb5dc0d646e51d111e6b1c0dec34a53ba71d76a0f5534a34df44 */
#if BIND_git_note_create_FUNCTION
#define git_note_create_REQUIRED_ARGC 8
#define git_note_create_OPTIONAL_ARGC 0
/* git_note_create
 *
 * Parameters:
 * - out: git_oid *
 * - repo: git_repository *
 * - notes_ref: const char *
 * - author: const git_signature *
 * - committer: const git_signature *
 * - oid: const git_oid *
 * - note: const char *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_note_create(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;
  char * native_notes_ref = NULL;
  mrb_value author;
  mrb_value committer;
  mrb_value oid;
  char * native_note = NULL;
  mrb_int native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "oozooozi", &out, &repo, &native_notes_ref, &author, &committer, &oid, &native_note, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, author, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, committer, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, oid, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: author */
  const git_signature * native_author = (mrb_nil_p(author) ? NULL : mruby_unbox_git_signature(author));

  /* Unbox param: committer */
  const git_signature * native_committer = (mrb_nil_p(committer) ? NULL : mruby_unbox_git_signature(committer));

  /* Unbox param: oid */
  const git_oid * native_oid = (mrb_nil_p(oid) ? NULL : mruby_unbox_git_oid(oid));

  /* Invocation */
  int native_return_value = git_note_create(native_out, native_repo, native_notes_ref, native_author, native_committer, native_oid, native_note, native_force);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_default_ref */
/* sha: ce5f9d95d142d4b07783dc2385c234dd98b801ec83db2fc04d3359b10734f057 */
#if BIND_git_note_default_ref_FUNCTION
#define git_note_default_ref_REQUIRED_ARGC 1
#define git_note_default_ref_OPTIONAL_ARGC 0
/* git_note_default_ref
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_note_default_ref(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_out;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_note_default_ref(&native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = mrb_fixnum_value(native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_foreach */
/* sha: d795e56cd90f6b61cf2debe139fc076b6dbb4727f1248e67ccad9670d124133c */
#if BIND_git_note_foreach_FUNCTION
#define git_note_foreach_REQUIRED_ARGC 4
#define git_note_foreach_OPTIONAL_ARGC 0
/* git_note_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - notes_ref: const char *
 * - note_cb: git_note_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_note_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_notes_ref = NULL;
  mrb_value note_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoo", &repo, &native_notes_ref, &note_cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_note_foreach_cb(note_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: note_cb */
  git_note_foreach_cb native_note_cb = TODO_mruby_unbox_git_note_foreach_cb(note_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_note_foreach(native_repo, native_notes_ref, native_note_cb, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_free */
/* sha: 372f3718f09a818cee2d91438719ed30f2a52300c08dbdfcc3a6d360fc24755b */
#if BIND_git_note_free_FUNCTION
#define git_note_free_REQUIRED_ARGC 1
#define git_note_free_OPTIONAL_ARGC 0
/* git_note_free
 *
 * Parameters:
 * - note: git_note *
 * Return Type: void
 */
mrb_value
mrb_Git_git_note_free(mrb_state* mrb, mrb_value self) {
  mrb_value note;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &note);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, note, Note_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Note expected");
    return mrb_nil_value();
  }

  /* Unbox param: note */
  git_note * native_note = (mrb_nil_p(note) ? NULL : mruby_unbox_git_note(note));

  /* Invocation */
  git_note_free(native_note);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_id */
/* sha: e5a07b7c2fc7e529b657f88bcc53d63cd065d68d8f7653bf5ea0534abd745099 */
#if BIND_git_note_id_FUNCTION
#define git_note_id_REQUIRED_ARGC 1
#define git_note_id_OPTIONAL_ARGC 0
/* git_note_id
 *
 * Parameters:
 * - note: const git_note *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_note_id(mrb_state* mrb, mrb_value self) {
  mrb_value note;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &note);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, note, Note_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Note expected");
    return mrb_nil_value();
  }

  /* Unbox param: note */
  const git_note * native_note = (mrb_nil_p(note) ? NULL : mruby_unbox_git_note(note));

  /* Invocation */
  const git_oid * native_return_value = git_note_id(native_note);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_iterator_free */
/* sha: ac53ef9fb28bf6d75e6710468a588faa92dbc374baf08fe58518598ef1c732f1 */
#if BIND_git_note_iterator_free_FUNCTION
#define git_note_iterator_free_REQUIRED_ARGC 1
#define git_note_iterator_free_OPTIONAL_ARGC 0
/* git_note_iterator_free
 *
 * Parameters:
 * - it: git_note_iterator *
 * Return Type: void
 */
mrb_value
mrb_Git_git_note_iterator_free(mrb_state* mrb, mrb_value self) {
  mrb_value it;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &it);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, it, NoteIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "NoteIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: it */
  git_note_iterator * native_it = (mrb_nil_p(it) ? NULL : mruby_unbox_git_note_iterator(it));

  /* Invocation */
  git_note_iterator_free(native_it);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_iterator_new */
/* sha: abca2daa413ce1381958d08c134a26aa458b7ccaf20ce28a51a9cf8ded149fc9 */
#if BIND_git_note_iterator_new_FUNCTION
#define git_note_iterator_new_REQUIRED_ARGC 2
#define git_note_iterator_new_OPTIONAL_ARGC 0
/* git_note_iterator_new
 *
 * Parameters:
 * - repo: git_repository *
 * - notes_ref: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_note_iterator_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_note_iterator * native_out = NULL;
  mrb_value repo;
  char * native_notes_ref = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_notes_ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_note_iterator_new(&native_out, native_repo, native_notes_ref);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_note_iterator(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_message */
/* sha: eca8d6bc3d6625be150ba0da2e6ef0b6a3141f4006165696e27827764906f769 */
#if BIND_git_note_message_FUNCTION
#define git_note_message_REQUIRED_ARGC 1
#define git_note_message_OPTIONAL_ARGC 0
/* git_note_message
 *
 * Parameters:
 * - note: const git_note *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_note_message(mrb_state* mrb, mrb_value self) {
  mrb_value note;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &note);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, note, Note_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Note expected");
    return mrb_nil_value();
  }

  /* Unbox param: note */
  const git_note * native_note = (mrb_nil_p(note) ? NULL : mruby_unbox_git_note(note));

  /* Invocation */
  const char * native_return_value = git_note_message(native_note);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_next */
/* sha: 8913b5f5726286aaa2a08704a2f3418c14dd068d2943305a8393b8b35300cb6f */
#if BIND_git_note_next_FUNCTION
#define git_note_next_REQUIRED_ARGC 3
#define git_note_next_OPTIONAL_ARGC 0
/* git_note_next
 *
 * Parameters:
 * - note_id: git_oid *
 * - annotated_id: git_oid *
 * - it: git_note_iterator *
 * Return Type: int
 */
mrb_value
mrb_Git_git_note_next(mrb_state* mrb, mrb_value self) {
  mrb_value note_id;
  mrb_value annotated_id;
  mrb_value it;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &note_id, &annotated_id, &it);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, note_id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, annotated_id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, it, NoteIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "NoteIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: note_id */
  git_oid * native_note_id = (mrb_nil_p(note_id) ? NULL : mruby_unbox_git_oid(note_id));

  /* Unbox param: annotated_id */
  git_oid * native_annotated_id = (mrb_nil_p(annotated_id) ? NULL : mruby_unbox_git_oid(annotated_id));

  /* Unbox param: it */
  git_note_iterator * native_it = (mrb_nil_p(it) ? NULL : mruby_unbox_git_note_iterator(it));

  /* Invocation */
  int native_return_value = git_note_next(native_note_id, native_annotated_id, native_it);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_read */
/* sha: 8411ca4365a196b1307e8a763a0a29e70218dfc5a16b2590b38714ef2ccce671 */
#if BIND_git_note_read_FUNCTION
#define git_note_read_REQUIRED_ARGC 3
#define git_note_read_OPTIONAL_ARGC 0
/* git_note_read
 *
 * Parameters:
 * - repo: git_repository *
 * - notes_ref: const char *
 * - oid: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_note_read(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_note * native_out = NULL;
  mrb_value repo;
  char * native_notes_ref = NULL;
  mrb_value oid;

  /* Fetch the args */
  mrb_get_args(mrb, "ozo", &repo, &native_notes_ref, &oid);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, oid, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: oid */
  const git_oid * native_oid = (mrb_nil_p(oid) ? NULL : mruby_unbox_git_oid(oid));

  /* Invocation */
  int native_return_value = git_note_read(&native_out, native_repo, native_notes_ref, native_oid);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_note(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_remove */
/* sha: 8a4319f2869dd53fc433dde8383a87b96e5b74a6e6f153a5613cc59fe3167770 */
#if BIND_git_note_remove_FUNCTION
#define git_note_remove_REQUIRED_ARGC 5
#define git_note_remove_OPTIONAL_ARGC 0
/* git_note_remove
 *
 * Parameters:
 * - repo: git_repository *
 * - notes_ref: const char *
 * - author: const git_signature *
 * - committer: const git_signature *
 * - oid: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_note_remove(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_notes_ref = NULL;
  mrb_value author;
  mrb_value committer;
  mrb_value oid;

  /* Fetch the args */
  mrb_get_args(mrb, "ozooo", &repo, &native_notes_ref, &author, &committer, &oid);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, author, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, committer, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, oid, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: author */
  const git_signature * native_author = (mrb_nil_p(author) ? NULL : mruby_unbox_git_signature(author));

  /* Unbox param: committer */
  const git_signature * native_committer = (mrb_nil_p(committer) ? NULL : mruby_unbox_git_signature(committer));

  /* Unbox param: oid */
  const git_oid * native_oid = (mrb_nil_p(oid) ? NULL : mruby_unbox_git_oid(oid));

  /* Invocation */
  int native_return_value = git_note_remove(native_repo, native_notes_ref, native_author, native_committer, native_oid);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object__size */
/* sha: 2f337ddd02ed2e1fb96336113391589002c5291be9a14cd904059eab3a2bdccf */
#if BIND_git_object__size_FUNCTION
#define git_object__size_REQUIRED_ARGC 1
#define git_object__size_OPTIONAL_ARGC 0
/* git_object__size
 *
 * Parameters:
 * - type: git_otype
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_object__size(mrb_state* mrb, mrb_value self) {
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_type);

  /* Invocation */
  size_t native_return_value = git_object__size(native_type);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_dup */
/* sha: 644ba2f6a77b15b5edbf5b6f449fdb0fd6091a759dd984332eedca40c21b2747 */
#if BIND_git_object_dup_FUNCTION
#define git_object_dup_REQUIRED_ARGC 1
#define git_object_dup_OPTIONAL_ARGC 0
/* git_object_dup
 *
 * Parameters:
 * - source: git_object *
 * Return Type: int
 */
mrb_value
mrb_Git_git_object_dup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_object * native_dest = NULL;
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: source */
  git_object * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox_git_object(source));

  /* Invocation */
  int native_return_value = git_object_dup(&native_dest, native_source);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: dest */
  mrb_value dest = native_dest == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_dest);

  /* Add out params to results */
  mrb_ary_push(mrb, results, dest);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_free */
/* sha: 5427c3742242bf38f560b51a7eea80e525e35bbaaf793e8231140d7d11ff5085 */
#if BIND_git_object_free_FUNCTION
#define git_object_free_REQUIRED_ARGC 1
#define git_object_free_OPTIONAL_ARGC 0
/* git_object_free
 *
 * Parameters:
 * - object: git_object *
 * Return Type: void
 */
mrb_value
mrb_Git_git_object_free(mrb_state* mrb, mrb_value self) {
  mrb_value object;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &object);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, object, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: object */
  git_object * native_object = (mrb_nil_p(object) ? NULL : mruby_unbox_git_object(object));

  /* Invocation */
  git_object_free(native_object);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_id */
/* sha: 58c787dab123f0a7caa6fe804adfe0f6a63dcfae5449bdb1c49a8268d6e635e0 */
#if BIND_git_object_id_FUNCTION
#define git_object_id_REQUIRED_ARGC 1
#define git_object_id_OPTIONAL_ARGC 0
/* git_object_id
 *
 * Parameters:
 * - obj: const git_object *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_object_id(mrb_state* mrb, mrb_value self) {
  mrb_value obj;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &obj);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, obj, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: obj */
  const git_object * native_obj = (mrb_nil_p(obj) ? NULL : mruby_unbox_git_object(obj));

  /* Invocation */
  const git_oid * native_return_value = git_object_id(native_obj);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_lookup */
/* sha: 46c9101409b5f15e72e54ecc2ce3bab212e9a90927e2454b482f30700704e28d */
#if BIND_git_object_lookup_FUNCTION
#define git_object_lookup_REQUIRED_ARGC 3
#define git_object_lookup_OPTIONAL_ARGC 0
/* git_object_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_object_lookup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_object * native_object = NULL;
  mrb_value repo;
  mrb_value id;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &repo, &id, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_object_lookup(&native_object, native_repo, native_id, native_type);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: object */
  mrb_value object = native_object == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_object);

  /* Add out params to results */
  mrb_ary_push(mrb, results, object);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_lookup_bypath */
/* sha: c10ce4e6bdcfd9f922e22bdcb332bb23b9384a4c9af7e0f0befbc7c76dc16514 */
#if BIND_git_object_lookup_bypath_FUNCTION
#define git_object_lookup_bypath_REQUIRED_ARGC 3
#define git_object_lookup_bypath_OPTIONAL_ARGC 0
/* git_object_lookup_bypath
 *
 * Parameters:
 * - treeish: const git_object *
 * - path: const char *
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_object_lookup_bypath(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_object * native_out = NULL;
  mrb_value treeish;
  char * native_path = NULL;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &treeish, &native_path, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, treeish, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: treeish */
  const git_object * native_treeish = (mrb_nil_p(treeish) ? NULL : mruby_unbox_git_object(treeish));

  /* Invocation */
  int native_return_value = git_object_lookup_bypath(&native_out, native_treeish, native_path, native_type);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_lookup_prefix */
/* sha: 0ca690c162e416ceb4e5a3af6136b0a24635704cdd11d086adf10a12ee3d65fb */
#if BIND_git_object_lookup_prefix_FUNCTION
#define git_object_lookup_prefix_REQUIRED_ARGC 4
#define git_object_lookup_prefix_OPTIONAL_ARGC 0
/* git_object_lookup_prefix
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * - len: size_t
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_object_lookup_prefix(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_object * native_object_out = NULL;
  mrb_value repo;
  mrb_value id;
  mrb_int native_len;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "ooii", &repo, &id, &native_len, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_object_lookup_prefix(&native_object_out, native_repo, native_id, native_len, native_type);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: object_out */
  mrb_value object_out = native_object_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_object_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, object_out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_owner */
/* sha: 67db950c07461afdeca7e1a77ffa22c5b531a0bc7e70e5f667067054ee417873 */
#if BIND_git_object_owner_FUNCTION
#define git_object_owner_REQUIRED_ARGC 1
#define git_object_owner_OPTIONAL_ARGC 0
/* git_object_owner
 *
 * Parameters:
 * - obj: const git_object *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_object_owner(mrb_state* mrb, mrb_value self) {
  mrb_value obj;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &obj);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, obj, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: obj */
  const git_object * native_obj = (mrb_nil_p(obj) ? NULL : mruby_unbox_git_object(obj));

  /* Invocation */
  git_repository * native_return_value = git_object_owner(native_obj);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_peel */
/* sha: 58d2fccff601eb8a92ff8caf12caeae0f6a922f9c60ed93953163a033f591791 */
#if BIND_git_object_peel_FUNCTION
#define git_object_peel_REQUIRED_ARGC 2
#define git_object_peel_OPTIONAL_ARGC 0
/* git_object_peel
 *
 * Parameters:
 * - object: const git_object *
 * - target_type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_object_peel(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_object * native_peeled = NULL;
  mrb_value object;
  mrb_int native_target_type;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &object, &native_target_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, object, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: object */
  const git_object * native_object = (mrb_nil_p(object) ? NULL : mruby_unbox_git_object(object));

  /* Invocation */
  int native_return_value = git_object_peel(&native_peeled, native_object, native_target_type);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: peeled */
  mrb_value peeled = native_peeled == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_peeled);

  /* Add out params to results */
  mrb_ary_push(mrb, results, peeled);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_short_id */
/* sha: 2034392b4139dae5eb8b072fce7256ee9506850fb41f966223fc02c01a309ff5 */
#if BIND_git_object_short_id_FUNCTION
#define git_object_short_id_REQUIRED_ARGC 2
#define git_object_short_id_OPTIONAL_ARGC 0
/* git_object_short_id
 *
 * Parameters:
 * - out: git_buf *
 * - obj: const git_object *
 * Return Type: int
 */
mrb_value
mrb_Git_git_object_short_id(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value obj;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &obj);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, obj, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: obj */
  const git_object * native_obj = (mrb_nil_p(obj) ? NULL : mruby_unbox_git_object(obj));

  /* Invocation */
  int native_return_value = git_object_short_id(native_out, native_obj);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_string2type */
/* sha: ea1788320dbcf63fbe0cd299c2176e50d6a14b6a20ef6e35c9b63a403c308926 */
#if BIND_git_object_string2type_FUNCTION
#define git_object_string2type_REQUIRED_ARGC 1
#define git_object_string2type_OPTIONAL_ARGC 0
/* git_object_string2type
 *
 * Parameters:
 * - str: const char *
 * Return Type: git_otype
 */
mrb_value
mrb_Git_git_object_string2type(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_str);

  /* Invocation */
  git_otype native_return_value = git_object_string2type(native_str);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_type */
/* sha: e43f56870b7b5acec49c27fb19d8b7f961150672be71e0a79139c753e189f008 */
#if BIND_git_object_type_FUNCTION
#define git_object_type_REQUIRED_ARGC 1
#define git_object_type_OPTIONAL_ARGC 0
/* git_object_type
 *
 * Parameters:
 * - obj: const git_object *
 * Return Type: git_otype
 */
mrb_value
mrb_Git_git_object_type(mrb_state* mrb, mrb_value self) {
  mrb_value obj;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &obj);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, obj, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: obj */
  const git_object * native_obj = (mrb_nil_p(obj) ? NULL : mruby_unbox_git_object(obj));

  /* Invocation */
  git_otype native_return_value = git_object_type(native_obj);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_type2string */
/* sha: 59300ea76612f5a68e843726e2939d66c5715f6a14abffb16999969c3153921e */
#if BIND_git_object_type2string_FUNCTION
#define git_object_type2string_REQUIRED_ARGC 1
#define git_object_type2string_OPTIONAL_ARGC 0
/* git_object_type2string
 *
 * Parameters:
 * - type: git_otype
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_object_type2string(mrb_state* mrb, mrb_value self) {
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_type);

  /* Invocation */
  const char * native_return_value = git_object_type2string(native_type);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_typeisloose */
/* sha: 900fc93e05ccd1811ce2b41d905cec3701253ff7a1e87cc8688a20ba43f88a0c */
#if BIND_git_object_typeisloose_FUNCTION
#define git_object_typeisloose_REQUIRED_ARGC 1
#define git_object_typeisloose_OPTIONAL_ARGC 0
/* git_object_typeisloose
 *
 * Parameters:
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_object_typeisloose(mrb_state* mrb, mrb_value self) {
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_type);

  /* Invocation */
  int native_return_value = git_object_typeisloose(native_type);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_add_alternate */
/* sha: 40d56071b7dc056ad2eaa11dada2a2f7ef58aa13c6f785cc2bf6445d7e1912e6 */
#if BIND_git_odb_add_alternate_FUNCTION
#define git_odb_add_alternate_REQUIRED_ARGC 3
#define git_odb_add_alternate_OPTIONAL_ARGC 0
/* git_odb_add_alternate
 *
 * Parameters:
 * - odb: git_odb *
 * - backend: git_odb_backend *
 * - priority: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_add_alternate(mrb_state* mrb, mrb_value self) {
  mrb_value odb;
  mrb_value backend;
  mrb_int native_priority;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &odb, &backend, &native_priority);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, backend, OdbBackend_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbBackend expected");
    return mrb_nil_value();
  }

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Unbox param: backend */
  git_odb_backend * native_backend = (mrb_nil_p(backend) ? NULL : mruby_unbox_git_odb_backend(backend));

  /* Invocation */
  int native_return_value = git_odb_add_alternate(native_odb, native_backend, native_priority);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_add_backend */
/* sha: 8eecf5d15002286e61c2cb63ff5fcf505f57749b5183105cd406a33ef42864dc */
#if BIND_git_odb_add_backend_FUNCTION
#define git_odb_add_backend_REQUIRED_ARGC 3
#define git_odb_add_backend_OPTIONAL_ARGC 0
/* git_odb_add_backend
 *
 * Parameters:
 * - odb: git_odb *
 * - backend: git_odb_backend *
 * - priority: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_add_backend(mrb_state* mrb, mrb_value self) {
  mrb_value odb;
  mrb_value backend;
  mrb_int native_priority;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &odb, &backend, &native_priority);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, backend, OdbBackend_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbBackend expected");
    return mrb_nil_value();
  }

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Unbox param: backend */
  git_odb_backend * native_backend = (mrb_nil_p(backend) ? NULL : mruby_unbox_git_odb_backend(backend));

  /* Invocation */
  int native_return_value = git_odb_add_backend(native_odb, native_backend, native_priority);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_add_disk_alternate */
/* sha: ae5316078a8e45971e56f89c513d4be37fac1b480dfcf84208fa7115d08134dd */
#if BIND_git_odb_add_disk_alternate_FUNCTION
#define git_odb_add_disk_alternate_REQUIRED_ARGC 2
#define git_odb_add_disk_alternate_OPTIONAL_ARGC 0
/* git_odb_add_disk_alternate
 *
 * Parameters:
 * - odb: git_odb *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_add_disk_alternate(mrb_state* mrb, mrb_value self) {
  mrb_value odb;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &odb, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Invocation */
  int native_return_value = git_odb_add_disk_alternate(native_odb, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_backend_loose */
/* sha: d264fa31f8a387b6055c20cb7ea31709c40aa3b014903a84220d4f429ff815f4 */
#if BIND_git_odb_backend_loose_FUNCTION
#define git_odb_backend_loose_REQUIRED_ARGC 5
#define git_odb_backend_loose_OPTIONAL_ARGC 0
/* git_odb_backend_loose
 *
 * Parameters:
 * - objects_dir: const char *
 * - compression_level: int
 * - do_fsync: int
 * - dir_mode: unsigned int
 * - file_mode: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_backend_loose(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_odb_backend * native_out;
  char * native_objects_dir = NULL;
  mrb_int native_compression_level;
  mrb_int native_do_fsync;
  mrb_int native_dir_mode;
  mrb_int native_file_mode;

  /* Fetch the args */
  mrb_get_args(mrb, "ziiii", &native_objects_dir, &native_compression_level, &native_do_fsync, &native_dir_mode, &native_file_mode);

  /* Invocation */
  int native_return_value = git_odb_backend_loose(&native_out, native_objects_dir, native_compression_level, native_do_fsync, native_dir_mode, native_file_mode);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = mruby_box_git_odb_backend(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_backend_one_pack */
/* sha: db0b75ebf47ff5131d221408a8862c971dc3d74f386e57fe3220cb2ac1ebb80c */
#if BIND_git_odb_backend_one_pack_FUNCTION
#define git_odb_backend_one_pack_REQUIRED_ARGC 1
#define git_odb_backend_one_pack_OPTIONAL_ARGC 0
/* git_odb_backend_one_pack
 *
 * Parameters:
 * - index_file: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_backend_one_pack(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_odb_backend * native_out;
  char * native_index_file = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_index_file);

  /* Invocation */
  int native_return_value = git_odb_backend_one_pack(&native_out, native_index_file);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = mruby_box_git_odb_backend(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_backend_pack */
/* sha: 66c3b240c28a7a25ab8a93ec614478349bb9a70c3c35dcedb4e23198c8857c10 */
#if BIND_git_odb_backend_pack_FUNCTION
#define git_odb_backend_pack_REQUIRED_ARGC 1
#define git_odb_backend_pack_OPTIONAL_ARGC 0
/* git_odb_backend_pack
 *
 * Parameters:
 * - objects_dir: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_backend_pack(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_odb_backend * native_out;
  char * native_objects_dir = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_objects_dir);

  /* Invocation */
  int native_return_value = git_odb_backend_pack(&native_out, native_objects_dir);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = mruby_box_git_odb_backend(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_exists */
/* sha: 6921fe3b6332dba3c9be614b37351bcf311c196df1ae35e13d05902aa0fa275a */
#if BIND_git_odb_exists_FUNCTION
#define git_odb_exists_REQUIRED_ARGC 2
#define git_odb_exists_OPTIONAL_ARGC 0
/* git_odb_exists
 *
 * Parameters:
 * - db: git_odb *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_exists(mrb_state* mrb, mrb_value self) {
  mrb_value db;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &db, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_odb_exists(native_db, native_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_exists_prefix */
/* sha: b9e165c70765df4cae7d0c12719b0d05acc8b161743d412ed6d9ca065c2a7fe0 */
#if BIND_git_odb_exists_prefix_FUNCTION
#define git_odb_exists_prefix_REQUIRED_ARGC 4
#define git_odb_exists_prefix_OPTIONAL_ARGC 0
/* git_odb_exists_prefix
 *
 * Parameters:
 * - out: git_oid *
 * - db: git_odb *
 * - short_id: const git_oid *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_exists_prefix(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value db;
  mrb_value short_id;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oooi", &out, &db, &short_id, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, short_id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: short_id */
  const git_oid * native_short_id = (mrb_nil_p(short_id) ? NULL : mruby_unbox_git_oid(short_id));

  /* Invocation */
  int native_return_value = git_odb_exists_prefix(native_out, native_db, native_short_id, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_foreach */
/* sha: 9d15ac37576e24cedf1c0bdbc8c4386e96d2f999b73d77bd545858e17f3e97c0 */
#if BIND_git_odb_foreach_FUNCTION
#define git_odb_foreach_REQUIRED_ARGC 3
#define git_odb_foreach_OPTIONAL_ARGC 0
/* git_odb_foreach
 *
 * Parameters:
 * - db: git_odb *
 * - cb: git_odb_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value db;
  mrb_value cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &db, &cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_odb_foreach_cb(cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: cb */
  git_odb_foreach_cb native_cb = TODO_mruby_unbox_git_odb_foreach_cb(cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_odb_foreach(native_db, native_cb, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_free */
/* sha: 40d7f2179d1aff990cd3034e21dbe07ece8927242ad3e356aa4ef4bbf7ac4ea9 */
#if BIND_git_odb_free_FUNCTION
#define git_odb_free_REQUIRED_ARGC 1
#define git_odb_free_OPTIONAL_ARGC 0
/* git_odb_free
 *
 * Parameters:
 * - db: git_odb *
 * Return Type: void
 */
mrb_value
mrb_Git_git_odb_free(mrb_state* mrb, mrb_value self) {
  mrb_value db;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &db);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Invocation */
  git_odb_free(native_db);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_get_backend */
/* sha: efedf4c368b1402c550e49e3c928d4d182d1246f095c5ea293d14f7015e513e0 */
#if BIND_git_odb_get_backend_FUNCTION
#define git_odb_get_backend_REQUIRED_ARGC 2
#define git_odb_get_backend_OPTIONAL_ARGC 0
/* git_odb_get_backend
 *
 * Parameters:
 * - odb: git_odb *
 * - pos: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_get_backend(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_odb_backend * native_out;
  mrb_value odb;
  mrb_int native_pos;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &odb, &native_pos);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Invocation */
  int native_return_value = git_odb_get_backend(&native_out, native_odb, native_pos);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = mruby_box_git_odb_backend(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_hash */
/* sha: 61f08a3e7ad3bf7dd80580e9a74aec277fe9d25392ce9f00c47f4a09edc0ea86 */
#if BIND_git_odb_hash_FUNCTION
#define git_odb_hash_REQUIRED_ARGC 3
#define git_odb_hash_OPTIONAL_ARGC 0
/* git_odb_hash
 *
 * Parameters:
 * - out: git_oid *
 * - data: const void *
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_hash(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value native_data;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "oSi", &out, &native_data, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Invocation */
  int native_return_value = git_odb_hash(native_out, RSTRING_PTR(native_data), RSTRING_LEN(native_data), native_type);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_hashfile */
/* sha: 393ce24633ba1f6127f25fe02b74d92ddfe8e8510326b077088e7406296a47b4 */
#if BIND_git_odb_hashfile_FUNCTION
#define git_odb_hashfile_REQUIRED_ARGC 3
#define git_odb_hashfile_OPTIONAL_ARGC 0
/* git_odb_hashfile
 *
 * Parameters:
 * - out: git_oid *
 * - path: const char *
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_hashfile(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  char * native_path = NULL;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &out, &native_path, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Invocation */
  int native_return_value = git_odb_hashfile(native_out, native_path, native_type);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_new */
/* sha: eeffcb7823a72a7d46f4f9f9b61e0e2bd655681014370c8c696934257fc633cf */
#if BIND_git_odb_new_FUNCTION
#define git_odb_new_REQUIRED_ARGC 0
#define git_odb_new_OPTIONAL_ARGC 0
/* git_odb_new
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_odb * native_out = NULL;


  /* Invocation */
  int native_return_value = git_odb_new(&native_out);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_num_backends */
/* sha: baac9935e93e63e316c4f2c24b4c7fe671b26747e068859db23f09e89cd822bc */
#if BIND_git_odb_num_backends_FUNCTION
#define git_odb_num_backends_REQUIRED_ARGC 1
#define git_odb_num_backends_OPTIONAL_ARGC 0
/* git_odb_num_backends
 *
 * Parameters:
 * - odb: git_odb *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_odb_num_backends(mrb_state* mrb, mrb_value self) {
  mrb_value odb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &odb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Invocation */
  size_t native_return_value = git_odb_num_backends(native_odb);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_object_data */
/* sha: 442e046b905ea756a96b8b37c3045b21764e8612962eaceba6f0ba41dd34226d */
#if BIND_git_odb_object_data_FUNCTION
#define git_odb_object_data_REQUIRED_ARGC 1
#define git_odb_object_data_OPTIONAL_ARGC 0
/* git_odb_object_data
 *
 * Parameters:
 * - object: git_odb_object *
 * Return Type: const void *
 */
mrb_value
mrb_Git_git_odb_object_data(mrb_state* mrb, mrb_value self) {
  mrb_value object;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &object);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, object, OdbObject_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbObject expected");
    return mrb_nil_value();
  }

  /* Unbox param: object */
  git_odb_object * native_object = (mrb_nil_p(object) ? NULL : mruby_unbox_git_odb_object(object));

  /* Invocation */
  const void * native_return_value = git_odb_object_data(native_object);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_void_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_object_dup */
/* sha: 8e145f4dd34629787a66d51e2aef6aab5ce57e9daa99b1f9e2bae4f18e4300fa */
#if BIND_git_odb_object_dup_FUNCTION
#define git_odb_object_dup_REQUIRED_ARGC 1
#define git_odb_object_dup_OPTIONAL_ARGC 0
/* git_odb_object_dup
 *
 * Parameters:
 * - source: git_odb_object *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_object_dup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_odb_object * native_dest = NULL;
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, OdbObject_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbObject expected");
    return mrb_nil_value();
  }

  /* Unbox param: source */
  git_odb_object * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox_git_odb_object(source));

  /* Invocation */
  int native_return_value = git_odb_object_dup(&native_dest, native_source);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: dest */
  mrb_value dest = native_dest == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb_object(mrb, native_dest);

  /* Add out params to results */
  mrb_ary_push(mrb, results, dest);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_object_free */
/* sha: ca0bf73da4f3bb67e279423da438f1bddb2ce2f4e137cde2ee23196542447bd5 */
#if BIND_git_odb_object_free_FUNCTION
#define git_odb_object_free_REQUIRED_ARGC 1
#define git_odb_object_free_OPTIONAL_ARGC 0
/* git_odb_object_free
 *
 * Parameters:
 * - object: git_odb_object *
 * Return Type: void
 */
mrb_value
mrb_Git_git_odb_object_free(mrb_state* mrb, mrb_value self) {
  mrb_value object;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &object);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, object, OdbObject_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbObject expected");
    return mrb_nil_value();
  }

  /* Unbox param: object */
  git_odb_object * native_object = (mrb_nil_p(object) ? NULL : mruby_unbox_git_odb_object(object));

  /* Invocation */
  git_odb_object_free(native_object);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_object_id */
/* sha: 64c653fede90ff3da70e49deb4d2247c0fccb32a3b78aec0ff609244af05fa8b */
#if BIND_git_odb_object_id_FUNCTION
#define git_odb_object_id_REQUIRED_ARGC 1
#define git_odb_object_id_OPTIONAL_ARGC 0
/* git_odb_object_id
 *
 * Parameters:
 * - object: git_odb_object *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_odb_object_id(mrb_state* mrb, mrb_value self) {
  mrb_value object;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &object);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, object, OdbObject_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbObject expected");
    return mrb_nil_value();
  }

  /* Unbox param: object */
  git_odb_object * native_object = (mrb_nil_p(object) ? NULL : mruby_unbox_git_odb_object(object));

  /* Invocation */
  const git_oid * native_return_value = git_odb_object_id(native_object);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_object_size */
/* sha: 95ab40d649d21de94a8201a96545c74f58f373f09b6a7dcaa92fb55d9afbcfb3 */
#if BIND_git_odb_object_size_FUNCTION
#define git_odb_object_size_REQUIRED_ARGC 1
#define git_odb_object_size_OPTIONAL_ARGC 0
/* git_odb_object_size
 *
 * Parameters:
 * - object: git_odb_object *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_odb_object_size(mrb_state* mrb, mrb_value self) {
  mrb_value object;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &object);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, object, OdbObject_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbObject expected");
    return mrb_nil_value();
  }

  /* Unbox param: object */
  git_odb_object * native_object = (mrb_nil_p(object) ? NULL : mruby_unbox_git_odb_object(object));

  /* Invocation */
  size_t native_return_value = git_odb_object_size(native_object);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_object_type */
/* sha: 4ccb87e9a3d8024e083157461dbf44167087476e3e97185c15f044d06c15b9c7 */
#if BIND_git_odb_object_type_FUNCTION
#define git_odb_object_type_REQUIRED_ARGC 1
#define git_odb_object_type_OPTIONAL_ARGC 0
/* git_odb_object_type
 *
 * Parameters:
 * - object: git_odb_object *
 * Return Type: git_otype
 */
mrb_value
mrb_Git_git_odb_object_type(mrb_state* mrb, mrb_value self) {
  mrb_value object;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &object);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, object, OdbObject_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbObject expected");
    return mrb_nil_value();
  }

  /* Unbox param: object */
  git_odb_object * native_object = (mrb_nil_p(object) ? NULL : mruby_unbox_git_odb_object(object));

  /* Invocation */
  git_otype native_return_value = git_odb_object_type(native_object);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_open */
/* sha: f3bb5b69138ef4f51bcc2610579ace3691c83549e6f4958cb3ad9d9d5d6f74ea */
#if BIND_git_odb_open_FUNCTION
#define git_odb_open_REQUIRED_ARGC 1
#define git_odb_open_OPTIONAL_ARGC 0
/* git_odb_open
 *
 * Parameters:
 * - objects_dir: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_open(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_odb * native_out = NULL;
  char * native_objects_dir = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_objects_dir);

  /* Invocation */
  int native_return_value = git_odb_open(&native_out, native_objects_dir);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_open_rstream */
/* sha: efc3d52519c1c2d7aa28655cdee5ba899ed4106d0851765ed7ea2f727b111f3c */
#if BIND_git_odb_open_rstream_FUNCTION
#define git_odb_open_rstream_REQUIRED_ARGC 2
#define git_odb_open_rstream_OPTIONAL_ARGC 0
/* git_odb_open_rstream
 *
 * Parameters:
 * - db: git_odb *
 * - oid: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_open_rstream(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_odb_stream * native_out = NULL;
  mrb_value db;
  mrb_value oid;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &db, &oid);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, oid, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: oid */
  const git_oid * native_oid = (mrb_nil_p(oid) ? NULL : mruby_unbox_git_oid(oid));

  /* Invocation */
  int native_return_value = git_odb_open_rstream(&native_out, native_db, native_oid);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb_stream(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_open_wstream */
/* sha: 2973f11fcd41ccf858c333cbcabce2b74ee52a8dc4fa703eb772ce92a172c05f */
#if BIND_git_odb_open_wstream_FUNCTION
#define git_odb_open_wstream_REQUIRED_ARGC 3
#define git_odb_open_wstream_OPTIONAL_ARGC 0
/* git_odb_open_wstream
 *
 * Parameters:
 * - db: git_odb *
 * - size: git_off_t
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_open_wstream(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_odb_stream * native_out = NULL;
  mrb_value db;
  mrb_int native_size;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &db, &native_size, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Invocation */
  int native_return_value = git_odb_open_wstream(&native_out, native_db, native_size, native_type);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb_stream(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_read */
/* sha: 2f6277304cd312cc9d804b7ed275937d4b1f9ff605879b157df83f69629e370a */
#if BIND_git_odb_read_FUNCTION
#define git_odb_read_REQUIRED_ARGC 2
#define git_odb_read_OPTIONAL_ARGC 0
/* git_odb_read
 *
 * Parameters:
 * - db: git_odb *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_read(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_odb_object * native_out = NULL;
  mrb_value db;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &db, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_odb_read(&native_out, native_db, native_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb_object(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_read_header */
/* sha: 623698e6dcf335ea77b20a76b3ee8dd9fc8077adaa7ce0fdb2fdc7250445419e */
#if BIND_git_odb_read_header_FUNCTION
#define git_odb_read_header_REQUIRED_ARGC 2
#define git_odb_read_header_OPTIONAL_ARGC 0
/* git_odb_read_header
 *
 * Parameters:
 * - db: git_odb *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_read_header(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_len_out;
  int native_type_out;
  mrb_value db;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &db, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_odb_read_header(&native_len_out, &native_type_out, native_db, native_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: len_out */
  mrb_value len_out = mrb_fixnum_value(native_len_out);
  /* Box out param: type_out */
  mrb_value type_out = mrb_fixnum_value(native_type_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, len_out);
  mrb_ary_push(mrb, results, type_out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_read_prefix */
/* sha: ea332e90a711c75447c6563898e4bcfacf0550e918d7e85eb39fbea91b21d9a3 */
#if BIND_git_odb_read_prefix_FUNCTION
#define git_odb_read_prefix_REQUIRED_ARGC 3
#define git_odb_read_prefix_OPTIONAL_ARGC 0
/* git_odb_read_prefix
 *
 * Parameters:
 * - db: git_odb *
 * - short_id: const git_oid *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_read_prefix(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_odb_object * native_out = NULL;
  mrb_value db;
  mrb_value short_id;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &db, &short_id, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, short_id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: short_id */
  const git_oid * native_short_id = (mrb_nil_p(short_id) ? NULL : mruby_unbox_git_oid(short_id));

  /* Invocation */
  int native_return_value = git_odb_read_prefix(&native_out, native_db, native_short_id, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb_object(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_refresh */
/* sha: a50b4ca9bf69d0553cd092fe306112f86c615ed56607d1dbc4cdf59334b41827 */
#if BIND_git_odb_refresh_FUNCTION
#define git_odb_refresh_REQUIRED_ARGC 1
#define git_odb_refresh_OPTIONAL_ARGC 0
/* git_odb_refresh
 *
 * Parameters:
 * - db: struct git_odb *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_refresh(mrb_state* mrb, mrb_value self) {
  mrb_value db;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &db);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  struct git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Invocation */
  int native_return_value = git_odb_refresh(native_db);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_stream_finalize_write */
/* sha: f9542540075395d7c1f3afcfe6f376c28004dea51854037540846f205bcf5897 */
#if BIND_git_odb_stream_finalize_write_FUNCTION
#define git_odb_stream_finalize_write_REQUIRED_ARGC 2
#define git_odb_stream_finalize_write_OPTIONAL_ARGC 0
/* git_odb_stream_finalize_write
 *
 * Parameters:
 * - out: git_oid *
 * - stream: git_odb_stream *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_stream_finalize_write(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value stream;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &stream);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, stream, OdbStream_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbStream expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: stream */
  git_odb_stream * native_stream = (mrb_nil_p(stream) ? NULL : mruby_unbox_git_odb_stream(stream));

  /* Invocation */
  int native_return_value = git_odb_stream_finalize_write(native_out, native_stream);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_stream_free */
/* sha: e1570153dfc20f29b7fbc1f47d31a0bb51499a60cf30ae80ad65abbb83065b55 */
#if BIND_git_odb_stream_free_FUNCTION
#define git_odb_stream_free_REQUIRED_ARGC 1
#define git_odb_stream_free_OPTIONAL_ARGC 0
/* git_odb_stream_free
 *
 * Parameters:
 * - stream: git_odb_stream *
 * Return Type: void
 */
mrb_value
mrb_Git_git_odb_stream_free(mrb_state* mrb, mrb_value self) {
  mrb_value stream;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &stream);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, stream, OdbStream_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbStream expected");
    return mrb_nil_value();
  }

  /* Unbox param: stream */
  git_odb_stream * native_stream = (mrb_nil_p(stream) ? NULL : mruby_unbox_git_odb_stream(stream));

  /* Invocation */
  git_odb_stream_free(native_stream);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_stream_read */
/* sha: a7485c4c577f226b0b5745c2c51e34008499a45344a7d918ef8c6721c11b0ee2 */
#if BIND_git_odb_stream_read_FUNCTION
#define git_odb_stream_read_REQUIRED_ARGC 3
#define git_odb_stream_read_OPTIONAL_ARGC 0
/* git_odb_stream_read
 *
 * Parameters:
 * - stream: git_odb_stream *
 * - buffer: char *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_stream_read(mrb_state* mrb, mrb_value self) {
  mrb_value stream;
  mrb_value buffer;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &stream, &buffer, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, stream, OdbStream_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbStream expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR(buffer);

  /* Unbox param: stream */
  git_odb_stream * native_stream = (mrb_nil_p(stream) ? NULL : mruby_unbox_git_odb_stream(stream));

  /* Unbox param: buffer */
  char * native_buffer = TODO_mruby_unbox_char_PTR(buffer);

  /* Invocation */
  int native_return_value = git_odb_stream_read(native_stream, native_buffer, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_stream_write */
/* sha: 1fa1e430aa055490a438552644efe9b9219ea6314686b66742d004764ba8fab4 */
#if BIND_git_odb_stream_write_FUNCTION
#define git_odb_stream_write_REQUIRED_ARGC 3
#define git_odb_stream_write_OPTIONAL_ARGC 0
/* git_odb_stream_write
 *
 * Parameters:
 * - stream: git_odb_stream *
 * - buffer: const char *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_stream_write(mrb_state* mrb, mrb_value self) {
  mrb_value stream;
  char * native_buffer = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &stream, &native_buffer, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, stream, OdbStream_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbStream expected");
    return mrb_nil_value();
  }

  /* Unbox param: stream */
  git_odb_stream * native_stream = (mrb_nil_p(stream) ? NULL : mruby_unbox_git_odb_stream(stream));

  /* Invocation */
  int native_return_value = git_odb_stream_write(native_stream, native_buffer, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_write */
/* sha: a346ecc61926cef97e5393e2a8dc29107e9d8028289515350eceebb5b680ca40 */
#if BIND_git_odb_write_FUNCTION
#define git_odb_write_REQUIRED_ARGC 4
#define git_odb_write_OPTIONAL_ARGC 0
/* git_odb_write
 *
 * Parameters:
 * - out: git_oid *
 * - odb: git_odb *
 * - data: const void *
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_write(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value odb;
  mrb_value native_data;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "ooSi", &out, &odb, &native_data, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Invocation */
  int native_return_value = git_odb_write(native_out, native_odb, RSTRING_PTR(native_data), RSTRING_LEN(native_data), native_type);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_write_pack */
/* sha: afac81eca3c341951aad09235a866f91116d54f6292cc3f57e4d3079a0c7b234 */
#if BIND_git_odb_write_pack_FUNCTION
#define git_odb_write_pack_REQUIRED_ARGC 3
#define git_odb_write_pack_OPTIONAL_ARGC 0
/* git_odb_write_pack
 *
 * Parameters:
 * - db: git_odb *
 * - progress_cb: git_transfer_progress_cb
 * - progress_payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_write_pack(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_odb_writepack * native_out;
  mrb_value db;
  mrb_value progress_cb;
  mrb_value progress_payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &db, &progress_cb, &progress_payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_transfer_progress_cb(progress_cb);
  TODO_type_check_void_PTR(progress_payload);

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: progress_cb */
  git_transfer_progress_cb native_progress_cb = TODO_mruby_unbox_git_transfer_progress_cb(progress_cb);

  /* Unbox param: progress_payload */
  void * native_progress_payload = TODO_mruby_unbox_void_PTR(progress_payload);

  /* Invocation */
  int native_return_value = git_odb_write_pack(&native_out, native_db, native_progress_cb, native_progress_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = mruby_box_git_odb_writepack(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_cmp */
/* sha: e6081f769634e15c10e47ac8b7957350df24b1ff41e652025935f82494119f43 */
#if BIND_git_oid_cmp_FUNCTION
#define git_oid_cmp_REQUIRED_ARGC 2
#define git_oid_cmp_OPTIONAL_ARGC 0
/* git_oid_cmp
 *
 * Parameters:
 * - a: const git_oid *
 * - b: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_cmp(mrb_state* mrb, mrb_value self) {
  mrb_value a;
  mrb_value b;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &a, &b);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, a, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, b, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: a */
  const git_oid * native_a = (mrb_nil_p(a) ? NULL : mruby_unbox_git_oid(a));

  /* Unbox param: b */
  const git_oid * native_b = (mrb_nil_p(b) ? NULL : mruby_unbox_git_oid(b));

  /* Invocation */
  int native_return_value = git_oid_cmp(native_a, native_b);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_cpy */
/* sha: a664a4ece1c45869005a235098cb3564ef59a0b0b4e5647070e027d79141eb19 */
#if BIND_git_oid_cpy_FUNCTION
#define git_oid_cpy_REQUIRED_ARGC 2
#define git_oid_cpy_OPTIONAL_ARGC 0
/* git_oid_cpy
 *
 * Parameters:
 * - out: git_oid *
 * - src: const git_oid *
 * Return Type: void
 */
mrb_value
mrb_Git_git_oid_cpy(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value src;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &src);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, src, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: src */
  const git_oid * native_src = (mrb_nil_p(src) ? NULL : mruby_unbox_git_oid(src));

  /* Invocation */
  git_oid_cpy(native_out, native_src);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_equal */
/* sha: 3eedcbe975eacab0fb25e51841d26bbcaa3e0a1b03397ea090b994c7e6c67141 */
#if BIND_git_oid_equal_FUNCTION
#define git_oid_equal_REQUIRED_ARGC 2
#define git_oid_equal_OPTIONAL_ARGC 0
/* git_oid_equal
 *
 * Parameters:
 * - a: const git_oid *
 * - b: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_equal(mrb_state* mrb, mrb_value self) {
  mrb_value a;
  mrb_value b;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &a, &b);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, a, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, b, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: a */
  const git_oid * native_a = (mrb_nil_p(a) ? NULL : mruby_unbox_git_oid(a));

  /* Unbox param: b */
  const git_oid * native_b = (mrb_nil_p(b) ? NULL : mruby_unbox_git_oid(b));

  /* Invocation */
  int native_return_value = git_oid_equal(native_a, native_b);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_fmt */
/* sha: e1c9e85e260eb86bbacffe6fe9777cd52c31a7963cb90e95babecaf568b570b6 */
#if BIND_git_oid_fmt_FUNCTION
#define git_oid_fmt_REQUIRED_ARGC 2
#define git_oid_fmt_OPTIONAL_ARGC 0
/* git_oid_fmt
 *
 * Parameters:
 * - out: char *
 * - id: const git_oid *
 * Return Type: void
 */
mrb_value
mrb_Git_git_oid_fmt(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &id);

  /* Type checking */
  TODO_type_check_char_PTR(out);
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  char * native_out = TODO_mruby_unbox_char_PTR(out);

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  git_oid_fmt(native_out, native_id);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_fromraw */
/* sha: 8bbd663e773875930750a622e55c12b21d7aa2db293fffe5890a83df76b056ac */
#if BIND_git_oid_fromraw_FUNCTION
#define git_oid_fromraw_REQUIRED_ARGC 2
#define git_oid_fromraw_OPTIONAL_ARGC 0
/* git_oid_fromraw
 *
 * Parameters:
 * - out: git_oid *
 * - raw: const unsigned char *
 * Return Type: void
 */
mrb_value
mrb_Git_git_oid_fromraw(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value raw;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &raw);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_char_PTR(raw);

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: raw */
  const unsigned char * native_raw = TODO_mruby_unbox_unsigned_char_PTR(raw);

  /* Invocation */
  git_oid_fromraw(native_out, native_raw);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_fromstr */
/* sha: b6a812dc065ea723c860b08d13988168f992f2fc5778245581b3cf4589ac2113 */
#if BIND_git_oid_fromstr_FUNCTION
#define git_oid_fromstr_REQUIRED_ARGC 2
#define git_oid_fromstr_OPTIONAL_ARGC 0
/* git_oid_fromstr
 *
 * Parameters:
 * - out: git_oid *
 * - str: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_fromstr(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  char * native_str = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &out, &native_str);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Invocation */
  int native_return_value = git_oid_fromstr(native_out, native_str);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_fromstrn */
/* sha: 22182b13af99eafc1bf1317823a8b54dc446c39a5cbfe9fa3f9f3050c8732b1c */
#if BIND_git_oid_fromstrn_FUNCTION
#define git_oid_fromstrn_REQUIRED_ARGC 3
#define git_oid_fromstrn_OPTIONAL_ARGC 0
/* git_oid_fromstrn
 *
 * Parameters:
 * - out: git_oid *
 * - str: const char *
 * - length: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_fromstrn(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  char * native_str = NULL;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &out, &native_str, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Invocation */
  int native_return_value = git_oid_fromstrn(native_out, native_str, native_length);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_fromstrp */
/* sha: 8d6a29f2dcd7c7ecaf961684b5069ec95a4848cb6ea097ce973013156dc12fd5 */
#if BIND_git_oid_fromstrp_FUNCTION
#define git_oid_fromstrp_REQUIRED_ARGC 2
#define git_oid_fromstrp_OPTIONAL_ARGC 0
/* git_oid_fromstrp
 *
 * Parameters:
 * - out: git_oid *
 * - str: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_fromstrp(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  char * native_str = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &out, &native_str);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Invocation */
  int native_return_value = git_oid_fromstrp(native_out, native_str);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_iszero */
/* sha: 4be0264ccc736329ef56c5f912fd838ae693af27764985aa73b7b67bfc2e94d1 */
#if BIND_git_oid_iszero_FUNCTION
#define git_oid_iszero_REQUIRED_ARGC 1
#define git_oid_iszero_OPTIONAL_ARGC 0
/* git_oid_iszero
 *
 * Parameters:
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_iszero(mrb_state* mrb, mrb_value self) {
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_oid_iszero(native_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_ncmp */
/* sha: 301d65bfccb5de90d155136f8b0d30370cc3b7788e0281b7b71fca5785df9740 */
#if BIND_git_oid_ncmp_FUNCTION
#define git_oid_ncmp_REQUIRED_ARGC 3
#define git_oid_ncmp_OPTIONAL_ARGC 0
/* git_oid_ncmp
 *
 * Parameters:
 * - a: const git_oid *
 * - b: const git_oid *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_ncmp(mrb_state* mrb, mrb_value self) {
  mrb_value a;
  mrb_value b;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &a, &b, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, a, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, b, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: a */
  const git_oid * native_a = (mrb_nil_p(a) ? NULL : mruby_unbox_git_oid(a));

  /* Unbox param: b */
  const git_oid * native_b = (mrb_nil_p(b) ? NULL : mruby_unbox_git_oid(b));

  /* Invocation */
  int native_return_value = git_oid_ncmp(native_a, native_b, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_nfmt */
/* sha: 8c1cd011c2e321db8a14844cbf90a4fa5c0cf20cf22de8081381e8d3a9b09a56 */
#if BIND_git_oid_nfmt_FUNCTION
#define git_oid_nfmt_REQUIRED_ARGC 3
#define git_oid_nfmt_OPTIONAL_ARGC 0
/* git_oid_nfmt
 *
 * Parameters:
 * - out: char *
 * - n: size_t
 * - id: const git_oid *
 * Return Type: void
 */
mrb_value
mrb_Git_git_oid_nfmt(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_int native_n;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &out, &native_n, &id);

  /* Type checking */
  TODO_type_check_char_PTR(out);
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  char * native_out = TODO_mruby_unbox_char_PTR(out);

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  git_oid_nfmt(native_out, native_n, native_id);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_pathfmt */
/* sha: c1567f6b284628de2b172834a45fa1a3fab665cef942808b3f386af909e12af4 */
#if BIND_git_oid_pathfmt_FUNCTION
#define git_oid_pathfmt_REQUIRED_ARGC 2
#define git_oid_pathfmt_OPTIONAL_ARGC 0
/* git_oid_pathfmt
 *
 * Parameters:
 * - out: char *
 * - id: const git_oid *
 * Return Type: void
 */
mrb_value
mrb_Git_git_oid_pathfmt(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &id);

  /* Type checking */
  TODO_type_check_char_PTR(out);
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  char * native_out = TODO_mruby_unbox_char_PTR(out);

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  git_oid_pathfmt(native_out, native_id);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_shorten_add */
/* sha: f3abfc9f10c0fcb45f1daacf5bee0e16aa4515c3814e9ec366e785fbe6ab4b82 */
#if BIND_git_oid_shorten_add_FUNCTION
#define git_oid_shorten_add_REQUIRED_ARGC 2
#define git_oid_shorten_add_OPTIONAL_ARGC 0
/* git_oid_shorten_add
 *
 * Parameters:
 * - os: git_oid_shorten *
 * - text_id: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_shorten_add(mrb_state* mrb, mrb_value self) {
  mrb_value os;
  char * native_text_id = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &os, &native_text_id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, os, OidShorten_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OidShorten expected");
    return mrb_nil_value();
  }

  /* Unbox param: os */
  git_oid_shorten * native_os = (mrb_nil_p(os) ? NULL : mruby_unbox_git_oid_shorten(os));

  /* Invocation */
  int native_return_value = git_oid_shorten_add(native_os, native_text_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_shorten_free */
/* sha: 6fb199cbe6c340b6c0f0b10a34ae19802e566992a86b75b8dce4beae1c1866c1 */
#if BIND_git_oid_shorten_free_FUNCTION
#define git_oid_shorten_free_REQUIRED_ARGC 1
#define git_oid_shorten_free_OPTIONAL_ARGC 0
/* git_oid_shorten_free
 *
 * Parameters:
 * - os: git_oid_shorten *
 * Return Type: void
 */
mrb_value
mrb_Git_git_oid_shorten_free(mrb_state* mrb, mrb_value self) {
  mrb_value os;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &os);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, os, OidShorten_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OidShorten expected");
    return mrb_nil_value();
  }

  /* Unbox param: os */
  git_oid_shorten * native_os = (mrb_nil_p(os) ? NULL : mruby_unbox_git_oid_shorten(os));

  /* Invocation */
  git_oid_shorten_free(native_os);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_shorten_new */
/* sha: 853ecf5ce92a98333fede8de7f0f59c06bb46f58fce59fa0208fbf2717af09b8 */
#if BIND_git_oid_shorten_new_FUNCTION
#define git_oid_shorten_new_REQUIRED_ARGC 1
#define git_oid_shorten_new_OPTIONAL_ARGC 0
/* git_oid_shorten_new
 *
 * Parameters:
 * - min_length: size_t
 * Return Type: git_oid_shorten *
 */
mrb_value
mrb_Git_git_oid_shorten_new(mrb_state* mrb, mrb_value self) {
  mrb_int native_min_length;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_min_length);

  /* Invocation */
  git_oid_shorten * native_return_value = git_oid_shorten_new(native_min_length);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid_shorten(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_strcmp */
/* sha: b1908cd85711d18bcf772b71976ea194252b97376599f19ab6e1dee9b1b456fc */
#if BIND_git_oid_strcmp_FUNCTION
#define git_oid_strcmp_REQUIRED_ARGC 2
#define git_oid_strcmp_OPTIONAL_ARGC 0
/* git_oid_strcmp
 *
 * Parameters:
 * - id: const git_oid *
 * - str: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_strcmp(mrb_state* mrb, mrb_value self) {
  mrb_value id;
  char * native_str = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &id, &native_str);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_oid_strcmp(native_id, native_str);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_streq */
/* sha: 1afe4514820ebd1cd49a7cad34da34305487add18d8b601183d3fb6861463e6a */
#if BIND_git_oid_streq_FUNCTION
#define git_oid_streq_REQUIRED_ARGC 2
#define git_oid_streq_OPTIONAL_ARGC 0
/* git_oid_streq
 *
 * Parameters:
 * - id: const git_oid *
 * - str: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_streq(mrb_state* mrb, mrb_value self) {
  mrb_value id;
  char * native_str = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &id, &native_str);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_oid_streq(native_id, native_str);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_tostr */
/* sha: 9b3a40569b07978f1eca44a1cc77d88f304b0b43972d5b44dfe79658aa0b5cb1 */
#if BIND_git_oid_tostr_FUNCTION
#define git_oid_tostr_REQUIRED_ARGC 3
#define git_oid_tostr_OPTIONAL_ARGC 0
/* git_oid_tostr
 *
 * Parameters:
 * - out: char *
 * - n: size_t
 * - id: const git_oid *
 * Return Type: char *
 */
mrb_value
mrb_Git_git_oid_tostr(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_int native_n;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &out, &native_n, &id);

  /* Type checking */
  TODO_type_check_char_PTR(out);
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  char * native_out = TODO_mruby_unbox_char_PTR(out);

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  char * native_return_value = git_oid_tostr(native_out, native_n, native_id);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_char_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_tostr_s */
/* sha: 294f6daa9bd7f78340fdfe2e05d0eae804ca4be74ae1afc86149fcf56941d2bf */
#if BIND_git_oid_tostr_s_FUNCTION
#define git_oid_tostr_s_REQUIRED_ARGC 1
#define git_oid_tostr_s_OPTIONAL_ARGC 0
/* git_oid_tostr_s
 *
 * Parameters:
 * - oid: const git_oid *
 * Return Type: char *
 */
mrb_value
mrb_Git_git_oid_tostr_s(mrb_state* mrb, mrb_value self) {
  mrb_value oid;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &oid);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, oid, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: oid */
  const git_oid * native_oid = (mrb_nil_p(oid) ? NULL : mruby_unbox_git_oid(oid));

  /* Invocation */
  char * native_return_value = git_oid_tostr_s(native_oid);

  /* Box the return value */
  mrb_value return_value = native_return_value ==  NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oidarray_free */
/* sha: 35c7f747de2e2c384802374182b756b3d3ede52c21d5e69083288f1c3d64e113 */
#if BIND_git_oidarray_free_FUNCTION
#define git_oidarray_free_REQUIRED_ARGC 1
#define git_oidarray_free_OPTIONAL_ARGC 0
/* git_oidarray_free
 *
 * Parameters:
 * - array: git_oidarray *
 * Return Type: void
 */
mrb_value
mrb_Git_git_oidarray_free(mrb_state* mrb, mrb_value self) {
  mrb_value array;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, Oidarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oidarray expected");
    return mrb_nil_value();
  }

  /* Unbox param: array */
  git_oidarray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox_git_oidarray(array));

  /* Invocation */
  git_oidarray_free(native_array);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_foreach */
/* sha: b5931a181440eef53b781c755fd81fa8f3179c11ad07ffa3aa737ff78e949ae5 */
#if BIND_git_packbuilder_foreach_FUNCTION
#define git_packbuilder_foreach_REQUIRED_ARGC 3
#define git_packbuilder_foreach_OPTIONAL_ARGC 0
/* git_packbuilder_foreach
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - cb: git_packbuilder_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value pb;
  mrb_value cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &pb, &cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_packbuilder_foreach_cb(cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: cb */
  git_packbuilder_foreach_cb native_cb = TODO_mruby_unbox_git_packbuilder_foreach_cb(cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_packbuilder_foreach(native_pb, native_cb, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_free */
/* sha: 32a3cd8534f8c2d93ef23a7de451cb03cc291c74abd7f5f825aa537986fbd662 */
#if BIND_git_packbuilder_free_FUNCTION
#define git_packbuilder_free_REQUIRED_ARGC 1
#define git_packbuilder_free_OPTIONAL_ARGC 0
/* git_packbuilder_free
 *
 * Parameters:
 * - pb: git_packbuilder *
 * Return Type: void
 */
mrb_value
mrb_Git_git_packbuilder_free(mrb_state* mrb, mrb_value self) {
  mrb_value pb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &pb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Invocation */
  git_packbuilder_free(native_pb);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_hash */
/* sha: 6222b3b3c3dc6d0c75dcd68da5074b30dbcfc5b25d720e5dba15e2d122d52d30 */
#if BIND_git_packbuilder_hash_FUNCTION
#define git_packbuilder_hash_REQUIRED_ARGC 1
#define git_packbuilder_hash_OPTIONAL_ARGC 0
/* git_packbuilder_hash
 *
 * Parameters:
 * - pb: git_packbuilder *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_packbuilder_hash(mrb_state* mrb, mrb_value self) {
  mrb_value pb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &pb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Invocation */
  const git_oid * native_return_value = git_packbuilder_hash(native_pb);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_insert */
/* sha: c6d9b67df537346b590152505383b9841e5ae3b0b20d672bdbc9e4c707e7df6f */
#if BIND_git_packbuilder_insert_FUNCTION
#define git_packbuilder_insert_REQUIRED_ARGC 3
#define git_packbuilder_insert_OPTIONAL_ARGC 0
/* git_packbuilder_insert
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - id: const git_oid *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_insert(mrb_state* mrb, mrb_value self) {
  mrb_value pb;
  mrb_value id;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &pb, &id, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_packbuilder_insert(native_pb, native_id, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_insert_commit */
/* sha: aede3df22bdd5c9cc3f38884f1f046ba7c0e6de41b79779003cd27cf185fe71f */
#if BIND_git_packbuilder_insert_commit_FUNCTION
#define git_packbuilder_insert_commit_REQUIRED_ARGC 2
#define git_packbuilder_insert_commit_OPTIONAL_ARGC 0
/* git_packbuilder_insert_commit
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_insert_commit(mrb_state* mrb, mrb_value self) {
  mrb_value pb;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &pb, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_packbuilder_insert_commit(native_pb, native_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_insert_recur */
/* sha: ba4e277c2bacfed880035b0080ae29eb929f1bd70796e9dd11971654b76fb7ab */
#if BIND_git_packbuilder_insert_recur_FUNCTION
#define git_packbuilder_insert_recur_REQUIRED_ARGC 3
#define git_packbuilder_insert_recur_OPTIONAL_ARGC 0
/* git_packbuilder_insert_recur
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - id: const git_oid *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_insert_recur(mrb_state* mrb, mrb_value self) {
  mrb_value pb;
  mrb_value id;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &pb, &id, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_packbuilder_insert_recur(native_pb, native_id, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_insert_tree */
/* sha: bb66206abd5f277b855367d6cabab9c4ccc67dcdcd3b11882e03f5a8aa42d18e */
#if BIND_git_packbuilder_insert_tree_FUNCTION
#define git_packbuilder_insert_tree_REQUIRED_ARGC 2
#define git_packbuilder_insert_tree_OPTIONAL_ARGC 0
/* git_packbuilder_insert_tree
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_insert_tree(mrb_state* mrb, mrb_value self) {
  mrb_value pb;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &pb, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_packbuilder_insert_tree(native_pb, native_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_insert_walk */
/* sha: 2fe6e2ad5c3f70bcb01a1b2e71f2da0dd9800c38c0100103d55a0fb4fe114062 */
#if BIND_git_packbuilder_insert_walk_FUNCTION
#define git_packbuilder_insert_walk_REQUIRED_ARGC 2
#define git_packbuilder_insert_walk_OPTIONAL_ARGC 0
/* git_packbuilder_insert_walk
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - walk: git_revwalk *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_insert_walk(mrb_state* mrb, mrb_value self) {
  mrb_value pb;
  mrb_value walk;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &pb, &walk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_packbuilder_insert_walk(native_pb, native_walk);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_new */
/* sha: fd4f331ee9104e25758bcfee53dd07d83d2755942ef64a1b0be200c79b52f0b4 */
#if BIND_git_packbuilder_new_FUNCTION
#define git_packbuilder_new_REQUIRED_ARGC 1
#define git_packbuilder_new_OPTIONAL_ARGC 0
/* git_packbuilder_new
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_packbuilder * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_packbuilder_new(&native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_packbuilder(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_object_count */
/* sha: 6fa512ffc813b674dbbf194486d284f6d89a604ff1aa603e244912060ff6566f */
#if BIND_git_packbuilder_object_count_FUNCTION
#define git_packbuilder_object_count_REQUIRED_ARGC 1
#define git_packbuilder_object_count_OPTIONAL_ARGC 0
/* git_packbuilder_object_count
 *
 * Parameters:
 * - pb: git_packbuilder *
 * Return Type: uint32_t
 */
mrb_value
mrb_Git_git_packbuilder_object_count(mrb_state* mrb, mrb_value self) {
  mrb_value pb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &pb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Invocation */
  uint32_t native_return_value = git_packbuilder_object_count(native_pb);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_set_callbacks */
/* sha: 0d54e59d2b45606cd3b1ed7866f952bbd43e68f29ddf196cfd0ae81597216ab5 */
#if BIND_git_packbuilder_set_callbacks_FUNCTION
#define git_packbuilder_set_callbacks_REQUIRED_ARGC 3
#define git_packbuilder_set_callbacks_OPTIONAL_ARGC 0
/* git_packbuilder_set_callbacks
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - progress_cb: git_packbuilder_progress
 * - progress_cb_payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_set_callbacks(mrb_state* mrb, mrb_value self) {
  mrb_value pb;
  mrb_value progress_cb;
  mrb_value progress_cb_payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &pb, &progress_cb, &progress_cb_payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_packbuilder_progress(progress_cb);
  TODO_type_check_void_PTR(progress_cb_payload);

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: progress_cb */
  git_packbuilder_progress native_progress_cb = TODO_mruby_unbox_git_packbuilder_progress(progress_cb);

  /* Unbox param: progress_cb_payload */
  void * native_progress_cb_payload = TODO_mruby_unbox_void_PTR(progress_cb_payload);

  /* Invocation */
  int native_return_value = git_packbuilder_set_callbacks(native_pb, native_progress_cb, native_progress_cb_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_set_threads */
/* sha: ec57b8ddb9882fa7218ce80510133a558538565a45fc1bd814bdf5d59f6f135c */
#if BIND_git_packbuilder_set_threads_FUNCTION
#define git_packbuilder_set_threads_REQUIRED_ARGC 2
#define git_packbuilder_set_threads_OPTIONAL_ARGC 0
/* git_packbuilder_set_threads
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - n: unsigned int
 * Return Type: unsigned int
 */
mrb_value
mrb_Git_git_packbuilder_set_threads(mrb_state* mrb, mrb_value self) {
  mrb_value pb;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &pb, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Invocation */
  unsigned int native_return_value = git_packbuilder_set_threads(native_pb, native_n);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_write */
/* sha: a058f055443f84aba791602ad8f843ac532b44a2de6f668e3c97e3c070f6e62f */
#if BIND_git_packbuilder_write_FUNCTION
#define git_packbuilder_write_REQUIRED_ARGC 5
#define git_packbuilder_write_OPTIONAL_ARGC 0
/* git_packbuilder_write
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - path: const char *
 * - mode: unsigned int
 * - progress_cb: git_transfer_progress_cb
 * - progress_cb_payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_write(mrb_state* mrb, mrb_value self) {
  mrb_value pb;
  char * native_path = NULL;
  mrb_int native_mode;
  mrb_value progress_cb;
  mrb_value progress_cb_payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozioo", &pb, &native_path, &native_mode, &progress_cb, &progress_cb_payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_transfer_progress_cb(progress_cb);
  TODO_type_check_void_PTR(progress_cb_payload);

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: progress_cb */
  git_transfer_progress_cb native_progress_cb = TODO_mruby_unbox_git_transfer_progress_cb(progress_cb);

  /* Unbox param: progress_cb_payload */
  void * native_progress_cb_payload = TODO_mruby_unbox_void_PTR(progress_cb_payload);

  /* Invocation */
  int native_return_value = git_packbuilder_write(native_pb, native_path, native_mode, native_progress_cb, native_progress_cb_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_write_buf */
/* sha: a3d7b1a0a8b7ecf0d2e573f39a15260687279e57e7b45bd63d4d7bde0d605dbe */
#if BIND_git_packbuilder_write_buf_FUNCTION
#define git_packbuilder_write_buf_REQUIRED_ARGC 2
#define git_packbuilder_write_buf_OPTIONAL_ARGC 0
/* git_packbuilder_write_buf
 *
 * Parameters:
 * - buf: git_buf *
 * - pb: git_packbuilder *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_write_buf(mrb_state* mrb, mrb_value self) {
  mrb_value buf;
  mrb_value pb;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &buf, &pb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, buf, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: buf */
  git_buf * native_buf = (mrb_nil_p(buf) ? NULL : mruby_unbox_git_buf(buf));

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Invocation */
  int native_return_value = git_packbuilder_write_buf(native_buf, native_pb);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_written */
/* sha: a47e95eb7336dc43814006c9d5276e974e8d238ccbafa0614043121ceea8aa35 */
#if BIND_git_packbuilder_written_FUNCTION
#define git_packbuilder_written_REQUIRED_ARGC 1
#define git_packbuilder_written_OPTIONAL_ARGC 0
/* git_packbuilder_written
 *
 * Parameters:
 * - pb: git_packbuilder *
 * Return Type: uint32_t
 */
mrb_value
mrb_Git_git_packbuilder_written(mrb_state* mrb, mrb_value self) {
  mrb_value pb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &pb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Invocation */
  uint32_t native_return_value = git_packbuilder_written(native_pb);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_free */
/* sha: 76b331b62b1325fbc15c2eb271270dcc2783698d8e9a9181939866c60839592e */
#if BIND_git_patch_free_FUNCTION
#define git_patch_free_REQUIRED_ARGC 1
#define git_patch_free_OPTIONAL_ARGC 0
/* git_patch_free
 *
 * Parameters:
 * - patch: git_patch *
 * Return Type: void
 */
mrb_value
mrb_Git_git_patch_free(mrb_state* mrb, mrb_value self) {
  mrb_value patch;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &patch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  git_patch_free(native_patch);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_from_blob_and_buffer */
/* sha: 726e612d26f9d4238c691b79763f7bb9c67e9ad418b83e0dc334f41c99def042 */
#if BIND_git_patch_from_blob_and_buffer_FUNCTION
#define git_patch_from_blob_and_buffer_REQUIRED_ARGC 6
#define git_patch_from_blob_and_buffer_OPTIONAL_ARGC 0
/* git_patch_from_blob_and_buffer
 *
 * Parameters:
 * - old_blob: const git_blob *
 * - old_as_path: const char *
 * - buffer: const char *
 * - buffer_len: size_t
 * - buffer_as_path: const char *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_from_blob_and_buffer(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_patch * native_out = NULL;
  mrb_value old_blob;
  char * native_old_as_path = NULL;
  char * native_buffer = NULL;
  mrb_int native_buffer_len;
  char * native_buffer_as_path = NULL;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzizo", &old_blob, &native_old_as_path, &native_buffer, &native_buffer_len, &native_buffer_as_path, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, old_blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: old_blob */
  const git_blob * native_old_blob = (mrb_nil_p(old_blob) ? NULL : mruby_unbox_git_blob(old_blob));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_patch_from_blob_and_buffer(&native_out, native_old_blob, native_old_as_path, native_buffer, native_buffer_len, native_buffer_as_path, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_patch(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_from_blobs */
/* sha: 2f0931464eb148c3bc8938c11cc0c9fc61c60d67dccf2fcc20cd0dda0b92ccce */
#if BIND_git_patch_from_blobs_FUNCTION
#define git_patch_from_blobs_REQUIRED_ARGC 5
#define git_patch_from_blobs_OPTIONAL_ARGC 0
/* git_patch_from_blobs
 *
 * Parameters:
 * - old_blob: const git_blob *
 * - old_as_path: const char *
 * - new_blob: const git_blob *
 * - new_as_path: const char *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_from_blobs(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_patch * native_out = NULL;
  mrb_value old_blob;
  char * native_old_as_path = NULL;
  mrb_value new_blob;
  char * native_new_as_path = NULL;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ozozo", &old_blob, &native_old_as_path, &new_blob, &native_new_as_path, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, old_blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, new_blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: old_blob */
  const git_blob * native_old_blob = (mrb_nil_p(old_blob) ? NULL : mruby_unbox_git_blob(old_blob));

  /* Unbox param: new_blob */
  const git_blob * native_new_blob = (mrb_nil_p(new_blob) ? NULL : mruby_unbox_git_blob(new_blob));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_patch_from_blobs(&native_out, native_old_blob, native_old_as_path, native_new_blob, native_new_as_path, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_patch(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_from_buffers */
/* sha: 31b943170ae62550815a8de4eea52b003272705ab55e8977fe405a703232414c */
#if BIND_git_patch_from_buffers_FUNCTION
#define git_patch_from_buffers_REQUIRED_ARGC 7
#define git_patch_from_buffers_OPTIONAL_ARGC 0
/* git_patch_from_buffers
 *
 * Parameters:
 * - old_buffer: const void *
 * - old_len: size_t
 * - old_as_path: const char *
 * - new_buffer: const char *
 * - new_len: size_t
 * - new_as_path: const char *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_from_buffers(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_patch * native_out = NULL;
  mrb_value old_buffer;
  mrb_int native_old_len;
  char * native_old_as_path = NULL;
  char * native_new_buffer = NULL;
  mrb_int native_new_len;
  char * native_new_as_path = NULL;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oizzizo", &old_buffer, &native_old_len, &native_old_as_path, &native_new_buffer, &native_new_len, &native_new_as_path, &opts);

  /* Type checking */
  TODO_type_check_void_PTR(old_buffer);
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: old_buffer */
  const void * native_old_buffer = TODO_mruby_unbox_void_PTR(old_buffer);

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_patch_from_buffers(&native_out, native_old_buffer, native_old_len, native_old_as_path, native_new_buffer, native_new_len, native_new_as_path, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_patch(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_from_diff */
/* sha: f2645f93d063e351e420b12168a5abe13e7f7450e88e233e90b2562fb3eeaff0 */
#if BIND_git_patch_from_diff_FUNCTION
#define git_patch_from_diff_REQUIRED_ARGC 2
#define git_patch_from_diff_OPTIONAL_ARGC 0
/* git_patch_from_diff
 *
 * Parameters:
 * - diff: git_diff *
 * - idx: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_from_diff(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_patch * native_out = NULL;
  mrb_value diff;
  mrb_int native_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &diff, &native_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Invocation */
  int native_return_value = git_patch_from_diff(&native_out, native_diff, native_idx);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_patch(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_get_delta */
/* sha: 69d50173badee25fc3d2380acd154dfa1832401385aa745c89e2915aaf8299bf */
#if BIND_git_patch_get_delta_FUNCTION
#define git_patch_get_delta_REQUIRED_ARGC 1
#define git_patch_get_delta_OPTIONAL_ARGC 0
/* git_patch_get_delta
 *
 * Parameters:
 * - patch: const git_patch *
 * Return Type: const git_diff_delta *
 */
mrb_value
mrb_Git_git_patch_get_delta(mrb_state* mrb, mrb_value self) {
  mrb_value patch;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &patch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  const git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  const git_diff_delta * native_return_value = git_patch_get_delta(native_patch);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_diff_delta(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_get_hunk */
/* sha: ed183f9a80b90234f493846d2ba1f957a04b17102429d7d4b324f7d647577453 */
#if BIND_git_patch_get_hunk_FUNCTION
#define git_patch_get_hunk_REQUIRED_ARGC 2
#define git_patch_get_hunk_OPTIONAL_ARGC 0
/* git_patch_get_hunk
 *
 * Parameters:
 * - patch: git_patch *
 * - hunk_idx: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_get_hunk(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_diff_hunk * native_out;
  int native_lines_in_hunk;
  mrb_value patch;
  mrb_int native_hunk_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &patch, &native_hunk_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  int native_return_value = git_patch_get_hunk(&native_out, &native_lines_in_hunk, native_patch, native_hunk_idx);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = mruby_box_git_diff_hunk(mrb, native_out);
  /* Box out param: lines_in_hunk */
  mrb_value lines_in_hunk = mrb_fixnum_value(native_lines_in_hunk);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);
  mrb_ary_push(mrb, results, lines_in_hunk);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_get_line_in_hunk */
/* sha: 380939d162248f64fa14c479aeb45202c97e5abffd016ddcc4aad12ad7cfdbf4 */
#if BIND_git_patch_get_line_in_hunk_FUNCTION
#define git_patch_get_line_in_hunk_REQUIRED_ARGC 3
#define git_patch_get_line_in_hunk_OPTIONAL_ARGC 0
/* git_patch_get_line_in_hunk
 *
 * Parameters:
 * - patch: git_patch *
 * - hunk_idx: size_t
 * - line_of_hunk: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_get_line_in_hunk(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_diff_line * native_out;
  mrb_value patch;
  mrb_int native_hunk_idx;
  mrb_int native_line_of_hunk;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &patch, &native_hunk_idx, &native_line_of_hunk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  int native_return_value = git_patch_get_line_in_hunk(&native_out, native_patch, native_hunk_idx, native_line_of_hunk);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = mruby_box_git_diff_line(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_line_stats */
/* sha: 746118591ace18e34f7518d84ff4243244919cbe8a62c562e16be1c1389bf364 */
#if BIND_git_patch_line_stats_FUNCTION
#define git_patch_line_stats_REQUIRED_ARGC 1
#define git_patch_line_stats_OPTIONAL_ARGC 0
/* git_patch_line_stats
 *
 * Parameters:
 * - patch: const git_patch *
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_line_stats(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_total_context;
  int native_total_additions;
  int native_total_deletions;
  mrb_value patch;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &patch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  const git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  int native_return_value = git_patch_line_stats(&native_total_context, &native_total_additions, &native_total_deletions, native_patch);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: total_context */
  mrb_value total_context = mrb_fixnum_value(native_total_context);
  /* Box out param: total_additions */
  mrb_value total_additions = mrb_fixnum_value(native_total_additions);
  /* Box out param: total_deletions */
  mrb_value total_deletions = mrb_fixnum_value(native_total_deletions);

  /* Add out params to results */
  mrb_ary_push(mrb, results, total_context);
  mrb_ary_push(mrb, results, total_additions);
  mrb_ary_push(mrb, results, total_deletions);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_num_hunks */
/* sha: af6d6afaa094c0a712fb0ca2d281866c908ce19851b490353d0aa03110c2dd6e */
#if BIND_git_patch_num_hunks_FUNCTION
#define git_patch_num_hunks_REQUIRED_ARGC 1
#define git_patch_num_hunks_OPTIONAL_ARGC 0
/* git_patch_num_hunks
 *
 * Parameters:
 * - patch: const git_patch *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_patch_num_hunks(mrb_state* mrb, mrb_value self) {
  mrb_value patch;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &patch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  const git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  size_t native_return_value = git_patch_num_hunks(native_patch);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_num_lines_in_hunk */
/* sha: 2d845dce6aeb876e7759b5aabca752dccb82af9589ce413f7afc7797097cf3b0 */
#if BIND_git_patch_num_lines_in_hunk_FUNCTION
#define git_patch_num_lines_in_hunk_REQUIRED_ARGC 2
#define git_patch_num_lines_in_hunk_OPTIONAL_ARGC 0
/* git_patch_num_lines_in_hunk
 *
 * Parameters:
 * - patch: const git_patch *
 * - hunk_idx: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_num_lines_in_hunk(mrb_state* mrb, mrb_value self) {
  mrb_value patch;
  mrb_int native_hunk_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &patch, &native_hunk_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  const git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  int native_return_value = git_patch_num_lines_in_hunk(native_patch, native_hunk_idx);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_print */
/* sha: 53703e7c103994aaea8e7f3a24a0e7cf0d29a59cc651c70204483e7cf16cc7c5 */
#if BIND_git_patch_print_FUNCTION
#define git_patch_print_REQUIRED_ARGC 3
#define git_patch_print_OPTIONAL_ARGC 0
/* git_patch_print
 *
 * Parameters:
 * - patch: git_patch *
 * - print_cb: git_diff_line_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_print(mrb_state* mrb, mrb_value self) {
  mrb_value patch;
  mrb_value print_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &patch, &print_cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_diff_line_cb(print_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: patch */
  git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Unbox param: print_cb */
  git_diff_line_cb native_print_cb = TODO_mruby_unbox_git_diff_line_cb(print_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_patch_print(native_patch, native_print_cb, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_size */
/* sha: f7c61742d6a34a841ac8cd2c2177406c87244000b46dbb44a14a3483f0857bc5 */
#if BIND_git_patch_size_FUNCTION
#define git_patch_size_REQUIRED_ARGC 4
#define git_patch_size_OPTIONAL_ARGC 0
/* git_patch_size
 *
 * Parameters:
 * - patch: git_patch *
 * - include_context: int
 * - include_hunk_headers: int
 * - include_file_headers: int
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_patch_size(mrb_state* mrb, mrb_value self) {
  mrb_value patch;
  mrb_int native_include_context;
  mrb_int native_include_hunk_headers;
  mrb_int native_include_file_headers;

  /* Fetch the args */
  mrb_get_args(mrb, "oiii", &patch, &native_include_context, &native_include_hunk_headers, &native_include_file_headers);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  size_t native_return_value = git_patch_size(native_patch, native_include_context, native_include_hunk_headers, native_include_file_headers);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_to_buf */
/* sha: 367a1c7e7f01f914d457aa5302929d6e30ecc9574658866e6d87c5d6c8b5edd4 */
#if BIND_git_patch_to_buf_FUNCTION
#define git_patch_to_buf_REQUIRED_ARGC 2
#define git_patch_to_buf_OPTIONAL_ARGC 0
/* git_patch_to_buf
 *
 * Parameters:
 * - out: git_buf *
 * - patch: git_patch *
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_to_buf(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value patch;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &patch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: patch */
  git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  int native_return_value = git_patch_to_buf(native_out, native_patch);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_free */
/* sha: bf3ff835398fe96c7c0bdb57ce8fd45b632bf53a3e803c97c42251e35a4ea225 */
#if BIND_git_pathspec_free_FUNCTION
#define git_pathspec_free_REQUIRED_ARGC 1
#define git_pathspec_free_OPTIONAL_ARGC 0
/* git_pathspec_free
 *
 * Parameters:
 * - ps: git_pathspec *
 * Return Type: void
 */
mrb_value
mrb_Git_git_pathspec_free(mrb_state* mrb, mrb_value self) {
  mrb_value ps;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ps);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ps, Pathspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Pathspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: ps */
  git_pathspec * native_ps = (mrb_nil_p(ps) ? NULL : mruby_unbox_git_pathspec(ps));

  /* Invocation */
  git_pathspec_free(native_ps);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_diff */
/* sha: 8a9f97333396551ae66266eb848b32ff88da196272611fb2e88345dc5929d9aa */
#if BIND_git_pathspec_match_diff_FUNCTION
#define git_pathspec_match_diff_REQUIRED_ARGC 3
#define git_pathspec_match_diff_OPTIONAL_ARGC 0
/* git_pathspec_match_diff
 *
 * Parameters:
 * - diff: git_diff *
 * - flags: uint32_t
 * - ps: git_pathspec *
 * Return Type: int
 */
mrb_value
mrb_Git_git_pathspec_match_diff(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_pathspec_match_list * native_out = NULL;
  mrb_value diff;
  mrb_int native_flags;
  mrb_value ps;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &diff, &native_flags, &ps);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ps, Pathspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Pathspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Unbox param: ps */
  git_pathspec * native_ps = (mrb_nil_p(ps) ? NULL : mruby_unbox_git_pathspec(ps));

  /* Invocation */
  int native_return_value = git_pathspec_match_diff(&native_out, native_diff, native_flags, native_ps);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_pathspec_match_list(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_index */
/* sha: d31971aea2869d7aa2b60a79b34a56033602fbf478447505ac2e1c8770d31a9b */
#if BIND_git_pathspec_match_index_FUNCTION
#define git_pathspec_match_index_REQUIRED_ARGC 3
#define git_pathspec_match_index_OPTIONAL_ARGC 0
/* git_pathspec_match_index
 *
 * Parameters:
 * - index: git_index *
 * - flags: uint32_t
 * - ps: git_pathspec *
 * Return Type: int
 */
mrb_value
mrb_Git_git_pathspec_match_index(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_pathspec_match_list * native_out = NULL;
  mrb_value index;
  mrb_int native_flags;
  mrb_value ps;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &index, &native_flags, &ps);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ps, Pathspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Pathspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: ps */
  git_pathspec * native_ps = (mrb_nil_p(ps) ? NULL : mruby_unbox_git_pathspec(ps));

  /* Invocation */
  int native_return_value = git_pathspec_match_index(&native_out, native_index, native_flags, native_ps);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_pathspec_match_list(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_list_diff_entry */
/* sha: fc7b30138a3fc0a822d5066bc847bdda309de111d00c22405841e2e3c9a96871 */
#if BIND_git_pathspec_match_list_diff_entry_FUNCTION
#define git_pathspec_match_list_diff_entry_REQUIRED_ARGC 2
#define git_pathspec_match_list_diff_entry_OPTIONAL_ARGC 0
/* git_pathspec_match_list_diff_entry
 *
 * Parameters:
 * - m: const git_pathspec_match_list *
 * - pos: size_t
 * Return Type: const git_diff_delta *
 */
mrb_value
mrb_Git_git_pathspec_match_list_diff_entry(mrb_state* mrb, mrb_value self) {
  mrb_value m;
  mrb_int native_pos;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &m, &native_pos);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, m, PathspecMatchList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PathspecMatchList expected");
    return mrb_nil_value();
  }

  /* Unbox param: m */
  const git_pathspec_match_list * native_m = (mrb_nil_p(m) ? NULL : mruby_unbox_git_pathspec_match_list(m));

  /* Invocation */
  const git_diff_delta * native_return_value = git_pathspec_match_list_diff_entry(native_m, native_pos);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_diff_delta(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_list_entry */
/* sha: f0778e6d53e08a312b8010e4ae0aedf79a5edfbfdac1dcf343af1154f4bac404 */
#if BIND_git_pathspec_match_list_entry_FUNCTION
#define git_pathspec_match_list_entry_REQUIRED_ARGC 2
#define git_pathspec_match_list_entry_OPTIONAL_ARGC 0
/* git_pathspec_match_list_entry
 *
 * Parameters:
 * - m: const git_pathspec_match_list *
 * - pos: size_t
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_pathspec_match_list_entry(mrb_state* mrb, mrb_value self) {
  mrb_value m;
  mrb_int native_pos;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &m, &native_pos);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, m, PathspecMatchList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PathspecMatchList expected");
    return mrb_nil_value();
  }

  /* Unbox param: m */
  const git_pathspec_match_list * native_m = (mrb_nil_p(m) ? NULL : mruby_unbox_git_pathspec_match_list(m));

  /* Invocation */
  const char * native_return_value = git_pathspec_match_list_entry(native_m, native_pos);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_list_entrycount */
/* sha: 9a1c9400b752a1f614104799c72ca48eab7f99cdc156980a17d0bf7534179d00 */
#if BIND_git_pathspec_match_list_entrycount_FUNCTION
#define git_pathspec_match_list_entrycount_REQUIRED_ARGC 1
#define git_pathspec_match_list_entrycount_OPTIONAL_ARGC 0
/* git_pathspec_match_list_entrycount
 *
 * Parameters:
 * - m: const git_pathspec_match_list *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_pathspec_match_list_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value m;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &m);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, m, PathspecMatchList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PathspecMatchList expected");
    return mrb_nil_value();
  }

  /* Unbox param: m */
  const git_pathspec_match_list * native_m = (mrb_nil_p(m) ? NULL : mruby_unbox_git_pathspec_match_list(m));

  /* Invocation */
  size_t native_return_value = git_pathspec_match_list_entrycount(native_m);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_list_failed_entry */
/* sha: b22ddb1f7f2b98e98ff0c4e483365ca60447bff1d9edc4bc6d0f9174a20cf8b6 */
#if BIND_git_pathspec_match_list_failed_entry_FUNCTION
#define git_pathspec_match_list_failed_entry_REQUIRED_ARGC 2
#define git_pathspec_match_list_failed_entry_OPTIONAL_ARGC 0
/* git_pathspec_match_list_failed_entry
 *
 * Parameters:
 * - m: const git_pathspec_match_list *
 * - pos: size_t
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_pathspec_match_list_failed_entry(mrb_state* mrb, mrb_value self) {
  mrb_value m;
  mrb_int native_pos;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &m, &native_pos);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, m, PathspecMatchList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PathspecMatchList expected");
    return mrb_nil_value();
  }

  /* Unbox param: m */
  const git_pathspec_match_list * native_m = (mrb_nil_p(m) ? NULL : mruby_unbox_git_pathspec_match_list(m));

  /* Invocation */
  const char * native_return_value = git_pathspec_match_list_failed_entry(native_m, native_pos);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_list_failed_entrycount */
/* sha: 182266ff44d509afe74eb66b5d4ceb20302faad82592b2c12d16262e2c73f2e5 */
#if BIND_git_pathspec_match_list_failed_entrycount_FUNCTION
#define git_pathspec_match_list_failed_entrycount_REQUIRED_ARGC 1
#define git_pathspec_match_list_failed_entrycount_OPTIONAL_ARGC 0
/* git_pathspec_match_list_failed_entrycount
 *
 * Parameters:
 * - m: const git_pathspec_match_list *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_pathspec_match_list_failed_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value m;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &m);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, m, PathspecMatchList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PathspecMatchList expected");
    return mrb_nil_value();
  }

  /* Unbox param: m */
  const git_pathspec_match_list * native_m = (mrb_nil_p(m) ? NULL : mruby_unbox_git_pathspec_match_list(m));

  /* Invocation */
  size_t native_return_value = git_pathspec_match_list_failed_entrycount(native_m);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_list_free */
/* sha: 9f679386a147294278d80c0855213b49909f48a45ca76c2265d16a446e15ebdd */
#if BIND_git_pathspec_match_list_free_FUNCTION
#define git_pathspec_match_list_free_REQUIRED_ARGC 1
#define git_pathspec_match_list_free_OPTIONAL_ARGC 0
/* git_pathspec_match_list_free
 *
 * Parameters:
 * - m: git_pathspec_match_list *
 * Return Type: void
 */
mrb_value
mrb_Git_git_pathspec_match_list_free(mrb_state* mrb, mrb_value self) {
  mrb_value m;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &m);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, m, PathspecMatchList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PathspecMatchList expected");
    return mrb_nil_value();
  }

  /* Unbox param: m */
  git_pathspec_match_list * native_m = (mrb_nil_p(m) ? NULL : mruby_unbox_git_pathspec_match_list(m));

  /* Invocation */
  git_pathspec_match_list_free(native_m);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_tree */
/* sha: e22691d9569413446bd230096c9efa9efcff5b18b249f3c130b3be568b4cc32b */
#if BIND_git_pathspec_match_tree_FUNCTION
#define git_pathspec_match_tree_REQUIRED_ARGC 3
#define git_pathspec_match_tree_OPTIONAL_ARGC 0
/* git_pathspec_match_tree
 *
 * Parameters:
 * - tree: git_tree *
 * - flags: uint32_t
 * - ps: git_pathspec *
 * Return Type: int
 */
mrb_value
mrb_Git_git_pathspec_match_tree(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_pathspec_match_list * native_out = NULL;
  mrb_value tree;
  mrb_int native_flags;
  mrb_value ps;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &tree, &native_flags, &ps);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ps, Pathspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Pathspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Unbox param: ps */
  git_pathspec * native_ps = (mrb_nil_p(ps) ? NULL : mruby_unbox_git_pathspec(ps));

  /* Invocation */
  int native_return_value = git_pathspec_match_tree(&native_out, native_tree, native_flags, native_ps);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_pathspec_match_list(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_workdir */
/* sha: a54e658b3581af052baa182711ceda6834cebfce712d6e3f615fb904594c2a10 */
#if BIND_git_pathspec_match_workdir_FUNCTION
#define git_pathspec_match_workdir_REQUIRED_ARGC 3
#define git_pathspec_match_workdir_OPTIONAL_ARGC 0
/* git_pathspec_match_workdir
 *
 * Parameters:
 * - repo: git_repository *
 * - flags: uint32_t
 * - ps: git_pathspec *
 * Return Type: int
 */
mrb_value
mrb_Git_git_pathspec_match_workdir(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_pathspec_match_list * native_out = NULL;
  mrb_value repo;
  mrb_int native_flags;
  mrb_value ps;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &repo, &native_flags, &ps);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ps, Pathspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Pathspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: ps */
  git_pathspec * native_ps = (mrb_nil_p(ps) ? NULL : mruby_unbox_git_pathspec(ps));

  /* Invocation */
  int native_return_value = git_pathspec_match_workdir(&native_out, native_repo, native_flags, native_ps);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_pathspec_match_list(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_matches_path */
/* sha: fcca4515b17e47bf6d375d71f785b3227adddf15b57f4269e23401be1e833c37 */
#if BIND_git_pathspec_matches_path_FUNCTION
#define git_pathspec_matches_path_REQUIRED_ARGC 3
#define git_pathspec_matches_path_OPTIONAL_ARGC 0
/* git_pathspec_matches_path
 *
 * Parameters:
 * - ps: const git_pathspec *
 * - flags: uint32_t
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_pathspec_matches_path(mrb_state* mrb, mrb_value self) {
  mrb_value ps;
  mrb_int native_flags;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oiz", &ps, &native_flags, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ps, Pathspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Pathspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: ps */
  const git_pathspec * native_ps = (mrb_nil_p(ps) ? NULL : mruby_unbox_git_pathspec(ps));

  /* Invocation */
  int native_return_value = git_pathspec_matches_path(native_ps, native_flags, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_new */
/* sha: e483a5526d5fd6b46ad3ccc9e7b2bf436b7b588e713fdd41ce9c3cc544142299 */
#if BIND_git_pathspec_new_FUNCTION
#define git_pathspec_new_REQUIRED_ARGC 1
#define git_pathspec_new_OPTIONAL_ARGC 0
/* git_pathspec_new
 *
 * Parameters:
 * - pathspec: const git_strarray *
 * Return Type: int
 */
mrb_value
mrb_Git_git_pathspec_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_pathspec * native_out = NULL;
  mrb_value pathspec;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &pathspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pathspec, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }

  /* Unbox param: pathspec */
  const git_strarray * native_pathspec = (mrb_nil_p(pathspec) ? NULL : mruby_unbox_git_strarray(pathspec));

  /* Invocation */
  int native_return_value = git_pathspec_new(&native_out, native_pathspec);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_pathspec(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_push_init_options */
/* sha: 57ea0e95ac3824f7683007388c9f58abbb3cd10c8d7ee2d75393689c466ea6cb */
#if BIND_git_push_init_options_FUNCTION
#define git_push_init_options_REQUIRED_ARGC 2
#define git_push_init_options_OPTIONAL_ARGC 0
/* git_push_init_options
 *
 * Parameters:
 * - opts: git_push_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_push_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, PushOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PushOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_push_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_push_options(opts));

  /* Invocation */
  int native_return_value = git_push_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_abort */
/* sha: 350c44142a26eee46bef37e875f9ee41903e211b436f8a52f54bdf0d1bdb7d81 */
#if BIND_git_rebase_abort_FUNCTION
#define git_rebase_abort_REQUIRED_ARGC 1
#define git_rebase_abort_OPTIONAL_ARGC 0
/* git_rebase_abort
 *
 * Parameters:
 * - rebase: git_rebase *
 * Return Type: int
 */
mrb_value
mrb_Git_git_rebase_abort(mrb_state* mrb, mrb_value self) {
  mrb_value rebase;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rebase);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Invocation */
  int native_return_value = git_rebase_abort(native_rebase);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_commit */
/* sha: a0645c0f0b19250ec73b183be745a04653848dfd663e2f1d97a4829c8b2fd2d6 */
#if BIND_git_rebase_commit_FUNCTION
#define git_rebase_commit_REQUIRED_ARGC 6
#define git_rebase_commit_OPTIONAL_ARGC 0
/* git_rebase_commit
 *
 * Parameters:
 * - id: git_oid *
 * - rebase: git_rebase *
 * - author: const git_signature *
 * - committer: const git_signature *
 * - message_encoding: const char *
 * - message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_rebase_commit(mrb_state* mrb, mrb_value self) {
  mrb_value id;
  mrb_value rebase;
  mrb_value author;
  mrb_value committer;
  char * native_message_encoding = NULL;
  char * native_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oooozz", &id, &rebase, &author, &committer, &native_message_encoding, &native_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, author, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, committer, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: id */
  git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Unbox param: author */
  const git_signature * native_author = (mrb_nil_p(author) ? NULL : mruby_unbox_git_signature(author));

  /* Unbox param: committer */
  const git_signature * native_committer = (mrb_nil_p(committer) ? NULL : mruby_unbox_git_signature(committer));

  /* Invocation */
  int native_return_value = git_rebase_commit(native_id, native_rebase, native_author, native_committer, native_message_encoding, native_message);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_finish */
/* sha: 3287d7cde84e684175f60452404fafc54faf89899c588adfce5647badfd715fc */
#if BIND_git_rebase_finish_FUNCTION
#define git_rebase_finish_REQUIRED_ARGC 2
#define git_rebase_finish_OPTIONAL_ARGC 0
/* git_rebase_finish
 *
 * Parameters:
 * - rebase: git_rebase *
 * - signature: const git_signature *
 * Return Type: int
 */
mrb_value
mrb_Git_git_rebase_finish(mrb_state* mrb, mrb_value self) {
  mrb_value rebase;
  mrb_value signature;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &rebase, &signature);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, signature, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Unbox param: signature */
  const git_signature * native_signature = (mrb_nil_p(signature) ? NULL : mruby_unbox_git_signature(signature));

  /* Invocation */
  int native_return_value = git_rebase_finish(native_rebase, native_signature);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_free */
/* sha: aac40d5a7b183951a5d66d35a3c197e654487fee9c4995352442bc99cedc5399 */
#if BIND_git_rebase_free_FUNCTION
#define git_rebase_free_REQUIRED_ARGC 1
#define git_rebase_free_OPTIONAL_ARGC 0
/* git_rebase_free
 *
 * Parameters:
 * - rebase: git_rebase *
 * Return Type: void
 */
mrb_value
mrb_Git_git_rebase_free(mrb_state* mrb, mrb_value self) {
  mrb_value rebase;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rebase);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Invocation */
  git_rebase_free(native_rebase);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_init */
/* sha: 4b8d916485451f1c15f6717906886b6ad441454327a58176801db34e57fecab3 */
#if BIND_git_rebase_init_FUNCTION
#define git_rebase_init_REQUIRED_ARGC 5
#define git_rebase_init_OPTIONAL_ARGC 0
/* git_rebase_init
 *
 * Parameters:
 * - repo: git_repository *
 * - branch: const git_annotated_commit *
 * - upstream: const git_annotated_commit *
 * - onto: const git_annotated_commit *
 * - opts: const git_rebase_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_rebase_init(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_rebase * native_out = NULL;
  mrb_value repo;
  mrb_value branch;
  mrb_value upstream;
  mrb_value onto;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooooo", &repo, &branch, &upstream, &onto, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, branch, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, upstream, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, onto, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, RebaseOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RebaseOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: branch */
  const git_annotated_commit * native_branch = (mrb_nil_p(branch) ? NULL : mruby_unbox_git_annotated_commit(branch));

  /* Unbox param: upstream */
  const git_annotated_commit * native_upstream = (mrb_nil_p(upstream) ? NULL : mruby_unbox_git_annotated_commit(upstream));

  /* Unbox param: onto */
  const git_annotated_commit * native_onto = (mrb_nil_p(onto) ? NULL : mruby_unbox_git_annotated_commit(onto));

  /* Unbox param: opts */
  const git_rebase_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_rebase_options(opts));

  /* Invocation */
  int native_return_value = git_rebase_init(&native_out, native_repo, native_branch, native_upstream, native_onto, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_rebase(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_init_options */
/* sha: 5aa4d46ac9c4967a9a55c360be4eed2f514e7856443cb11f1ef840e2fb9e00dd */
#if BIND_git_rebase_init_options_FUNCTION
#define git_rebase_init_options_REQUIRED_ARGC 2
#define git_rebase_init_options_OPTIONAL_ARGC 0
/* git_rebase_init_options
 *
 * Parameters:
 * - opts: git_rebase_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_rebase_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, RebaseOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RebaseOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_rebase_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_rebase_options(opts));

  /* Invocation */
  int native_return_value = git_rebase_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_next */
/* sha: b6dc411e5ed27182c8c9b9e355bb8be987cb5f88207779507a760bb81599535f */
#if BIND_git_rebase_next_FUNCTION
#define git_rebase_next_REQUIRED_ARGC 1
#define git_rebase_next_OPTIONAL_ARGC 0
/* git_rebase_next
 *
 * Parameters:
 * - rebase: git_rebase *
 * Return Type: int
 */
mrb_value
mrb_Git_git_rebase_next(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_rebase_operation * native_operation;
  mrb_value rebase;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rebase);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Invocation */
  int native_return_value = git_rebase_next(&native_operation, native_rebase);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: operation */
  mrb_value operation = mruby_box_git_rebase_operation(mrb, native_operation);

  /* Add out params to results */
  mrb_ary_push(mrb, results, operation);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_open */
/* sha: e297c0bb20b7da2a1b37f849c225084d2d1bf67498000f124d17aafddf73f90e */
#if BIND_git_rebase_open_FUNCTION
#define git_rebase_open_REQUIRED_ARGC 2
#define git_rebase_open_OPTIONAL_ARGC 0
/* git_rebase_open
 *
 * Parameters:
 * - repo: git_repository *
 * - opts: const git_rebase_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_rebase_open(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_rebase * native_out = NULL;
  mrb_value repo;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, RebaseOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RebaseOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: opts */
  const git_rebase_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_rebase_options(opts));

  /* Invocation */
  int native_return_value = git_rebase_open(&native_out, native_repo, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_rebase(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_operation_byindex */
/* sha: ec0fc1bec5d09da32f2b12e0ed5323eb8e0864f17a3afe46ca82e040520c17cc */
#if BIND_git_rebase_operation_byindex_FUNCTION
#define git_rebase_operation_byindex_REQUIRED_ARGC 2
#define git_rebase_operation_byindex_OPTIONAL_ARGC 0
/* git_rebase_operation_byindex
 *
 * Parameters:
 * - rebase: git_rebase *
 * - idx: size_t
 * Return Type: git_rebase_operation *
 */
mrb_value
mrb_Git_git_rebase_operation_byindex(mrb_state* mrb, mrb_value self) {
  mrb_value rebase;
  mrb_int native_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &rebase, &native_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Invocation */
  git_rebase_operation * native_return_value = git_rebase_operation_byindex(native_rebase, native_idx);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_rebase_operation(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_operation_current */
/* sha: cf6162c1a9d45cded86d10b42c7c31b86d61f512f4cd723da45745b58f8dc5ec */
#if BIND_git_rebase_operation_current_FUNCTION
#define git_rebase_operation_current_REQUIRED_ARGC 1
#define git_rebase_operation_current_OPTIONAL_ARGC 0
/* git_rebase_operation_current
 *
 * Parameters:
 * - rebase: git_rebase *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_rebase_operation_current(mrb_state* mrb, mrb_value self) {
  mrb_value rebase;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rebase);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Invocation */
  size_t native_return_value = git_rebase_operation_current(native_rebase);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_operation_entrycount */
/* sha: ffc4e655dee236c79089d4c558577f9e750a3036b39f843b6da671706db6afa1 */
#if BIND_git_rebase_operation_entrycount_FUNCTION
#define git_rebase_operation_entrycount_REQUIRED_ARGC 1
#define git_rebase_operation_entrycount_OPTIONAL_ARGC 0
/* git_rebase_operation_entrycount
 *
 * Parameters:
 * - rebase: git_rebase *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_rebase_operation_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value rebase;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rebase);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Invocation */
  size_t native_return_value = git_rebase_operation_entrycount(native_rebase);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refdb_compress */
/* sha: 2bc7e2a66837e18a1cc346d98a1b3023bb3aec800b644d310c47ec8cb947fdc0 */
#if BIND_git_refdb_compress_FUNCTION
#define git_refdb_compress_REQUIRED_ARGC 1
#define git_refdb_compress_OPTIONAL_ARGC 0
/* git_refdb_compress
 *
 * Parameters:
 * - refdb: git_refdb *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refdb_compress(mrb_state* mrb, mrb_value self) {
  mrb_value refdb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &refdb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refdb, Refdb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refdb expected");
    return mrb_nil_value();
  }

  /* Unbox param: refdb */
  git_refdb * native_refdb = (mrb_nil_p(refdb) ? NULL : mruby_unbox_git_refdb(refdb));

  /* Invocation */
  int native_return_value = git_refdb_compress(native_refdb);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refdb_free */
/* sha: 424a13ce61e049e9664d062b41b3cc9a3bbfefc6d221cb9f279e703e43f84384 */
#if BIND_git_refdb_free_FUNCTION
#define git_refdb_free_REQUIRED_ARGC 1
#define git_refdb_free_OPTIONAL_ARGC 0
/* git_refdb_free
 *
 * Parameters:
 * - refdb: git_refdb *
 * Return Type: void
 */
mrb_value
mrb_Git_git_refdb_free(mrb_state* mrb, mrb_value self) {
  mrb_value refdb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &refdb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refdb, Refdb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refdb expected");
    return mrb_nil_value();
  }

  /* Unbox param: refdb */
  git_refdb * native_refdb = (mrb_nil_p(refdb) ? NULL : mruby_unbox_git_refdb(refdb));

  /* Invocation */
  git_refdb_free(native_refdb);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refdb_new */
/* sha: f902c49a47df7f27f2b44d89c365557c39eed13c0302e83b5857b2b19d99a857 */
#if BIND_git_refdb_new_FUNCTION
#define git_refdb_new_REQUIRED_ARGC 1
#define git_refdb_new_OPTIONAL_ARGC 0
/* git_refdb_new
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refdb_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_refdb * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_refdb_new(&native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_refdb(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refdb_open */
/* sha: d7f5f2b1d0b67297bd77792049aebb4047036ade33111fcc54930881d74d7205 */
#if BIND_git_refdb_open_FUNCTION
#define git_refdb_open_REQUIRED_ARGC 1
#define git_refdb_open_OPTIONAL_ARGC 0
/* git_refdb_open
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refdb_open(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_refdb * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_refdb_open(&native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_refdb(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_cmp */
/* sha: e63d308eab0c43a841065a1475112b654567fdd9ad6ff0450634ec9eb4736892 */
#if BIND_git_reference_cmp_FUNCTION
#define git_reference_cmp_REQUIRED_ARGC 2
#define git_reference_cmp_OPTIONAL_ARGC 0
/* git_reference_cmp
 *
 * Parameters:
 * - ref1: const git_reference *
 * - ref2: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_cmp(mrb_state* mrb, mrb_value self) {
  mrb_value ref1;
  mrb_value ref2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &ref1, &ref2);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref1, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ref2, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref1 */
  const git_reference * native_ref1 = (mrb_nil_p(ref1) ? NULL : mruby_unbox_git_reference(ref1));

  /* Unbox param: ref2 */
  const git_reference * native_ref2 = (mrb_nil_p(ref2) ? NULL : mruby_unbox_git_reference(ref2));

  /* Invocation */
  int native_return_value = git_reference_cmp(native_ref1, native_ref2);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_create */
/* sha: 580e30a00639e1bb568b21bc6d304a0d5199dea3e0d93e3db8175615411807cc */
#if BIND_git_reference_create_FUNCTION
#define git_reference_create_REQUIRED_ARGC 5
#define git_reference_create_OPTIONAL_ARGC 0
/* git_reference_create
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - id: const git_oid *
 * - force: int
 * - log_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_create(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;
  mrb_value id;
  mrb_int native_force;
  char * native_log_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoiz", &repo, &native_name, &id, &native_force, &native_log_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_reference_create(&native_out, native_repo, native_name, native_id, native_force, native_log_message);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_create_matching */
/* sha: fc04248bc8ea60f72fc9c6f327f24904b3b5b488f53ddcfb82d951f09164d9d0 */
#if BIND_git_reference_create_matching_FUNCTION
#define git_reference_create_matching_REQUIRED_ARGC 6
#define git_reference_create_matching_OPTIONAL_ARGC 0
/* git_reference_create_matching
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - id: const git_oid *
 * - force: int
 * - current_id: const git_oid *
 * - log_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_create_matching(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;
  mrb_value id;
  mrb_int native_force;
  mrb_value current_id;
  char * native_log_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoioz", &repo, &native_name, &id, &native_force, &current_id, &native_log_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, current_id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Unbox param: current_id */
  const git_oid * native_current_id = (mrb_nil_p(current_id) ? NULL : mruby_unbox_git_oid(current_id));

  /* Invocation */
  int native_return_value = git_reference_create_matching(&native_out, native_repo, native_name, native_id, native_force, native_current_id, native_log_message);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_delete */
/* sha: 00e6f24bd0ba89db98ba0fcf32f6c023df165e89ec0ff21a0c264a0f7beb2cea */
#if BIND_git_reference_delete_FUNCTION
#define git_reference_delete_REQUIRED_ARGC 1
#define git_reference_delete_OPTIONAL_ARGC 0
/* git_reference_delete
 *
 * Parameters:
 * - ref: git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_delete(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_delete(native_ref);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_dwim */
/* sha: fe68a0c40bdafa4db03214ddbc285fc4935f38d0156f3c2c3563a66df5eecf47 */
#if BIND_git_reference_dwim_FUNCTION
#define git_reference_dwim_REQUIRED_ARGC 2
#define git_reference_dwim_OPTIONAL_ARGC 0
/* git_reference_dwim
 *
 * Parameters:
 * - repo: git_repository *
 * - shorthand: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_dwim(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_shorthand = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_shorthand);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_dwim(&native_out, native_repo, native_shorthand);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_ensure_log */
/* sha: 4f31958e93191483ff4a7a626fb77585843c2044c2e28a3608f5cac3af3537d3 */
#if BIND_git_reference_ensure_log_FUNCTION
#define git_reference_ensure_log_REQUIRED_ARGC 2
#define git_reference_ensure_log_OPTIONAL_ARGC 0
/* git_reference_ensure_log
 *
 * Parameters:
 * - repo: git_repository *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_ensure_log(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_ensure_log(native_repo, native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_foreach */
/* sha: bcb8c89821661aa1cb003a54c6f982fc8d09739debfddb7a53b1f0725344475b */
#if BIND_git_reference_foreach_FUNCTION
#define git_reference_foreach_REQUIRED_ARGC 3
#define git_reference_foreach_OPTIONAL_ARGC 0
/* git_reference_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_reference_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_reference_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_reference_foreach_cb native_callback = TODO_mruby_unbox_git_reference_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_reference_foreach(native_repo, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_foreach_glob */
/* sha: 9206d99bc97c8a91b17a084c1c3d18add9bebc8e3e85e6adfc3902044ba00b87 */
#if BIND_git_reference_foreach_glob_FUNCTION
#define git_reference_foreach_glob_REQUIRED_ARGC 4
#define git_reference_foreach_glob_OPTIONAL_ARGC 0
/* git_reference_foreach_glob
 *
 * Parameters:
 * - repo: git_repository *
 * - glob: const char *
 * - callback: git_reference_foreach_name_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_foreach_glob(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_glob = NULL;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoo", &repo, &native_glob, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_reference_foreach_name_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_reference_foreach_name_cb native_callback = TODO_mruby_unbox_git_reference_foreach_name_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_reference_foreach_glob(native_repo, native_glob, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_foreach_name */
/* sha: f5585486f6262dc8d0adafb13cffca5669e9125591f7bfa10bdb6a85fc4e34f2 */
#if BIND_git_reference_foreach_name_FUNCTION
#define git_reference_foreach_name_REQUIRED_ARGC 3
#define git_reference_foreach_name_OPTIONAL_ARGC 0
/* git_reference_foreach_name
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_reference_foreach_name_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_foreach_name(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_reference_foreach_name_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_reference_foreach_name_cb native_callback = TODO_mruby_unbox_git_reference_foreach_name_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_reference_foreach_name(native_repo, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_free */
/* sha: 128e61c41f7e6e2441092437df966d5ca14cf4488193b34875351861b8ecc1c5 */
#if BIND_git_reference_free_FUNCTION
#define git_reference_free_REQUIRED_ARGC 1
#define git_reference_free_OPTIONAL_ARGC 0
/* git_reference_free
 *
 * Parameters:
 * - ref: git_reference *
 * Return Type: void
 */
mrb_value
mrb_Git_git_reference_free(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  git_reference_free(native_ref);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_has_log */
/* sha: 7f1f483d942bcdf0fad7fb3fef6448a1d0d986a863efdd58ec713cb2dd09bd2e */
#if BIND_git_reference_has_log_FUNCTION
#define git_reference_has_log_REQUIRED_ARGC 2
#define git_reference_has_log_OPTIONAL_ARGC 0
/* git_reference_has_log
 *
 * Parameters:
 * - repo: git_repository *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_has_log(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_has_log(native_repo, native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_is_branch */
/* sha: 4e29d33562e85efca73f5fc08ceddeee57915c3038a373b7831d13ef31926538 */
#if BIND_git_reference_is_branch_FUNCTION
#define git_reference_is_branch_REQUIRED_ARGC 1
#define git_reference_is_branch_OPTIONAL_ARGC 0
/* git_reference_is_branch
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_is_branch(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_is_branch(native_ref);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_is_note */
/* sha: 28ffa9a6674c1085f4a63100d7244e6095c48edf28dc310b577ee4bbb75c36e8 */
#if BIND_git_reference_is_note_FUNCTION
#define git_reference_is_note_REQUIRED_ARGC 1
#define git_reference_is_note_OPTIONAL_ARGC 0
/* git_reference_is_note
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_is_note(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_is_note(native_ref);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_is_remote */
/* sha: a8d0d6b609a15e406393cea8a826a8338c7fb1d754188fd6a83589e8aaa2ce73 */
#if BIND_git_reference_is_remote_FUNCTION
#define git_reference_is_remote_REQUIRED_ARGC 1
#define git_reference_is_remote_OPTIONAL_ARGC 0
/* git_reference_is_remote
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_is_remote(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_is_remote(native_ref);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_is_tag */
/* sha: 6e7381a50200e7aa8f2e5c3d6fb5cf8423bdcac313ca5ab7517579ae8d74c36a */
#if BIND_git_reference_is_tag_FUNCTION
#define git_reference_is_tag_REQUIRED_ARGC 1
#define git_reference_is_tag_OPTIONAL_ARGC 0
/* git_reference_is_tag
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_is_tag(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_is_tag(native_ref);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_is_valid_name */
/* sha: 3d98c0eb2665aa213fd7586eb81d9c9aed9a1c9ed79e0c4dd27ac0d9df47a631 */
#if BIND_git_reference_is_valid_name_FUNCTION
#define git_reference_is_valid_name_REQUIRED_ARGC 1
#define git_reference_is_valid_name_OPTIONAL_ARGC 0
/* git_reference_is_valid_name
 *
 * Parameters:
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_is_valid_name(mrb_state* mrb, mrb_value self) {
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_refname);

  /* Invocation */
  int native_return_value = git_reference_is_valid_name(native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_iterator_free */
/* sha: e285cfa8a59221072819a4d15f1e535d258bebce610cda72fa5131b8c072d089 */
#if BIND_git_reference_iterator_free_FUNCTION
#define git_reference_iterator_free_REQUIRED_ARGC 1
#define git_reference_iterator_free_OPTIONAL_ARGC 0
/* git_reference_iterator_free
 *
 * Parameters:
 * - iter: git_reference_iterator *
 * Return Type: void
 */
mrb_value
mrb_Git_git_reference_iterator_free(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, ReferenceIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ReferenceIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iter */
  git_reference_iterator * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox_git_reference_iterator(iter));

  /* Invocation */
  git_reference_iterator_free(native_iter);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_iterator_glob_new */
/* sha: b72ef748c20eb1661b3da9a0b55eacd834314e1489c0347af98225e7f06844b1 */
#if BIND_git_reference_iterator_glob_new_FUNCTION
#define git_reference_iterator_glob_new_REQUIRED_ARGC 2
#define git_reference_iterator_glob_new_OPTIONAL_ARGC 0
/* git_reference_iterator_glob_new
 *
 * Parameters:
 * - repo: git_repository *
 * - glob: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_iterator_glob_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference_iterator * native_out = NULL;
  mrb_value repo;
  char * native_glob = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_glob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_iterator_glob_new(&native_out, native_repo, native_glob);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference_iterator(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_iterator_new */
/* sha: 2a82d43bd37fbb0adb4a4e1b443d95c842f9984324f178ab5ca1dea4cc17c825 */
#if BIND_git_reference_iterator_new_FUNCTION
#define git_reference_iterator_new_REQUIRED_ARGC 1
#define git_reference_iterator_new_OPTIONAL_ARGC 0
/* git_reference_iterator_new
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_iterator_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference_iterator * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_iterator_new(&native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference_iterator(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_list */
/* sha: e3671c79a7d1a00bd1ba7b8ee456ee8dcc5cabb2a33ff93cea8912280699b86b */
#if BIND_git_reference_list_FUNCTION
#define git_reference_list_REQUIRED_ARGC 2
#define git_reference_list_OPTIONAL_ARGC 0
/* git_reference_list
 *
 * Parameters:
 * - array: git_strarray *
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_list(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &array, &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: array */
  git_strarray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox_git_strarray(array));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_list(native_array, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_lookup */
/* sha: 2d782fd1b269e848cbe504d8ff6b2cb02b1a30a5a497db3609bedbbf6ea806d8 */
#if BIND_git_reference_lookup_FUNCTION
#define git_reference_lookup_REQUIRED_ARGC 2
#define git_reference_lookup_OPTIONAL_ARGC 0
/* git_reference_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_lookup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_lookup(&native_out, native_repo, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_name */
/* sha: 05b295baa93d9545997212f9efb17b82bcb255de62f376cbe12e126864d0e98b */
#if BIND_git_reference_name_FUNCTION
#define git_reference_name_REQUIRED_ARGC 1
#define git_reference_name_OPTIONAL_ARGC 0
/* git_reference_name
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_reference_name(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  const char * native_return_value = git_reference_name(native_ref);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_name_to_id */
/* sha: f23db6dceef79fd13e92152cd2dbe9e4fc1688d7456267fa89e17f83f89c2ff4 */
#if BIND_git_reference_name_to_id_FUNCTION
#define git_reference_name_to_id_REQUIRED_ARGC 3
#define git_reference_name_to_id_OPTIONAL_ARGC 0
/* git_reference_name_to_id
 *
 * Parameters:
 * - out: git_oid *
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_name_to_id(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &out, &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_name_to_id(native_out, native_repo, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_next */
/* sha: db3a0020ff941689dc40109d8513fdc5b2c2ec8087db12331614272a839fe14e */
#if BIND_git_reference_next_FUNCTION
#define git_reference_next_REQUIRED_ARGC 1
#define git_reference_next_OPTIONAL_ARGC 0
/* git_reference_next
 *
 * Parameters:
 * - iter: git_reference_iterator *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_next(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, ReferenceIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ReferenceIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iter */
  git_reference_iterator * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox_git_reference_iterator(iter));

  /* Invocation */
  int native_return_value = git_reference_next(&native_out, native_iter);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_next_name */
/* sha: d1f9c06c7e09f1a760322fa071c195fd028b9884483f399a7272cb5edf5caa71 */
#if BIND_git_reference_next_name_FUNCTION
#define git_reference_next_name_REQUIRED_ARGC 1
#define git_reference_next_name_OPTIONAL_ARGC 0
/* git_reference_next_name
 *
 * Parameters:
 * - iter: git_reference_iterator *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_next_name(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_out = NULL;
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, ReferenceIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ReferenceIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iter */
  git_reference_iterator * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox_git_reference_iterator(iter));

  /* Invocation */
  int native_return_value = git_reference_next_name(&native_out, native_iter);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out ==  NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_normalize_name */
/* sha: d28706211778962ca74f146ee9247a59a759f858e8896520317cfef8652aab6b */
#if BIND_git_reference_normalize_name_FUNCTION
#define git_reference_normalize_name_REQUIRED_ARGC 4
#define git_reference_normalize_name_OPTIONAL_ARGC 0
/* git_reference_normalize_name
 *
 * Parameters:
 * - buffer_out: char *
 * - buffer_size: size_t
 * - name: const char *
 * - flags: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_normalize_name(mrb_state* mrb, mrb_value self) {
  mrb_value buffer_out;
  mrb_int native_buffer_size;
  char * native_name = NULL;
  mrb_int native_flags;

  /* Fetch the args */
  mrb_get_args(mrb, "oizi", &buffer_out, &native_buffer_size, &native_name, &native_flags);

  /* Type checking */
  TODO_type_check_char_PTR(buffer_out);

  /* Unbox param: buffer_out */
  char * native_buffer_out = TODO_mruby_unbox_char_PTR(buffer_out);

  /* Invocation */
  int native_return_value = git_reference_normalize_name(native_buffer_out, native_buffer_size, native_name, native_flags);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_owner */
/* sha: 8bdf2641ad6bef2663a1839f835206cf538dbfdfdc97d415b268519eae38bf9a */
#if BIND_git_reference_owner_FUNCTION
#define git_reference_owner_REQUIRED_ARGC 1
#define git_reference_owner_OPTIONAL_ARGC 0
/* git_reference_owner
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_reference_owner(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  git_repository * native_return_value = git_reference_owner(native_ref);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_peel */
/* sha: 0bfb205f13dfd3172122251a74d14984ca8b3ca887415acd80022b196ba16b85 */
#if BIND_git_reference_peel_FUNCTION
#define git_reference_peel_REQUIRED_ARGC 2
#define git_reference_peel_OPTIONAL_ARGC 0
/* git_reference_peel
 *
 * Parameters:
 * - ref: git_reference *
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_peel(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_object * native_out = NULL;
  mrb_value ref;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &ref, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_peel(&native_out, native_ref, native_type);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_remove */
/* sha: 0972d96e395990cf92ade8a70dcbf60e6e55fc714c6599e1f20e14092e10ccf2 */
#if BIND_git_reference_remove_FUNCTION
#define git_reference_remove_REQUIRED_ARGC 2
#define git_reference_remove_OPTIONAL_ARGC 0
/* git_reference_remove
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_remove(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_remove(native_repo, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_rename */
/* sha: 9f0c922f1e7598ff3fbb501e65e0a00ba6f3c1b9910499eeacbe234df972d239 */
#if BIND_git_reference_rename_FUNCTION
#define git_reference_rename_REQUIRED_ARGC 4
#define git_reference_rename_OPTIONAL_ARGC 0
/* git_reference_rename
 *
 * Parameters:
 * - ref: git_reference *
 * - new_name: const char *
 * - force: int
 * - log_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_rename(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_new_ref = NULL;
  mrb_value ref;
  char * native_new_name = NULL;
  mrb_int native_force;
  char * native_log_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oziz", &ref, &native_new_name, &native_force, &native_log_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_rename(&native_new_ref, native_ref, native_new_name, native_force, native_log_message);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: new_ref */
  mrb_value new_ref = native_new_ref == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_new_ref);

  /* Add out params to results */
  mrb_ary_push(mrb, results, new_ref);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_resolve */
/* sha: b05b360cedbe125b3281995d84af1b1c666e02bf1059fbf4c7c3fbd43adea551 */
#if BIND_git_reference_resolve_FUNCTION
#define git_reference_resolve_REQUIRED_ARGC 1
#define git_reference_resolve_OPTIONAL_ARGC 0
/* git_reference_resolve
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_resolve(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_resolve(&native_out, native_ref);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_set_target */
/* sha: 2b655960b5335149405449133e2b7eacff60677b2f31569ea5c16400365794e0 */
#if BIND_git_reference_set_target_FUNCTION
#define git_reference_set_target_REQUIRED_ARGC 3
#define git_reference_set_target_OPTIONAL_ARGC 0
/* git_reference_set_target
 *
 * Parameters:
 * - ref: git_reference *
 * - id: const git_oid *
 * - log_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_set_target(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  mrb_value ref;
  mrb_value id;
  char * native_log_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &ref, &id, &native_log_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_reference_set_target(&native_out, native_ref, native_id, native_log_message);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_shorthand */
/* sha: ec09b0964ebccf032de7b0f54b18ed0f6d20ee6ba570fe3321682d8c083b235e */
#if BIND_git_reference_shorthand_FUNCTION
#define git_reference_shorthand_REQUIRED_ARGC 1
#define git_reference_shorthand_OPTIONAL_ARGC 0
/* git_reference_shorthand
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_reference_shorthand(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  const char * native_return_value = git_reference_shorthand(native_ref);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_symbolic_create */
/* sha: 284cb1b2435db748d28dfca38bfb884ca17e033aa98dceb7c79b5ddb4eed4d42 */
#if BIND_git_reference_symbolic_create_FUNCTION
#define git_reference_symbolic_create_REQUIRED_ARGC 5
#define git_reference_symbolic_create_OPTIONAL_ARGC 0
/* git_reference_symbolic_create
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - target: const char *
 * - force: int
 * - log_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_symbolic_create(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;
  char * native_target = NULL;
  mrb_int native_force;
  char * native_log_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozziz", &repo, &native_name, &native_target, &native_force, &native_log_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_symbolic_create(&native_out, native_repo, native_name, native_target, native_force, native_log_message);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_symbolic_create_matching */
/* sha: 116885b5010577ccfbf12704ba6fbe3437ce9a8c02d5199e6b77aa0bb0470bd9 */
#if BIND_git_reference_symbolic_create_matching_FUNCTION
#define git_reference_symbolic_create_matching_REQUIRED_ARGC 6
#define git_reference_symbolic_create_matching_OPTIONAL_ARGC 0
/* git_reference_symbolic_create_matching
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - target: const char *
 * - force: int
 * - current_value: const char *
 * - log_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_symbolic_create_matching(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;
  char * native_target = NULL;
  mrb_int native_force;
  char * native_current_value = NULL;
  char * native_log_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzizz", &repo, &native_name, &native_target, &native_force, &native_current_value, &native_log_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_symbolic_create_matching(&native_out, native_repo, native_name, native_target, native_force, native_current_value, native_log_message);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_symbolic_set_target */
/* sha: d35f55ea5eb903c02d94a3eeaf37b12c25e317a1e48379b3d23b345ed1ce6c30 */
#if BIND_git_reference_symbolic_set_target_FUNCTION
#define git_reference_symbolic_set_target_REQUIRED_ARGC 3
#define git_reference_symbolic_set_target_OPTIONAL_ARGC 0
/* git_reference_symbolic_set_target
 *
 * Parameters:
 * - ref: git_reference *
 * - target: const char *
 * - log_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_symbolic_set_target(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  mrb_value ref;
  char * native_target = NULL;
  char * native_log_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &ref, &native_target, &native_log_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_symbolic_set_target(&native_out, native_ref, native_target, native_log_message);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_symbolic_target */
/* sha: 5729e9239b98317e5e490b48450984be82ccc9336204ad066ad33fa810de7a5a */
#if BIND_git_reference_symbolic_target_FUNCTION
#define git_reference_symbolic_target_REQUIRED_ARGC 1
#define git_reference_symbolic_target_OPTIONAL_ARGC 0
/* git_reference_symbolic_target
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_reference_symbolic_target(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  const char * native_return_value = git_reference_symbolic_target(native_ref);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_target */
/* sha: 064292dc06951b25778ce09bcbc25887d365e887c127d89bb86dcf44b68b2571 */
#if BIND_git_reference_target_FUNCTION
#define git_reference_target_REQUIRED_ARGC 1
#define git_reference_target_OPTIONAL_ARGC 0
/* git_reference_target
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_reference_target(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  const git_oid * native_return_value = git_reference_target(native_ref);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_target_peel */
/* sha: 8437bf881541d62a307d06547e44e3405bee86bcf8ffeb01fbf66a9e1acd97f1 */
#if BIND_git_reference_target_peel_FUNCTION
#define git_reference_target_peel_REQUIRED_ARGC 1
#define git_reference_target_peel_OPTIONAL_ARGC 0
/* git_reference_target_peel
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_reference_target_peel(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  const git_oid * native_return_value = git_reference_target_peel(native_ref);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_type */
/* sha: d56db66d0d25b896e5ecb50c97b2eaf52a69d92ae64787fe0df39ffcc43b61e0 */
#if BIND_git_reference_type_FUNCTION
#define git_reference_type_REQUIRED_ARGC 1
#define git_reference_type_OPTIONAL_ARGC 0
/* git_reference_type
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: git_ref_t
 */
mrb_value
mrb_Git_git_reference_type(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  git_ref_t native_return_value = git_reference_type(native_ref);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_append */
/* sha: cb7cde7f23b24300df6da936a57c1cdeb981403a5850feb779c6e5caf7975ebd */
#if BIND_git_reflog_append_FUNCTION
#define git_reflog_append_REQUIRED_ARGC 4
#define git_reflog_append_OPTIONAL_ARGC 0
/* git_reflog_append
 *
 * Parameters:
 * - reflog: git_reflog *
 * - id: const git_oid *
 * - committer: const git_signature *
 * - msg: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reflog_append(mrb_state* mrb, mrb_value self) {
  mrb_value reflog;
  mrb_value id;
  mrb_value committer;
  char * native_msg = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oooz", &reflog, &id, &committer, &native_msg);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, reflog, Reflog_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reflog expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, committer, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: reflog */
  git_reflog * native_reflog = (mrb_nil_p(reflog) ? NULL : mruby_unbox_git_reflog(reflog));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Unbox param: committer */
  const git_signature * native_committer = (mrb_nil_p(committer) ? NULL : mruby_unbox_git_signature(committer));

  /* Invocation */
  int native_return_value = git_reflog_append(native_reflog, native_id, native_committer, native_msg);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_delete */
/* sha: 3f53f946b68436e2a1bb4b02e5d31cc39470a05589e6437a5198ea98424cd440 */
#if BIND_git_reflog_delete_FUNCTION
#define git_reflog_delete_REQUIRED_ARGC 2
#define git_reflog_delete_OPTIONAL_ARGC 0
/* git_reflog_delete
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reflog_delete(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reflog_delete(native_repo, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_drop */
/* sha: bddc8e568dd116d9e09eab4aa9adbc4466ba2d1c24e785c96e317b8943d63bcc */
#if BIND_git_reflog_drop_FUNCTION
#define git_reflog_drop_REQUIRED_ARGC 3
#define git_reflog_drop_OPTIONAL_ARGC 0
/* git_reflog_drop
 *
 * Parameters:
 * - reflog: git_reflog *
 * - idx: size_t
 * - rewrite_previous_entry: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_reflog_drop(mrb_state* mrb, mrb_value self) {
  mrb_value reflog;
  mrb_int native_idx;
  mrb_int native_rewrite_previous_entry;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &reflog, &native_idx, &native_rewrite_previous_entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, reflog, Reflog_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reflog expected");
    return mrb_nil_value();
  }

  /* Unbox param: reflog */
  git_reflog * native_reflog = (mrb_nil_p(reflog) ? NULL : mruby_unbox_git_reflog(reflog));

  /* Invocation */
  int native_return_value = git_reflog_drop(native_reflog, native_idx, native_rewrite_previous_entry);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_entry_byindex */
/* sha: b80377c6dce9ae8f43c7bde448c77a1db0c84b4acfe5cd16763ef6cb3e7aea66 */
#if BIND_git_reflog_entry_byindex_FUNCTION
#define git_reflog_entry_byindex_REQUIRED_ARGC 2
#define git_reflog_entry_byindex_OPTIONAL_ARGC 0
/* git_reflog_entry_byindex
 *
 * Parameters:
 * - reflog: const git_reflog *
 * - idx: size_t
 * Return Type: const git_reflog_entry *
 */
mrb_value
mrb_Git_git_reflog_entry_byindex(mrb_state* mrb, mrb_value self) {
  mrb_value reflog;
  mrb_int native_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &reflog, &native_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, reflog, Reflog_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reflog expected");
    return mrb_nil_value();
  }

  /* Unbox param: reflog */
  const git_reflog * native_reflog = (mrb_nil_p(reflog) ? NULL : mruby_unbox_git_reflog(reflog));

  /* Invocation */
  const git_reflog_entry * native_return_value = git_reflog_entry_byindex(native_reflog, native_idx);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_reflog_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_entry_committer */
/* sha: 30aecfb4911f3a543d642893b0a5abeecc0d35125f6d54b0673c035d6687e3c9 */
#if BIND_git_reflog_entry_committer_FUNCTION
#define git_reflog_entry_committer_REQUIRED_ARGC 1
#define git_reflog_entry_committer_OPTIONAL_ARGC 0
/* git_reflog_entry_committer
 *
 * Parameters:
 * - entry: const git_reflog_entry *
 * Return Type: const git_signature *
 */
mrb_value
mrb_Git_git_reflog_entry_committer(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, ReflogEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ReflogEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_reflog_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_reflog_entry(entry));

  /* Invocation */
  const git_signature * native_return_value = git_reflog_entry_committer(native_entry);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_signature(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_entry_id_new */
/* sha: a15346bdc3926e516d6931003ed649d3c1c03382268037aac9889b71921628d9 */
#if BIND_git_reflog_entry_id_new_FUNCTION
#define git_reflog_entry_id_new_REQUIRED_ARGC 1
#define git_reflog_entry_id_new_OPTIONAL_ARGC 0
/* git_reflog_entry_id_new
 *
 * Parameters:
 * - entry: const git_reflog_entry *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_reflog_entry_id_new(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, ReflogEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ReflogEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_reflog_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_reflog_entry(entry));

  /* Invocation */
  const git_oid * native_return_value = git_reflog_entry_id_new(native_entry);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_entry_id_old */
/* sha: 70b18790d3ad4a58a7195211a29dd3bf96577f701cc97f9cc870e22986412956 */
#if BIND_git_reflog_entry_id_old_FUNCTION
#define git_reflog_entry_id_old_REQUIRED_ARGC 1
#define git_reflog_entry_id_old_OPTIONAL_ARGC 0
/* git_reflog_entry_id_old
 *
 * Parameters:
 * - entry: const git_reflog_entry *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_reflog_entry_id_old(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, ReflogEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ReflogEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_reflog_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_reflog_entry(entry));

  /* Invocation */
  const git_oid * native_return_value = git_reflog_entry_id_old(native_entry);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_entry_message */
/* sha: 2bcd630b9f276097bbb254d8c3ea25e89e90bd3c8ad10d568398329ce62920cb */
#if BIND_git_reflog_entry_message_FUNCTION
#define git_reflog_entry_message_REQUIRED_ARGC 1
#define git_reflog_entry_message_OPTIONAL_ARGC 0
/* git_reflog_entry_message
 *
 * Parameters:
 * - entry: const git_reflog_entry *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_reflog_entry_message(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, ReflogEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ReflogEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_reflog_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_reflog_entry(entry));

  /* Invocation */
  const char * native_return_value = git_reflog_entry_message(native_entry);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_entrycount */
/* sha: 6058f43eb6160fa05195a85ef01b9c13907ace3aa678990855772af1ac7d8c5a */
#if BIND_git_reflog_entrycount_FUNCTION
#define git_reflog_entrycount_REQUIRED_ARGC 1
#define git_reflog_entrycount_OPTIONAL_ARGC 0
/* git_reflog_entrycount
 *
 * Parameters:
 * - reflog: git_reflog *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_reflog_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value reflog;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &reflog);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, reflog, Reflog_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reflog expected");
    return mrb_nil_value();
  }

  /* Unbox param: reflog */
  git_reflog * native_reflog = (mrb_nil_p(reflog) ? NULL : mruby_unbox_git_reflog(reflog));

  /* Invocation */
  size_t native_return_value = git_reflog_entrycount(native_reflog);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_free */
/* sha: 37acbfe82d591233d01e68e3922869ae21a6e94d837e3bf72a1153eb93c87b33 */
#if BIND_git_reflog_free_FUNCTION
#define git_reflog_free_REQUIRED_ARGC 1
#define git_reflog_free_OPTIONAL_ARGC 0
/* git_reflog_free
 *
 * Parameters:
 * - reflog: git_reflog *
 * Return Type: void
 */
mrb_value
mrb_Git_git_reflog_free(mrb_state* mrb, mrb_value self) {
  mrb_value reflog;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &reflog);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, reflog, Reflog_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reflog expected");
    return mrb_nil_value();
  }

  /* Unbox param: reflog */
  git_reflog * native_reflog = (mrb_nil_p(reflog) ? NULL : mruby_unbox_git_reflog(reflog));

  /* Invocation */
  git_reflog_free(native_reflog);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_read */
/* sha: a03006678c799545e850f7bb17a342050ad3d7479691171d3c24f605235ac836 */
#if BIND_git_reflog_read_FUNCTION
#define git_reflog_read_REQUIRED_ARGC 2
#define git_reflog_read_OPTIONAL_ARGC 0
/* git_reflog_read
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reflog_read(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reflog * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reflog_read(&native_out, native_repo, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reflog(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_rename */
/* sha: 481df6067fea432cc5bfd3685baafad39faeb8376993220431c69b27727119b3 */
#if BIND_git_reflog_rename_FUNCTION
#define git_reflog_rename_REQUIRED_ARGC 3
#define git_reflog_rename_OPTIONAL_ARGC 0
/* git_reflog_rename
 *
 * Parameters:
 * - repo: git_repository *
 * - old_name: const char *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reflog_rename(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_old_name = NULL;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_old_name, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reflog_rename(native_repo, native_old_name, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_write */
/* sha: b97939e648ace1857a83be5771c3fd70416ac642fb4247e0d95a9c68607f44fb */
#if BIND_git_reflog_write_FUNCTION
#define git_reflog_write_REQUIRED_ARGC 1
#define git_reflog_write_OPTIONAL_ARGC 0
/* git_reflog_write
 *
 * Parameters:
 * - reflog: git_reflog *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reflog_write(mrb_state* mrb, mrb_value self) {
  mrb_value reflog;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &reflog);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, reflog, Reflog_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reflog expected");
    return mrb_nil_value();
  }

  /* Unbox param: reflog */
  git_reflog * native_reflog = (mrb_nil_p(reflog) ? NULL : mruby_unbox_git_reflog(reflog));

  /* Invocation */
  int native_return_value = git_reflog_write(native_reflog);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_direction */
/* sha: 5c3320d99c939bfb590ea115066a2746bab43083d9b0a232ed112bd57c8569d8 */
#if BIND_git_refspec_direction_FUNCTION
#define git_refspec_direction_REQUIRED_ARGC 1
#define git_refspec_direction_OPTIONAL_ARGC 0
/* git_refspec_direction
 *
 * Parameters:
 * - spec: const git_refspec *
 * Return Type: git_direction
 */
mrb_value
mrb_Git_git_refspec_direction(mrb_state* mrb, mrb_value self) {
  mrb_value spec;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &spec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, spec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: spec */
  const git_refspec * native_spec = (mrb_nil_p(spec) ? NULL : mruby_unbox_git_refspec(spec));

  /* Invocation */
  git_direction native_return_value = git_refspec_direction(native_spec);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_dst */
/* sha: c911c03db0542e9ea2453a371cb288d51f5f84351eb8164aeab954b0dc7ac461 */
#if BIND_git_refspec_dst_FUNCTION
#define git_refspec_dst_REQUIRED_ARGC 1
#define git_refspec_dst_OPTIONAL_ARGC 0
/* git_refspec_dst
 *
 * Parameters:
 * - refspec: const git_refspec *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_refspec_dst(mrb_state* mrb, mrb_value self) {
  mrb_value refspec;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &refspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refspec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: refspec */
  const git_refspec * native_refspec = (mrb_nil_p(refspec) ? NULL : mruby_unbox_git_refspec(refspec));

  /* Invocation */
  const char * native_return_value = git_refspec_dst(native_refspec);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_dst_matches */
/* sha: 1ccf0b0fa9b5572c6e4652f3ccd5250d015c5724f37dd5ab54d961a03cbc40d2 */
#if BIND_git_refspec_dst_matches_FUNCTION
#define git_refspec_dst_matches_REQUIRED_ARGC 2
#define git_refspec_dst_matches_OPTIONAL_ARGC 0
/* git_refspec_dst_matches
 *
 * Parameters:
 * - refspec: const git_refspec *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refspec_dst_matches(mrb_state* mrb, mrb_value self) {
  mrb_value refspec;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &refspec, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refspec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: refspec */
  const git_refspec * native_refspec = (mrb_nil_p(refspec) ? NULL : mruby_unbox_git_refspec(refspec));

  /* Invocation */
  int native_return_value = git_refspec_dst_matches(native_refspec, native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_force */
/* sha: d2255d53e09e888b92b4d0f81a55b8116636f24aa4a9520336c59625e2d2044e */
#if BIND_git_refspec_force_FUNCTION
#define git_refspec_force_REQUIRED_ARGC 1
#define git_refspec_force_OPTIONAL_ARGC 0
/* git_refspec_force
 *
 * Parameters:
 * - refspec: const git_refspec *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refspec_force(mrb_state* mrb, mrb_value self) {
  mrb_value refspec;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &refspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refspec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: refspec */
  const git_refspec * native_refspec = (mrb_nil_p(refspec) ? NULL : mruby_unbox_git_refspec(refspec));

  /* Invocation */
  int native_return_value = git_refspec_force(native_refspec);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_rtransform */
/* sha: 415005c3d715f90b8c2b0ad0739430465b57eec60286eec6d4988c618d5a73da */
#if BIND_git_refspec_rtransform_FUNCTION
#define git_refspec_rtransform_REQUIRED_ARGC 3
#define git_refspec_rtransform_OPTIONAL_ARGC 0
/* git_refspec_rtransform
 *
 * Parameters:
 * - out: git_buf *
 * - spec: const git_refspec *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refspec_rtransform(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value spec;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &out, &spec, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, spec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: spec */
  const git_refspec * native_spec = (mrb_nil_p(spec) ? NULL : mruby_unbox_git_refspec(spec));

  /* Invocation */
  int native_return_value = git_refspec_rtransform(native_out, native_spec, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_src */
/* sha: ab77aaed716f657f8e95ebe98e6cd16fafcaf6d44c77550e4c5af19ddebd576a */
#if BIND_git_refspec_src_FUNCTION
#define git_refspec_src_REQUIRED_ARGC 1
#define git_refspec_src_OPTIONAL_ARGC 0
/* git_refspec_src
 *
 * Parameters:
 * - refspec: const git_refspec *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_refspec_src(mrb_state* mrb, mrb_value self) {
  mrb_value refspec;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &refspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refspec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: refspec */
  const git_refspec * native_refspec = (mrb_nil_p(refspec) ? NULL : mruby_unbox_git_refspec(refspec));

  /* Invocation */
  const char * native_return_value = git_refspec_src(native_refspec);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_src_matches */
/* sha: 1bb192a321fe0c6fc2424a63056b07887a751c7e9d235b0c3fa452d2ad09e540 */
#if BIND_git_refspec_src_matches_FUNCTION
#define git_refspec_src_matches_REQUIRED_ARGC 2
#define git_refspec_src_matches_OPTIONAL_ARGC 0
/* git_refspec_src_matches
 *
 * Parameters:
 * - refspec: const git_refspec *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refspec_src_matches(mrb_state* mrb, mrb_value self) {
  mrb_value refspec;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &refspec, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refspec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: refspec */
  const git_refspec * native_refspec = (mrb_nil_p(refspec) ? NULL : mruby_unbox_git_refspec(refspec));

  /* Invocation */
  int native_return_value = git_refspec_src_matches(native_refspec, native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_string */
/* sha: 420a36f9fe44f661f91ee2eb04c97cc07fe051834a0480b43e0cd9967970a83d */
#if BIND_git_refspec_string_FUNCTION
#define git_refspec_string_REQUIRED_ARGC 1
#define git_refspec_string_OPTIONAL_ARGC 0
/* git_refspec_string
 *
 * Parameters:
 * - refspec: const git_refspec *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_refspec_string(mrb_state* mrb, mrb_value self) {
  mrb_value refspec;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &refspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refspec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: refspec */
  const git_refspec * native_refspec = (mrb_nil_p(refspec) ? NULL : mruby_unbox_git_refspec(refspec));

  /* Invocation */
  const char * native_return_value = git_refspec_string(native_refspec);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_transform */
/* sha: c9d3a3b8a9e94001694e2ccf401bf630855550c7cf842f9a82f40310ba91d797 */
#if BIND_git_refspec_transform_FUNCTION
#define git_refspec_transform_REQUIRED_ARGC 3
#define git_refspec_transform_OPTIONAL_ARGC 0
/* git_refspec_transform
 *
 * Parameters:
 * - out: git_buf *
 * - spec: const git_refspec *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refspec_transform(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value spec;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &out, &spec, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, spec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: spec */
  const git_refspec * native_spec = (mrb_nil_p(spec) ? NULL : mruby_unbox_git_refspec(spec));

  /* Invocation */
  int native_return_value = git_refspec_transform(native_out, native_spec, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_add_fetch */
/* sha: 9e94b97b8919a2a8c793dd508e1f033b8cc62ecabb3987c9b43fe3fb988321f7 */
#if BIND_git_remote_add_fetch_FUNCTION
#define git_remote_add_fetch_REQUIRED_ARGC 3
#define git_remote_add_fetch_OPTIONAL_ARGC 0
/* git_remote_add_fetch
 *
 * Parameters:
 * - repo: git_repository *
 * - remote: const char *
 * - refspec: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_add_fetch(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_remote = NULL;
  char * native_refspec = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_remote, &native_refspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_add_fetch(native_repo, native_remote, native_refspec);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_add_push */
/* sha: 26efb1a06412ed35a41180ae0ead91617f06aea6dfa732831ff47de28c936d20 */
#if BIND_git_remote_add_push_FUNCTION
#define git_remote_add_push_REQUIRED_ARGC 3
#define git_remote_add_push_OPTIONAL_ARGC 0
/* git_remote_add_push
 *
 * Parameters:
 * - repo: git_repository *
 * - remote: const char *
 * - refspec: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_add_push(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_remote = NULL;
  char * native_refspec = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_remote, &native_refspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_add_push(native_repo, native_remote, native_refspec);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_autotag */
/* sha: bbd8c5cbd61532e3ed6f634920e28a25daa42a761bbc31f3282ec45bbc07b57f */
#if BIND_git_remote_autotag_FUNCTION
#define git_remote_autotag_REQUIRED_ARGC 1
#define git_remote_autotag_OPTIONAL_ARGC 0
/* git_remote_autotag
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: git_remote_autotag_option_t
 */
mrb_value
mrb_Git_git_remote_autotag(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  git_remote_autotag_option_t native_return_value = git_remote_autotag(native_remote);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_connect */
/* sha: 7e2071f5e1ec6a755a9a49d7340d82e4698382fdaeb16cc98d981fa74647d3cd */
#if BIND_git_remote_connect_FUNCTION
#define git_remote_connect_REQUIRED_ARGC 4
#define git_remote_connect_OPTIONAL_ARGC 0
/* git_remote_connect
 *
 * Parameters:
 * - remote: git_remote *
 * - direction: git_direction
 * - callbacks: const git_remote_callbacks *
 * - custom_headers: const git_strarray *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_connect(mrb_state* mrb, mrb_value self) {
  mrb_value remote;
  mrb_int native_direction;
  mrb_value callbacks;
  mrb_value custom_headers;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &remote, &native_direction, &callbacks, &custom_headers);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, callbacks, RemoteCallbacks_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RemoteCallbacks expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, custom_headers, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Unbox param: callbacks */
  const git_remote_callbacks * native_callbacks = (mrb_nil_p(callbacks) ? NULL : mruby_unbox_git_remote_callbacks(callbacks));

  /* Unbox param: custom_headers */
  const git_strarray * native_custom_headers = (mrb_nil_p(custom_headers) ? NULL : mruby_unbox_git_strarray(custom_headers));

  /* Invocation */
  int native_return_value = git_remote_connect(native_remote, native_direction, native_callbacks, native_custom_headers);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_connected */
/* sha: 8b731bf6577e71144433dfa8d93ffffba16e83504f5768323872464081e7874e */
#if BIND_git_remote_connected_FUNCTION
#define git_remote_connected_REQUIRED_ARGC 1
#define git_remote_connected_OPTIONAL_ARGC 0
/* git_remote_connected
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_connected(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  int native_return_value = git_remote_connected(native_remote);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_create */
/* sha: 8ffb0fa48d96469dc9089832b33ce6277d37dc1a9beee23dacbfbc5687a36875 */
#if BIND_git_remote_create_FUNCTION
#define git_remote_create_REQUIRED_ARGC 3
#define git_remote_create_OPTIONAL_ARGC 0
/* git_remote_create
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - url: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_create(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_remote * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;
  char * native_url = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_name, &native_url);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_create(&native_out, native_repo, native_name, native_url);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_remote(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_create_anonymous */
/* sha: f549a1741cf7207385019650c0106b1adb516d0c2b4711413b561037eaff9c65 */
#if BIND_git_remote_create_anonymous_FUNCTION
#define git_remote_create_anonymous_REQUIRED_ARGC 2
#define git_remote_create_anonymous_OPTIONAL_ARGC 0
/* git_remote_create_anonymous
 *
 * Parameters:
 * - repo: git_repository *
 * - url: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_create_anonymous(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_remote * native_out = NULL;
  mrb_value repo;
  char * native_url = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_url);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_create_anonymous(&native_out, native_repo, native_url);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_remote(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_create_with_fetchspec */
/* sha: 3787a1caab5585a66dcc3d559f4ebba9a85c778450c7a88745a39fa3242d63fe */
#if BIND_git_remote_create_with_fetchspec_FUNCTION
#define git_remote_create_with_fetchspec_REQUIRED_ARGC 4
#define git_remote_create_with_fetchspec_OPTIONAL_ARGC 0
/* git_remote_create_with_fetchspec
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - url: const char *
 * - fetch: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_create_with_fetchspec(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_remote * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;
  char * native_url = NULL;
  char * native_fetch = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzz", &repo, &native_name, &native_url, &native_fetch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_create_with_fetchspec(&native_out, native_repo, native_name, native_url, native_fetch);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_remote(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_default_branch */
/* sha: ac02fd2539821ba7b1c7a841c4a92be1b9053959386472b81aa5d60d4366648d */
#if BIND_git_remote_default_branch_FUNCTION
#define git_remote_default_branch_REQUIRED_ARGC 2
#define git_remote_default_branch_OPTIONAL_ARGC 0
/* git_remote_default_branch
 *
 * Parameters:
 * - out: git_buf *
 * - remote: git_remote *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_default_branch(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  int native_return_value = git_remote_default_branch(native_out, native_remote);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_delete */
/* sha: dc107d9004e73c6840387e5a6d72ea97c54f79664669668324fb0cb99e1c099c */
#if BIND_git_remote_delete_FUNCTION
#define git_remote_delete_REQUIRED_ARGC 2
#define git_remote_delete_OPTIONAL_ARGC 0
/* git_remote_delete
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_delete(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_delete(native_repo, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_disconnect */
/* sha: 58f2c5af0ca974bf027ddb52549fea5f57f5b32bf401e9ebce2721a7d674b3a9 */
#if BIND_git_remote_disconnect_FUNCTION
#define git_remote_disconnect_REQUIRED_ARGC 1
#define git_remote_disconnect_OPTIONAL_ARGC 0
/* git_remote_disconnect
 *
 * Parameters:
 * - remote: git_remote *
 * Return Type: void
 */
mrb_value
mrb_Git_git_remote_disconnect(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  git_remote_disconnect(native_remote);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_download */
/* sha: 31008e228d24a7d4e2868bb2cc90a92085ec150a6e16e4e13380fcd2afd457e9 */
#if BIND_git_remote_download_FUNCTION
#define git_remote_download_REQUIRED_ARGC 3
#define git_remote_download_OPTIONAL_ARGC 0
/* git_remote_download
 *
 * Parameters:
 * - remote: git_remote *
 * - refspecs: const git_strarray *
 * - opts: const git_fetch_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_download(mrb_state* mrb, mrb_value self) {
  mrb_value remote;
  mrb_value refspecs;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &remote, &refspecs, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, refspecs, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, FetchOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FetchOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Unbox param: refspecs */
  const git_strarray * native_refspecs = (mrb_nil_p(refspecs) ? NULL : mruby_unbox_git_strarray(refspecs));

  /* Unbox param: opts */
  const git_fetch_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_fetch_options(opts));

  /* Invocation */
  int native_return_value = git_remote_download(native_remote, native_refspecs, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_dup */
/* sha: 1e8b91351cb8a90c774d006e85228f661227df426ab90b040b62ad9fd2b85579 */
#if BIND_git_remote_dup_FUNCTION
#define git_remote_dup_REQUIRED_ARGC 1
#define git_remote_dup_OPTIONAL_ARGC 0
/* git_remote_dup
 *
 * Parameters:
 * - source: git_remote *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_dup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_remote * native_dest = NULL;
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: source */
  git_remote * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox_git_remote(source));

  /* Invocation */
  int native_return_value = git_remote_dup(&native_dest, native_source);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: dest */
  mrb_value dest = native_dest == NULL ? mrb_nil_value() : mruby_giftwrap_git_remote(mrb, native_dest);

  /* Add out params to results */
  mrb_ary_push(mrb, results, dest);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_fetch */
/* sha: bc858a546b62acee7d26d3817b064ed8418e958b58bc87e18df00d1f63f7f52e */
#if BIND_git_remote_fetch_FUNCTION
#define git_remote_fetch_REQUIRED_ARGC 4
#define git_remote_fetch_OPTIONAL_ARGC 0
/* git_remote_fetch
 *
 * Parameters:
 * - remote: git_remote *
 * - refspecs: const git_strarray *
 * - opts: const git_fetch_options *
 * - reflog_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_fetch(mrb_state* mrb, mrb_value self) {
  mrb_value remote;
  mrb_value refspecs;
  mrb_value opts;
  char * native_reflog_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oooz", &remote, &refspecs, &opts, &native_reflog_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, refspecs, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, FetchOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FetchOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Unbox param: refspecs */
  const git_strarray * native_refspecs = (mrb_nil_p(refspecs) ? NULL : mruby_unbox_git_strarray(refspecs));

  /* Unbox param: opts */
  const git_fetch_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_fetch_options(opts));

  /* Invocation */
  int native_return_value = git_remote_fetch(native_remote, native_refspecs, native_opts, native_reflog_message);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_free */
/* sha: dfbbe4198662f3dc3d15f38a81c477fb4310c7e35202143626cb34b40ab8c026 */
#if BIND_git_remote_free_FUNCTION
#define git_remote_free_REQUIRED_ARGC 1
#define git_remote_free_OPTIONAL_ARGC 0
/* git_remote_free
 *
 * Parameters:
 * - remote: git_remote *
 * Return Type: void
 */
mrb_value
mrb_Git_git_remote_free(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  git_remote_free(native_remote);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_get_fetch_refspecs */
/* sha: 31390d214a82e602cba336af9856975b5206f342f5881eb3658a5b9bc89979c7 */
#if BIND_git_remote_get_fetch_refspecs_FUNCTION
#define git_remote_get_fetch_refspecs_REQUIRED_ARGC 2
#define git_remote_get_fetch_refspecs_OPTIONAL_ARGC 0
/* git_remote_get_fetch_refspecs
 *
 * Parameters:
 * - array: git_strarray *
 * - remote: const git_remote *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_get_fetch_refspecs(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &array, &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: array */
  git_strarray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox_git_strarray(array));

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  int native_return_value = git_remote_get_fetch_refspecs(native_array, native_remote);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_get_push_refspecs */
/* sha: 689287b3b8e02fd9690069a7337f8de348a4d901ce30225c8cb3d5d94218694c */
#if BIND_git_remote_get_push_refspecs_FUNCTION
#define git_remote_get_push_refspecs_REQUIRED_ARGC 2
#define git_remote_get_push_refspecs_OPTIONAL_ARGC 0
/* git_remote_get_push_refspecs
 *
 * Parameters:
 * - array: git_strarray *
 * - remote: const git_remote *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_get_push_refspecs(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &array, &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: array */
  git_strarray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox_git_strarray(array));

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  int native_return_value = git_remote_get_push_refspecs(native_array, native_remote);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_get_refspec */
/* sha: 02af21ea779549dae73de93bcd8e4a1ffa887ace6afca0faac0240fc511b73e8 */
#if BIND_git_remote_get_refspec_FUNCTION
#define git_remote_get_refspec_REQUIRED_ARGC 2
#define git_remote_get_refspec_OPTIONAL_ARGC 0
/* git_remote_get_refspec
 *
 * Parameters:
 * - remote: const git_remote *
 * - n: size_t
 * Return Type: const git_refspec *
 */
mrb_value
mrb_Git_git_remote_get_refspec(mrb_state* mrb, mrb_value self) {
  mrb_value remote;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &remote, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  const git_refspec * native_return_value = git_remote_get_refspec(native_remote, native_n);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_refspec(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_init_callbacks */
/* sha: 98064bf4b098d7cd2a894f68f572dffd0d307dc43a62414758f96d688c9d648b */
#if BIND_git_remote_init_callbacks_FUNCTION
#define git_remote_init_callbacks_REQUIRED_ARGC 2
#define git_remote_init_callbacks_OPTIONAL_ARGC 0
/* git_remote_init_callbacks
 *
 * Parameters:
 * - opts: git_remote_callbacks *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_init_callbacks(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, RemoteCallbacks_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RemoteCallbacks expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_remote_callbacks * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_remote_callbacks(opts));

  /* Invocation */
  int native_return_value = git_remote_init_callbacks(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_is_valid_name */
/* sha: 83f718e7ff7ebc3b0f467b02f528fa5b2b7cf4f7da72aaccda20202097b6d932 */
#if BIND_git_remote_is_valid_name_FUNCTION
#define git_remote_is_valid_name_REQUIRED_ARGC 1
#define git_remote_is_valid_name_OPTIONAL_ARGC 0
/* git_remote_is_valid_name
 *
 * Parameters:
 * - remote_name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_is_valid_name(mrb_state* mrb, mrb_value self) {
  char * native_remote_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_remote_name);

  /* Invocation */
  int native_return_value = git_remote_is_valid_name(native_remote_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_list */
/* sha: dddec647535287d4df53ee1c096a4fc0c48075216a597725b61a9be27139d5df */
#if BIND_git_remote_list_FUNCTION
#define git_remote_list_REQUIRED_ARGC 2
#define git_remote_list_OPTIONAL_ARGC 0
/* git_remote_list
 *
 * Parameters:
 * - out: git_strarray *
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_list(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_strarray * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_strarray(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_list(native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_lookup */
/* sha: 30af9fbf9fedcf9bfc23594b8996c1f3918c0b61cfcfb60553acbf6d1af035c9 */
#if BIND_git_remote_lookup_FUNCTION
#define git_remote_lookup_REQUIRED_ARGC 2
#define git_remote_lookup_OPTIONAL_ARGC 0
/* git_remote_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_lookup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_remote * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_lookup(&native_out, native_repo, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_remote(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_ls */
/* sha: 62733d73837baa30ae06276742da63a5f0a49b739d2c6be00ee0585b30b49a23 */
#if BIND_git_remote_ls_FUNCTION
#define git_remote_ls_REQUIRED_ARGC 2
#define git_remote_ls_OPTIONAL_ARGC 0
/* git_remote_ls
 *
 * Parameters:
 * - out: const git_remote_head ***
 * - remote: git_remote *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_ls(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value out;
  int native_size;
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &remote);

  /* Type checking */
  TODO_type_check_git_remote_head_PTR_PTR_PTR(out);
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  const git_remote_head *** native_out = TODO_mruby_unbox_git_remote_head_PTR_PTR_PTR(out);

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  int native_return_value = git_remote_ls(native_out, &native_size, native_remote);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: size */
  mrb_value size = mrb_fixnum_value(native_size);

  /* Add out params to results */
  mrb_ary_push(mrb, results, size);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_name */
/* sha: d77c09691cfed316276d3bde473c2da5b3030a0315913de7c91d4cd9fade2d35 */
#if BIND_git_remote_name_FUNCTION
#define git_remote_name_REQUIRED_ARGC 1
#define git_remote_name_OPTIONAL_ARGC 0
/* git_remote_name
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_remote_name(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  const char * native_return_value = git_remote_name(native_remote);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_owner */
/* sha: da6aa02801b5718200b6d3c3277931c96671ac4e249f43a6e10895b79043f24d */
#if BIND_git_remote_owner_FUNCTION
#define git_remote_owner_REQUIRED_ARGC 1
#define git_remote_owner_OPTIONAL_ARGC 0
/* git_remote_owner
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_remote_owner(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  git_repository * native_return_value = git_remote_owner(native_remote);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_prune */
/* sha: 99ba3fe0648ade7d0e752f67d45cdd0da1aaae5b5dbaea98f8f901b13d62a633 */
#if BIND_git_remote_prune_FUNCTION
#define git_remote_prune_REQUIRED_ARGC 2
#define git_remote_prune_OPTIONAL_ARGC 0
/* git_remote_prune
 *
 * Parameters:
 * - remote: git_remote *
 * - callbacks: const git_remote_callbacks *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_prune(mrb_state* mrb, mrb_value self) {
  mrb_value remote;
  mrb_value callbacks;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &remote, &callbacks);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, callbacks, RemoteCallbacks_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RemoteCallbacks expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Unbox param: callbacks */
  const git_remote_callbacks * native_callbacks = (mrb_nil_p(callbacks) ? NULL : mruby_unbox_git_remote_callbacks(callbacks));

  /* Invocation */
  int native_return_value = git_remote_prune(native_remote, native_callbacks);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_prune_refs */
/* sha: 65116335714650e85bd450f369944d170238682d29cf136a799394349330e943 */
#if BIND_git_remote_prune_refs_FUNCTION
#define git_remote_prune_refs_REQUIRED_ARGC 1
#define git_remote_prune_refs_OPTIONAL_ARGC 0
/* git_remote_prune_refs
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_prune_refs(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  int native_return_value = git_remote_prune_refs(native_remote);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_push */
/* sha: a826d23eeeea0f0ffabb0fefdffaac82fdecb9ad812bf392908cbd1b36d2cd8f */
#if BIND_git_remote_push_FUNCTION
#define git_remote_push_REQUIRED_ARGC 3
#define git_remote_push_OPTIONAL_ARGC 0
/* git_remote_push
 *
 * Parameters:
 * - remote: git_remote *
 * - refspecs: const git_strarray *
 * - opts: const git_push_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_push(mrb_state* mrb, mrb_value self) {
  mrb_value remote;
  mrb_value refspecs;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &remote, &refspecs, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, refspecs, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, PushOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PushOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Unbox param: refspecs */
  const git_strarray * native_refspecs = (mrb_nil_p(refspecs) ? NULL : mruby_unbox_git_strarray(refspecs));

  /* Unbox param: opts */
  const git_push_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_push_options(opts));

  /* Invocation */
  int native_return_value = git_remote_push(native_remote, native_refspecs, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_pushurl */
/* sha: 4b52e0b378b8c44fe39be1c0456e991e11edcde8cc63767444ecb64183bdb602 */
#if BIND_git_remote_pushurl_FUNCTION
#define git_remote_pushurl_REQUIRED_ARGC 1
#define git_remote_pushurl_OPTIONAL_ARGC 0
/* git_remote_pushurl
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_remote_pushurl(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  const char * native_return_value = git_remote_pushurl(native_remote);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_refspec_count */
/* sha: 518506c97e0971614d325ae406a78e55a1b9fb4bb96be9a1b1a462f9ae920542 */
#if BIND_git_remote_refspec_count_FUNCTION
#define git_remote_refspec_count_REQUIRED_ARGC 1
#define git_remote_refspec_count_OPTIONAL_ARGC 0
/* git_remote_refspec_count
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_remote_refspec_count(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  size_t native_return_value = git_remote_refspec_count(native_remote);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_rename */
/* sha: d6331ca269844a08353fb37b6b8b69f9decc11f1e5b6f7c87665ba36123c2f7a */
#if BIND_git_remote_rename_FUNCTION
#define git_remote_rename_REQUIRED_ARGC 4
#define git_remote_rename_OPTIONAL_ARGC 0
/* git_remote_rename
 *
 * Parameters:
 * - problems: git_strarray *
 * - repo: git_repository *
 * - name: const char *
 * - new_name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_rename(mrb_state* mrb, mrb_value self) {
  mrb_value problems;
  mrb_value repo;
  char * native_name = NULL;
  char * native_new_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oozz", &problems, &repo, &native_name, &native_new_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, problems, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: problems */
  git_strarray * native_problems = (mrb_nil_p(problems) ? NULL : mruby_unbox_git_strarray(problems));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_rename(native_problems, native_repo, native_name, native_new_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_set_autotag */
/* sha: 8b0604c6a0d6bb960285d8326d6777feb053171ba78d7baf6e5598285eb8e921 */
#if BIND_git_remote_set_autotag_FUNCTION
#define git_remote_set_autotag_REQUIRED_ARGC 3
#define git_remote_set_autotag_OPTIONAL_ARGC 0
/* git_remote_set_autotag
 *
 * Parameters:
 * - repo: git_repository *
 * - remote: const char *
 * - value: git_remote_autotag_option_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_set_autotag(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_remote = NULL;
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &repo, &native_remote, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_set_autotag(native_repo, native_remote, native_value);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_set_pushurl */
/* sha: c17216a74a792586f69c2dc3a1772dbd908a4bbc71979ad58455419853a0dfdc */
#if BIND_git_remote_set_pushurl_FUNCTION
#define git_remote_set_pushurl_REQUIRED_ARGC 3
#define git_remote_set_pushurl_OPTIONAL_ARGC 0
/* git_remote_set_pushurl
 *
 * Parameters:
 * - repo: git_repository *
 * - remote: const char *
 * - url: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_set_pushurl(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_remote = NULL;
  char * native_url = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_remote, &native_url);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_set_pushurl(native_repo, native_remote, native_url);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_set_url */
/* sha: 480dc3bb0bd2302a5e32efd3ecac123110ff5b1356cfbb4ba81e10174fbbacbb */
#if BIND_git_remote_set_url_FUNCTION
#define git_remote_set_url_REQUIRED_ARGC 3
#define git_remote_set_url_OPTIONAL_ARGC 0
/* git_remote_set_url
 *
 * Parameters:
 * - repo: git_repository *
 * - remote: const char *
 * - url: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_set_url(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_remote = NULL;
  char * native_url = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_remote, &native_url);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_set_url(native_repo, native_remote, native_url);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_stats */
/* sha: b5bdf9dc2c97b5a86a5411694dd0422d350b900546de391dc360442fe35c8a70 */
#if BIND_git_remote_stats_FUNCTION
#define git_remote_stats_REQUIRED_ARGC 1
#define git_remote_stats_OPTIONAL_ARGC 0
/* git_remote_stats
 *
 * Parameters:
 * - remote: git_remote *
 * Return Type: const git_transfer_progress *
 */
mrb_value
mrb_Git_git_remote_stats(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  const git_transfer_progress * native_return_value = git_remote_stats(native_remote);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_transfer_progress(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_stop */
/* sha: 635ac15a912f4c25b60879e1ebddc5ffcf5bf4b6e5fcdd2a8d415109fde804b7 */
#if BIND_git_remote_stop_FUNCTION
#define git_remote_stop_REQUIRED_ARGC 1
#define git_remote_stop_OPTIONAL_ARGC 0
/* git_remote_stop
 *
 * Parameters:
 * - remote: git_remote *
 * Return Type: void
 */
mrb_value
mrb_Git_git_remote_stop(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  git_remote_stop(native_remote);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_update_tips */
/* sha: 3829f350ac4bc835a60961a022f17093fdd7452e9c90baac9a20d69bc132142f */
#if BIND_git_remote_update_tips_FUNCTION
#define git_remote_update_tips_REQUIRED_ARGC 5
#define git_remote_update_tips_OPTIONAL_ARGC 0
/* git_remote_update_tips
 *
 * Parameters:
 * - remote: git_remote *
 * - callbacks: const git_remote_callbacks *
 * - update_fetchhead: int
 * - download_tags: git_remote_autotag_option_t
 * - reflog_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_update_tips(mrb_state* mrb, mrb_value self) {
  mrb_value remote;
  mrb_value callbacks;
  mrb_int native_update_fetchhead;
  mrb_int native_download_tags;
  char * native_reflog_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooiiz", &remote, &callbacks, &native_update_fetchhead, &native_download_tags, &native_reflog_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, callbacks, RemoteCallbacks_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RemoteCallbacks expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Unbox param: callbacks */
  const git_remote_callbacks * native_callbacks = (mrb_nil_p(callbacks) ? NULL : mruby_unbox_git_remote_callbacks(callbacks));

  /* Invocation */
  int native_return_value = git_remote_update_tips(native_remote, native_callbacks, native_update_fetchhead, native_download_tags, native_reflog_message);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_upload */
/* sha: 64a74db51b22adf155458257ac8b04f2cb09a200c234b6770e59a878045fe7e6 */
#if BIND_git_remote_upload_FUNCTION
#define git_remote_upload_REQUIRED_ARGC 3
#define git_remote_upload_OPTIONAL_ARGC 0
/* git_remote_upload
 *
 * Parameters:
 * - remote: git_remote *
 * - refspecs: const git_strarray *
 * - opts: const git_push_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_upload(mrb_state* mrb, mrb_value self) {
  mrb_value remote;
  mrb_value refspecs;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &remote, &refspecs, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, refspecs, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, PushOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PushOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Unbox param: refspecs */
  const git_strarray * native_refspecs = (mrb_nil_p(refspecs) ? NULL : mruby_unbox_git_strarray(refspecs));

  /* Unbox param: opts */
  const git_push_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_push_options(opts));

  /* Invocation */
  int native_return_value = git_remote_upload(native_remote, native_refspecs, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_url */
/* sha: b41eea3d5b787b6cc32d6a360d8248d4e1171ac054af5bfc06b2b800fc7f5564 */
#if BIND_git_remote_url_FUNCTION
#define git_remote_url_REQUIRED_ARGC 1
#define git_remote_url_OPTIONAL_ARGC 0
/* git_remote_url
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_remote_url(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  const char * native_return_value = git_remote_url(native_remote);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_config */
/* sha: 6a0a287ce8f53ab035cb3c8c15e72ec0fbc7fd72e4ec7e005a7488cee9fd4f3d */
#if BIND_git_repository_config_FUNCTION
#define git_repository_config_REQUIRED_ARGC 1
#define git_repository_config_OPTIONAL_ARGC 0
/* git_repository_config
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_config(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_config * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_config(&native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_config_snapshot */
/* sha: 6ea7536ffe97a82fd5554f0954ebc7a9d3ee984a6a218ecad7cfadb3a046825d */
#if BIND_git_repository_config_snapshot_FUNCTION
#define git_repository_config_snapshot_REQUIRED_ARGC 1
#define git_repository_config_snapshot_OPTIONAL_ARGC 0
/* git_repository_config_snapshot
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_config_snapshot(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_config * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_config_snapshot(&native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_detach_head */
/* sha: d93ad5ca2432b89decda1227baa41c2d0bafafaf50d809dde9536f714afb959d */
#if BIND_git_repository_detach_head_FUNCTION
#define git_repository_detach_head_REQUIRED_ARGC 1
#define git_repository_detach_head_OPTIONAL_ARGC 0
/* git_repository_detach_head
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_detach_head(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_detach_head(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_discover */
/* sha: 5afc30a71ae235920b54303dc2a1972c35164ff6fc2257a09b40aa7f70b030ad */
#if BIND_git_repository_discover_FUNCTION
#define git_repository_discover_REQUIRED_ARGC 4
#define git_repository_discover_OPTIONAL_ARGC 0
/* git_repository_discover
 *
 * Parameters:
 * - out: git_buf *
 * - start_path: const char *
 * - across_fs: int
 * - ceiling_dirs: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_discover(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  char * native_start_path = NULL;
  mrb_int native_across_fs;
  char * native_ceiling_dirs = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oziz", &out, &native_start_path, &native_across_fs, &native_ceiling_dirs);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Invocation */
  int native_return_value = git_repository_discover(native_out, native_start_path, native_across_fs, native_ceiling_dirs);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_fetchhead_foreach */
/* sha: 8573705d3e59039113f0cea1a3a4336e0577a65d273b3ddbe77ca4be65cf805f */
#if BIND_git_repository_fetchhead_foreach_FUNCTION
#define git_repository_fetchhead_foreach_REQUIRED_ARGC 3
#define git_repository_fetchhead_foreach_OPTIONAL_ARGC 0
/* git_repository_fetchhead_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_repository_fetchhead_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_fetchhead_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_repository_fetchhead_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_repository_fetchhead_foreach_cb native_callback = TODO_mruby_unbox_git_repository_fetchhead_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_repository_fetchhead_foreach(native_repo, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_free */
/* sha: 0b9e2daeeb2f198f45486ad4b9c0c5e7193e8a10a8227930403b06147e3732b6 */
#if BIND_git_repository_free_FUNCTION
#define git_repository_free_REQUIRED_ARGC 1
#define git_repository_free_OPTIONAL_ARGC 0
/* git_repository_free
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: void
 */
mrb_value
mrb_Git_git_repository_free(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  git_repository_free(native_repo);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_get_namespace */
/* sha: d83bd5e8f93eab4b5a5dfefbe55140b8fc7f6775eac6a89c8e30da1a481f3460 */
#if BIND_git_repository_get_namespace_FUNCTION
#define git_repository_get_namespace_REQUIRED_ARGC 1
#define git_repository_get_namespace_OPTIONAL_ARGC 0
/* git_repository_get_namespace
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_repository_get_namespace(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  const char * native_return_value = git_repository_get_namespace(native_repo);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_hashfile */
/* sha: 853dae3f63eba88e8a70ae4301efdba9c1d69077581ece725c9ceb12c1d2ac4d */
#if BIND_git_repository_hashfile_FUNCTION
#define git_repository_hashfile_REQUIRED_ARGC 5
#define git_repository_hashfile_OPTIONAL_ARGC 0
/* git_repository_hashfile
 *
 * Parameters:
 * - out: git_oid *
 * - repo: git_repository *
 * - path: const char *
 * - type: git_otype
 * - as_path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_hashfile(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;
  char * native_path = NULL;
  mrb_int native_type;
  char * native_as_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooziz", &out, &repo, &native_path, &native_type, &native_as_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_hashfile(native_out, native_repo, native_path, native_type, native_as_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_head */
/* sha: 84e0d0107e8a3e77fba3038fb0007735f04a215b43d4b808a12c65ec277fcdbc */
#if BIND_git_repository_head_FUNCTION
#define git_repository_head_REQUIRED_ARGC 1
#define git_repository_head_OPTIONAL_ARGC 0
/* git_repository_head
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_head(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_head(&native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_head_detached */
/* sha: 6ae878c02dde0ee69724fcb0e369472c3eb5856bcf0373c6df09607db4f52096 */
#if BIND_git_repository_head_detached_FUNCTION
#define git_repository_head_detached_REQUIRED_ARGC 1
#define git_repository_head_detached_OPTIONAL_ARGC 0
/* git_repository_head_detached
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_head_detached(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_head_detached(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_head_unborn */
/* sha: 48f2a1a2fb6ea5d765c9a7680a90f968707e767e450812bfef2fa9d5cc0bd060 */
#if BIND_git_repository_head_unborn_FUNCTION
#define git_repository_head_unborn_REQUIRED_ARGC 1
#define git_repository_head_unborn_OPTIONAL_ARGC 0
/* git_repository_head_unborn
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_head_unborn(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_head_unborn(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_ident */
/* sha: 8bf10267ba9bb2af257e0599b009ad4e682845c1aba3f1add9b3f3a6a1b9e0f1 */
#if BIND_git_repository_ident_FUNCTION
#define git_repository_ident_REQUIRED_ARGC 1
#define git_repository_ident_OPTIONAL_ARGC 0
/* git_repository_ident
 *
 * Parameters:
 * - repo: const git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_ident(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_name = NULL;
  char * native_email = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  const git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_ident(&native_name, &native_email, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: name */
  mrb_value name = native_name ==  NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_name);
  /* Box out param: email */
  mrb_value email = native_email ==  NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_email);

  /* Add out params to results */
  mrb_ary_push(mrb, results, name);
  mrb_ary_push(mrb, results, email);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_index */
/* sha: ffadb921d173f289b661e59a36a4f661363a0b3498b9dcef3d37fd699d5a8db9 */
#if BIND_git_repository_index_FUNCTION
#define git_repository_index_REQUIRED_ARGC 1
#define git_repository_index_OPTIONAL_ARGC 0
/* git_repository_index
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_index(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_index * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_index(&native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_init */
/* sha: 7715b5970a6983ecc4f008d7cf049b64c14b21f783457a5b4fa993deeaded328 */
#if BIND_git_repository_init_FUNCTION
#define git_repository_init_REQUIRED_ARGC 2
#define git_repository_init_OPTIONAL_ARGC 0
/* git_repository_init
 *
 * Parameters:
 * - path: const char *
 * - is_bare: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_init(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_repository * native_out = NULL;
  char * native_path = NULL;
  mrb_value is_bare;
  int native_is_bare;

  /* Fetch the args */
  mrb_get_args(mrb, "zo", &native_path, &is_bare);
  
  native_is_bare = mrb_test(is_bare);

  /* Invocation */
  int native_return_value = git_repository_init(&native_out, native_path, native_is_bare);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_init_ext */
/* sha: e12f4ecf83ec051a8903cb7e263a26f830f7558c03cbcbc7351f8d7705d90147 */
#if BIND_git_repository_init_ext_FUNCTION
#define git_repository_init_ext_REQUIRED_ARGC 2
#define git_repository_init_ext_OPTIONAL_ARGC 0
/* git_repository_init_ext
 *
 * Parameters:
 * - repo_path: const char *
 * - opts: git_repository_init_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_init_ext(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_repository * native_out = NULL;
  char * native_repo_path = NULL;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "zo", &native_repo_path, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, RepositoryInitOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RepositoryInitOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_repository_init_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_repository_init_options(opts));

  /* Invocation */
  int native_return_value = git_repository_init_ext(&native_out, native_repo_path, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_init_init_options */
/* sha: 06fad8805a1818ed31be787c50133f32fc01da0d2367f8130303627aa7a3a450 */
#if BIND_git_repository_init_init_options_FUNCTION
#define git_repository_init_init_options_REQUIRED_ARGC 2
#define git_repository_init_init_options_OPTIONAL_ARGC 0
/* git_repository_init_init_options
 *
 * Parameters:
 * - opts: git_repository_init_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_init_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, RepositoryInitOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RepositoryInitOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_repository_init_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_repository_init_options(opts));

  /* Invocation */
  int native_return_value = git_repository_init_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_is_bare */
/* sha: 812d374317d6cc89799a9f1653f2ad22f88e2256f279cf8606651eea7db5a9ca */
#if BIND_git_repository_is_bare_FUNCTION
#define git_repository_is_bare_REQUIRED_ARGC 1
#define git_repository_is_bare_OPTIONAL_ARGC 0
/* git_repository_is_bare
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_is_bare(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_is_bare(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_is_empty */
/* sha: 6cac9b58d801f5d4eb5fea1270040ea062d2e0c8b5e3e896434b9a9347d4dbbd */
#if BIND_git_repository_is_empty_FUNCTION
#define git_repository_is_empty_REQUIRED_ARGC 1
#define git_repository_is_empty_OPTIONAL_ARGC 0
/* git_repository_is_empty
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_is_empty(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_is_empty(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_is_shallow */
/* sha: 7ffac33045daf776a0d1f84b8e693dc5fcfba7f65579ac152cde8dbf800749f2 */
#if BIND_git_repository_is_shallow_FUNCTION
#define git_repository_is_shallow_REQUIRED_ARGC 1
#define git_repository_is_shallow_OPTIONAL_ARGC 0
/* git_repository_is_shallow
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_is_shallow(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_is_shallow(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_mergehead_foreach */
/* sha: ff2ff925c67ad6b3ab0b8a6961232c649ab67def8da288d5e1199c9416ff4383 */
#if BIND_git_repository_mergehead_foreach_FUNCTION
#define git_repository_mergehead_foreach_REQUIRED_ARGC 3
#define git_repository_mergehead_foreach_OPTIONAL_ARGC 0
/* git_repository_mergehead_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_repository_mergehead_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_mergehead_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_repository_mergehead_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_repository_mergehead_foreach_cb native_callback = TODO_mruby_unbox_git_repository_mergehead_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_repository_mergehead_foreach(native_repo, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_message */
/* sha: 56cf34d0582c184fd00685fa89448d2a5d1e8bce79d5b9b9fce59554f5667c74 */
#if BIND_git_repository_message_FUNCTION
#define git_repository_message_REQUIRED_ARGC 2
#define git_repository_message_OPTIONAL_ARGC 0
/* git_repository_message
 *
 * Parameters:
 * - out: git_buf *
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_message(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_message(native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_message_remove */
/* sha: 73a618800bcff8fefa0e38491f039c107353525c0c74722c0232c1ab6f955cdc */
#if BIND_git_repository_message_remove_FUNCTION
#define git_repository_message_remove_REQUIRED_ARGC 1
#define git_repository_message_remove_OPTIONAL_ARGC 0
/* git_repository_message_remove
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_message_remove(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_message_remove(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_odb */
/* sha: d4e9ae34bd79a36ac9be0c019f28f50277198d223b0d422ab7e2d57aa27b33d2 */
#if BIND_git_repository_odb_FUNCTION
#define git_repository_odb_REQUIRED_ARGC 1
#define git_repository_odb_OPTIONAL_ARGC 0
/* git_repository_odb
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_odb(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_odb * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_odb(&native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_open */
/* sha: 124929c0f6d9bd84c64cbf62ad96e297da0d943b2fe40c53ef45858f07ded671 */
#if BIND_git_repository_open_FUNCTION
#define git_repository_open_REQUIRED_ARGC 1
#define git_repository_open_OPTIONAL_ARGC 0
/* git_repository_open
 *
 * Parameters:
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_open(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_repository * native_out = NULL;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_path);

  /* Invocation */
  int native_return_value = git_repository_open(&native_out, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_open_bare */
/* sha: 0a47f5cf8e0b048f39e828bf2143d3cee9647e205421d3ffd97bc83956ac27c9 */
#if BIND_git_repository_open_bare_FUNCTION
#define git_repository_open_bare_REQUIRED_ARGC 1
#define git_repository_open_bare_OPTIONAL_ARGC 0
/* git_repository_open_bare
 *
 * Parameters:
 * - bare_path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_open_bare(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_repository * native_out = NULL;
  char * native_bare_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_bare_path);

  /* Invocation */
  int native_return_value = git_repository_open_bare(&native_out, native_bare_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_open_ext */
/* sha: a86c404cb877d9452cc66df45ae6b0632d624c7fd9f17159b1ac14aea32ee9df */
#if BIND_git_repository_open_ext_FUNCTION
#define git_repository_open_ext_REQUIRED_ARGC 3
#define git_repository_open_ext_OPTIONAL_ARGC 0
/* git_repository_open_ext
 *
 * Parameters:
 * - path: const char *
 * - flags: unsigned int
 * - ceiling_dirs: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_open_ext(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_repository * native_out = NULL;
  char * native_path = NULL;
  mrb_int native_flags;
  char * native_ceiling_dirs = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ziz", &native_path, &native_flags, &native_ceiling_dirs);

  /* Invocation */
  int native_return_value = git_repository_open_ext(&native_out, native_path, native_flags, native_ceiling_dirs);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_path */
/* sha: 88fa0935245a2190d257f38feef8cfae64952fbb870af4b43ff44ced4a0e6331 */
#if BIND_git_repository_path_FUNCTION
#define git_repository_path_REQUIRED_ARGC 1
#define git_repository_path_OPTIONAL_ARGC 0
/* git_repository_path
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_repository_path(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  const char * native_return_value = git_repository_path(native_repo);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_refdb */
/* sha: ea7fc42d9fd8e619d833920c6c2a2944392bb8f529797afe62e7661b03c2950a */
#if BIND_git_repository_refdb_FUNCTION
#define git_repository_refdb_REQUIRED_ARGC 1
#define git_repository_refdb_OPTIONAL_ARGC 0
/* git_repository_refdb
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_refdb(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_refdb * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_refdb(&native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_refdb(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_set_head */
/* sha: 854589c0aef73387f592dd0805623f5dc8314fecc92ff677954b248786cfe894 */
#if BIND_git_repository_set_head_FUNCTION
#define git_repository_set_head_REQUIRED_ARGC 2
#define git_repository_set_head_OPTIONAL_ARGC 0
/* git_repository_set_head
 *
 * Parameters:
 * - repo: git_repository *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_set_head(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_set_head(native_repo, native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_set_head_detached */
/* sha: 0ce6b2ccabbd1532128fb97e56e26d6b487578904148b1482bf1ea69674af56c */
#if BIND_git_repository_set_head_detached_FUNCTION
#define git_repository_set_head_detached_REQUIRED_ARGC 2
#define git_repository_set_head_detached_OPTIONAL_ARGC 0
/* git_repository_set_head_detached
 *
 * Parameters:
 * - repo: git_repository *
 * - commitish: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_set_head_detached(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value commitish;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &commitish);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commitish, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: commitish */
  const git_oid * native_commitish = (mrb_nil_p(commitish) ? NULL : mruby_unbox_git_oid(commitish));

  /* Invocation */
  int native_return_value = git_repository_set_head_detached(native_repo, native_commitish);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_set_head_detached_from_annotated */
/* sha: c599e91bcfc748f9a2485a5cf26f0d52bf06dc21c32c6f92e7f315d76c92e077 */
#if BIND_git_repository_set_head_detached_from_annotated_FUNCTION
#define git_repository_set_head_detached_from_annotated_REQUIRED_ARGC 2
#define git_repository_set_head_detached_from_annotated_OPTIONAL_ARGC 0
/* git_repository_set_head_detached_from_annotated
 *
 * Parameters:
 * - repo: git_repository *
 * - commitish: const git_annotated_commit *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_set_head_detached_from_annotated(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value commitish;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &commitish);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commitish, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: commitish */
  const git_annotated_commit * native_commitish = (mrb_nil_p(commitish) ? NULL : mruby_unbox_git_annotated_commit(commitish));

  /* Invocation */
  int native_return_value = git_repository_set_head_detached_from_annotated(native_repo, native_commitish);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_set_ident */
/* sha: cdd23042d0c835bd4ded8d91e65f20f2ff472d7807187f0ebebeab31adcac007 */
#if BIND_git_repository_set_ident_FUNCTION
#define git_repository_set_ident_REQUIRED_ARGC 3
#define git_repository_set_ident_OPTIONAL_ARGC 0
/* git_repository_set_ident
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - email: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_set_ident(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_name = NULL;
  char * native_email = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_name, &native_email);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_set_ident(native_repo, native_name, native_email);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_set_namespace */
/* sha: f2a4a495dac24ce1835f8608cd01c3cef61395a61b2c3d2a0c0c5ac37ab6fa97 */
#if BIND_git_repository_set_namespace_FUNCTION
#define git_repository_set_namespace_REQUIRED_ARGC 2
#define git_repository_set_namespace_OPTIONAL_ARGC 0
/* git_repository_set_namespace
 *
 * Parameters:
 * - repo: git_repository *
 * - nmspace: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_set_namespace(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_nmspace = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_nmspace);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_set_namespace(native_repo, native_nmspace);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_set_workdir */
/* sha: 703167e951e46a327df95b277b4bdec1d6293f8234be252688bb76294b982561 */
#if BIND_git_repository_set_workdir_FUNCTION
#define git_repository_set_workdir_REQUIRED_ARGC 3
#define git_repository_set_workdir_OPTIONAL_ARGC 0
/* git_repository_set_workdir
 *
 * Parameters:
 * - repo: git_repository *
 * - workdir: const char *
 * - update_gitlink: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_set_workdir(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_workdir = NULL;
  mrb_int native_update_gitlink;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &repo, &native_workdir, &native_update_gitlink);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_set_workdir(native_repo, native_workdir, native_update_gitlink);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_state */
/* sha: fe390c57a2d0361409659bce8e2cde2d5db06a16bc9b4082966af3c0534b7740 */
#if BIND_git_repository_state_FUNCTION
#define git_repository_state_REQUIRED_ARGC 1
#define git_repository_state_OPTIONAL_ARGC 0
/* git_repository_state
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_state(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_state(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_state_cleanup */
/* sha: d66c13db62f54667330272406c5a5660c757eee90cf0bcc81afc15d9f4f4d528 */
#if BIND_git_repository_state_cleanup_FUNCTION
#define git_repository_state_cleanup_REQUIRED_ARGC 1
#define git_repository_state_cleanup_OPTIONAL_ARGC 0
/* git_repository_state_cleanup
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_state_cleanup(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_state_cleanup(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_workdir */
/* sha: f18c5e76df2aa2dc1907cc85a5276ad8d6be2608791716978933e74c1c3ea128 */
#if BIND_git_repository_workdir_FUNCTION
#define git_repository_workdir_REQUIRED_ARGC 1
#define git_repository_workdir_OPTIONAL_ARGC 0
/* git_repository_workdir
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_repository_workdir(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  const char * native_return_value = git_repository_workdir(native_repo);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_wrap_odb */
/* sha: 7e01cc20ef820878eb6e3b8f113d3ed19f15d703f297be9d994be680486a80b5 */
#if BIND_git_repository_wrap_odb_FUNCTION
#define git_repository_wrap_odb_REQUIRED_ARGC 1
#define git_repository_wrap_odb_OPTIONAL_ARGC 0
/* git_repository_wrap_odb
 *
 * Parameters:
 * - odb: git_odb *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_wrap_odb(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_repository * native_out = NULL;
  mrb_value odb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &odb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Invocation */
  int native_return_value = git_repository_wrap_odb(&native_out, native_odb);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reset */
/* sha: cdea42a20d578c367315eb00359c4df4bd618e6e47839cf00ea9f5cd542f6903 */
#if BIND_git_reset_FUNCTION
#define git_reset_REQUIRED_ARGC 4
#define git_reset_OPTIONAL_ARGC 0
/* git_reset
 *
 * Parameters:
 * - repo: git_repository *
 * - target: git_object *
 * - reset_type: git_reset_t
 * - checkout_opts: const git_checkout_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reset(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value target;
  mrb_int native_reset_type;
  mrb_value checkout_opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooio", &repo, &target, &native_reset_type, &checkout_opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, checkout_opts, CheckoutOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CheckoutOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: target */
  git_object * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_object(target));

  /* Unbox param: checkout_opts */
  const git_checkout_options * native_checkout_opts = (mrb_nil_p(checkout_opts) ? NULL : mruby_unbox_git_checkout_options(checkout_opts));

  /* Invocation */
  int native_return_value = git_reset(native_repo, native_target, native_reset_type, native_checkout_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reset_default */
/* sha: 170e69f0472af3b74cc88a23aa7a72f397f797a0d827ef3d05f16e9f6782ab55 */
#if BIND_git_reset_default_FUNCTION
#define git_reset_default_REQUIRED_ARGC 3
#define git_reset_default_OPTIONAL_ARGC 0
/* git_reset_default
 *
 * Parameters:
 * - repo: git_repository *
 * - target: git_object *
 * - pathspecs: git_strarray *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reset_default(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value target;
  mrb_value pathspecs;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &target, &pathspecs);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, pathspecs, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: target */
  git_object * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_object(target));

  /* Unbox param: pathspecs */
  git_strarray * native_pathspecs = (mrb_nil_p(pathspecs) ? NULL : mruby_unbox_git_strarray(pathspecs));

  /* Invocation */
  int native_return_value = git_reset_default(native_repo, native_target, native_pathspecs);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reset_from_annotated */
/* sha: 60f5adb5779c89a38ae6d12d532fee4ae4353ed6f55d069c84634f7ff783a280 */
#if BIND_git_reset_from_annotated_FUNCTION
#define git_reset_from_annotated_REQUIRED_ARGC 4
#define git_reset_from_annotated_OPTIONAL_ARGC 0
/* git_reset_from_annotated
 *
 * Parameters:
 * - repo: git_repository *
 * - commit: git_annotated_commit *
 * - reset_type: git_reset_t
 * - checkout_opts: const git_checkout_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reset_from_annotated(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value commit;
  mrb_int native_reset_type;
  mrb_value checkout_opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooio", &repo, &commit, &native_reset_type, &checkout_opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, checkout_opts, CheckoutOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CheckoutOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: commit */
  git_annotated_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_annotated_commit(commit));

  /* Unbox param: checkout_opts */
  const git_checkout_options * native_checkout_opts = (mrb_nil_p(checkout_opts) ? NULL : mruby_unbox_git_checkout_options(checkout_opts));

  /* Invocation */
  int native_return_value = git_reset_from_annotated(native_repo, native_commit, native_reset_type, native_checkout_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revert */
/* sha: b185b65434fd346d1bc078fc88e03b41e1fd677e6187710fd976239e7c055bff */
#if BIND_git_revert_FUNCTION
#define git_revert_REQUIRED_ARGC 3
#define git_revert_OPTIONAL_ARGC 0
/* git_revert
 *
 * Parameters:
 * - repo: git_repository *
 * - commit: git_commit *
 * - given_opts: const git_revert_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revert(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value commit;
  mrb_value given_opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &commit, &given_opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, given_opts, RevertOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RevertOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: commit */
  git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Unbox param: given_opts */
  const git_revert_options * native_given_opts = (mrb_nil_p(given_opts) ? NULL : mruby_unbox_git_revert_options(given_opts));

  /* Invocation */
  int native_return_value = git_revert(native_repo, native_commit, native_given_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revert_commit */
/* sha: de1ac022f86649c696cda6e40cc551c7488a4b897bfd8be1e198e69fa4ffc954 */
#if BIND_git_revert_commit_FUNCTION
#define git_revert_commit_REQUIRED_ARGC 5
#define git_revert_commit_OPTIONAL_ARGC 0
/* git_revert_commit
 *
 * Parameters:
 * - repo: git_repository *
 * - revert_commit: git_commit *
 * - our_commit: git_commit *
 * - mainline: unsigned int
 * - merge_options: const git_merge_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revert_commit(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_index * native_out = NULL;
  mrb_value repo;
  mrb_value revert_commit;
  mrb_value our_commit;
  mrb_int native_mainline;
  mrb_value merge_options;

  /* Fetch the args */
  mrb_get_args(mrb, "oooio", &repo, &revert_commit, &our_commit, &native_mainline, &merge_options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, revert_commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, our_commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, merge_options, MergeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: revert_commit */
  git_commit * native_revert_commit = (mrb_nil_p(revert_commit) ? NULL : mruby_unbox_git_commit(revert_commit));

  /* Unbox param: our_commit */
  git_commit * native_our_commit = (mrb_nil_p(our_commit) ? NULL : mruby_unbox_git_commit(our_commit));

  /* Unbox param: merge_options */
  const git_merge_options * native_merge_options = (mrb_nil_p(merge_options) ? NULL : mruby_unbox_git_merge_options(merge_options));

  /* Invocation */
  int native_return_value = git_revert_commit(&native_out, native_repo, native_revert_commit, native_our_commit, native_mainline, native_merge_options);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revert_init_options */
/* sha: 04ff28412c7fd6491d5ddf1005d46c60098447b726eeb7836716a669f92b14c4 */
#if BIND_git_revert_init_options_FUNCTION
#define git_revert_init_options_REQUIRED_ARGC 2
#define git_revert_init_options_OPTIONAL_ARGC 0
/* git_revert_init_options
 *
 * Parameters:
 * - opts: git_revert_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_revert_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, RevertOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RevertOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_revert_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_revert_options(opts));

  /* Invocation */
  int native_return_value = git_revert_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revparse */
/* sha: f4db0087fb3bdd58b4e3a93e7e3f1acacfc7d2612aae0a788267cb94e5a0e34d */
#if BIND_git_revparse_FUNCTION
#define git_revparse_REQUIRED_ARGC 3
#define git_revparse_OPTIONAL_ARGC 0
/* git_revparse
 *
 * Parameters:
 * - revspec: git_revspec *
 * - repo: git_repository *
 * - spec: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revparse(mrb_state* mrb, mrb_value self) {
  mrb_value revspec;
  mrb_value repo;
  char * native_spec = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &revspec, &repo, &native_spec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, revspec, Revspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revspec expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: revspec */
  git_revspec * native_revspec = (mrb_nil_p(revspec) ? NULL : mruby_unbox_git_revspec(revspec));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_revparse(native_revspec, native_repo, native_spec);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revparse_ext */
/* sha: 5df900a2fa9f39b2173f51eaf80714996b26c7d21ffd1cc34d412a7ad230da6e */
#if BIND_git_revparse_ext_FUNCTION
#define git_revparse_ext_REQUIRED_ARGC 2
#define git_revparse_ext_OPTIONAL_ARGC 0
/* git_revparse_ext
 *
 * Parameters:
 * - repo: git_repository *
 * - spec: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revparse_ext(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_object * native_object_out = NULL;
  git_reference * native_reference_out = NULL;
  mrb_value repo;
  char * native_spec = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_spec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_revparse_ext(&native_object_out, &native_reference_out, native_repo, native_spec);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: object_out */
  mrb_value object_out = native_object_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_object_out);
  /* Box out param: reference_out */
  mrb_value reference_out = native_reference_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_reference_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, object_out);
  mrb_ary_push(mrb, results, reference_out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revparse_single */
/* sha: 5de7136c07e2c5d14d58074264acb7baf9ff0765087f651fc5e294ba1258d2b9 */
#if BIND_git_revparse_single_FUNCTION
#define git_revparse_single_REQUIRED_ARGC 2
#define git_revparse_single_OPTIONAL_ARGC 0
/* git_revparse_single
 *
 * Parameters:
 * - repo: git_repository *
 * - spec: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revparse_single(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_object * native_out = NULL;
  mrb_value repo;
  char * native_spec = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_spec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_revparse_single(&native_out, native_repo, native_spec);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_add_hide_cb */
/* sha: 5260c89385229db4a27acb3ca7642ae4a420406e359d786f40ce12ca70ece044 */
#if BIND_git_revwalk_add_hide_cb_FUNCTION
#define git_revwalk_add_hide_cb_REQUIRED_ARGC 3
#define git_revwalk_add_hide_cb_OPTIONAL_ARGC 0
/* git_revwalk_add_hide_cb
 *
 * Parameters:
 * - walk: git_revwalk *
 * - hide_cb: git_revwalk_hide_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_add_hide_cb(mrb_state* mrb, mrb_value self) {
  mrb_value walk;
  mrb_value hide_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &walk, &hide_cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_revwalk_hide_cb(hide_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Unbox param: hide_cb */
  git_revwalk_hide_cb native_hide_cb = TODO_mruby_unbox_git_revwalk_hide_cb(hide_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_revwalk_add_hide_cb(native_walk, native_hide_cb, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_free */
/* sha: 4a664613c18c06cb1e75cac0e83c3212b64cd5330a49c0568e2d295d0a46607f */
#if BIND_git_revwalk_free_FUNCTION
#define git_revwalk_free_REQUIRED_ARGC 1
#define git_revwalk_free_OPTIONAL_ARGC 0
/* git_revwalk_free
 *
 * Parameters:
 * - walk: git_revwalk *
 * Return Type: void
 */
mrb_value
mrb_Git_git_revwalk_free(mrb_state* mrb, mrb_value self) {
  mrb_value walk;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &walk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  git_revwalk_free(native_walk);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_hide */
/* sha: d219fd32cc3a7da821f7b508d39f0707fdc4e7c07ad42c9b336e9b14fd23bcbd */
#if BIND_git_revwalk_hide_FUNCTION
#define git_revwalk_hide_REQUIRED_ARGC 2
#define git_revwalk_hide_OPTIONAL_ARGC 0
/* git_revwalk_hide
 *
 * Parameters:
 * - walk: git_revwalk *
 * - commit_id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_hide(mrb_state* mrb, mrb_value self) {
  mrb_value walk;
  mrb_value commit_id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &walk, &commit_id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit_id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Unbox param: commit_id */
  const git_oid * native_commit_id = (mrb_nil_p(commit_id) ? NULL : mruby_unbox_git_oid(commit_id));

  /* Invocation */
  int native_return_value = git_revwalk_hide(native_walk, native_commit_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_hide_glob */
/* sha: 3082223056f34d66a88a889af0fb5ec47909ee9a47d93a16384c1e87fe1ee57c */
#if BIND_git_revwalk_hide_glob_FUNCTION
#define git_revwalk_hide_glob_REQUIRED_ARGC 2
#define git_revwalk_hide_glob_OPTIONAL_ARGC 0
/* git_revwalk_hide_glob
 *
 * Parameters:
 * - walk: git_revwalk *
 * - glob: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_hide_glob(mrb_state* mrb, mrb_value self) {
  mrb_value walk;
  char * native_glob = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &walk, &native_glob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_hide_glob(native_walk, native_glob);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_hide_head */
/* sha: eaba798eefe4288f535276cd11bf176522b88b8f4346eac6e4c8ac3abbe17cfa */
#if BIND_git_revwalk_hide_head_FUNCTION
#define git_revwalk_hide_head_REQUIRED_ARGC 1
#define git_revwalk_hide_head_OPTIONAL_ARGC 0
/* git_revwalk_hide_head
 *
 * Parameters:
 * - walk: git_revwalk *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_hide_head(mrb_state* mrb, mrb_value self) {
  mrb_value walk;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &walk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_hide_head(native_walk);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_hide_ref */
/* sha: a0d4a8875d14c6516484ade1a79e1781905ed1dd1fd66584f2ec88c6899b0236 */
#if BIND_git_revwalk_hide_ref_FUNCTION
#define git_revwalk_hide_ref_REQUIRED_ARGC 2
#define git_revwalk_hide_ref_OPTIONAL_ARGC 0
/* git_revwalk_hide_ref
 *
 * Parameters:
 * - walk: git_revwalk *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_hide_ref(mrb_state* mrb, mrb_value self) {
  mrb_value walk;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &walk, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_hide_ref(native_walk, native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_new */
/* sha: 819f8eebca73be83f2317ebe71cb1e6a134b6de659087a29b57be047dd85f9c3 */
#if BIND_git_revwalk_new_FUNCTION
#define git_revwalk_new_REQUIRED_ARGC 1
#define git_revwalk_new_OPTIONAL_ARGC 0
/* git_revwalk_new
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_revwalk * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_revwalk_new(&native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_revwalk(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_next */
/* sha: d9b41f88dcd2a04fe4d493354647584d57ed429cd0e7d21416dbcc60c1900071 */
#if BIND_git_revwalk_next_FUNCTION
#define git_revwalk_next_REQUIRED_ARGC 2
#define git_revwalk_next_OPTIONAL_ARGC 0
/* git_revwalk_next
 *
 * Parameters:
 * - out: git_oid *
 * - walk: git_revwalk *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_next(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value walk;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &walk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_next(native_out, native_walk);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_push */
/* sha: 3532cf91f4d9ea7469cd6a69a2b1c63378c7670eb359bf1a39510d02511b5865 */
#if BIND_git_revwalk_push_FUNCTION
#define git_revwalk_push_REQUIRED_ARGC 2
#define git_revwalk_push_OPTIONAL_ARGC 0
/* git_revwalk_push
 *
 * Parameters:
 * - walk: git_revwalk *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_push(mrb_state* mrb, mrb_value self) {
  mrb_value walk;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &walk, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_revwalk_push(native_walk, native_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_push_glob */
/* sha: 39c87a126d3c034454e9ebbd6fc52a6cb510cc4dd307a79b73231f76fd570861 */
#if BIND_git_revwalk_push_glob_FUNCTION
#define git_revwalk_push_glob_REQUIRED_ARGC 2
#define git_revwalk_push_glob_OPTIONAL_ARGC 0
/* git_revwalk_push_glob
 *
 * Parameters:
 * - walk: git_revwalk *
 * - glob: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_push_glob(mrb_state* mrb, mrb_value self) {
  mrb_value walk;
  char * native_glob = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &walk, &native_glob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_push_glob(native_walk, native_glob);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_push_head */
/* sha: 0123200e8115d2063d1bc1bb985cba647eb1a1b9e13e73e534b421e5b2e233ae */
#if BIND_git_revwalk_push_head_FUNCTION
#define git_revwalk_push_head_REQUIRED_ARGC 1
#define git_revwalk_push_head_OPTIONAL_ARGC 0
/* git_revwalk_push_head
 *
 * Parameters:
 * - walk: git_revwalk *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_push_head(mrb_state* mrb, mrb_value self) {
  mrb_value walk;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &walk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_push_head(native_walk);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_push_range */
/* sha: f5d525719fde307aa42ad36e1fa3d557db3b8bab369044ea96217bceb300008e */
#if BIND_git_revwalk_push_range_FUNCTION
#define git_revwalk_push_range_REQUIRED_ARGC 2
#define git_revwalk_push_range_OPTIONAL_ARGC 0
/* git_revwalk_push_range
 *
 * Parameters:
 * - walk: git_revwalk *
 * - range: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_push_range(mrb_state* mrb, mrb_value self) {
  mrb_value walk;
  char * native_range = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &walk, &native_range);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_push_range(native_walk, native_range);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_push_ref */
/* sha: 89788973a26ee8d92f6a970efa43ccbcd5e442c06e090e8638420856f9bb3e66 */
#if BIND_git_revwalk_push_ref_FUNCTION
#define git_revwalk_push_ref_REQUIRED_ARGC 2
#define git_revwalk_push_ref_OPTIONAL_ARGC 0
/* git_revwalk_push_ref
 *
 * Parameters:
 * - walk: git_revwalk *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_push_ref(mrb_state* mrb, mrb_value self) {
  mrb_value walk;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &walk, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_push_ref(native_walk, native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_repository */
/* sha: c61a01ab4a78edb139d29f5b39b8533bbc0a8e8297382d7e940b96a070a22b62 */
#if BIND_git_revwalk_repository_FUNCTION
#define git_revwalk_repository_REQUIRED_ARGC 1
#define git_revwalk_repository_OPTIONAL_ARGC 0
/* git_revwalk_repository
 *
 * Parameters:
 * - walk: git_revwalk *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_revwalk_repository(mrb_state* mrb, mrb_value self) {
  mrb_value walk;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &walk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  git_repository * native_return_value = git_revwalk_repository(native_walk);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_reset */
/* sha: 86c7c20e4b187a5cd832a82bc67be2f23ad209c917c4bb3d0fc1f64cc9649942 */
#if BIND_git_revwalk_reset_FUNCTION
#define git_revwalk_reset_REQUIRED_ARGC 1
#define git_revwalk_reset_OPTIONAL_ARGC 0
/* git_revwalk_reset
 *
 * Parameters:
 * - walker: git_revwalk *
 * Return Type: void
 */
mrb_value
mrb_Git_git_revwalk_reset(mrb_state* mrb, mrb_value self) {
  mrb_value walker;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &walker);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walker, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walker */
  git_revwalk * native_walker = (mrb_nil_p(walker) ? NULL : mruby_unbox_git_revwalk(walker));

  /* Invocation */
  git_revwalk_reset(native_walker);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_simplify_first_parent */
/* sha: c447f9d3479e113a371fa48155a102fae443a05f0e93f090eb4accd02bc0a0e0 */
#if BIND_git_revwalk_simplify_first_parent_FUNCTION
#define git_revwalk_simplify_first_parent_REQUIRED_ARGC 1
#define git_revwalk_simplify_first_parent_OPTIONAL_ARGC 0
/* git_revwalk_simplify_first_parent
 *
 * Parameters:
 * - walk: git_revwalk *
 * Return Type: void
 */
mrb_value
mrb_Git_git_revwalk_simplify_first_parent(mrb_state* mrb, mrb_value self) {
  mrb_value walk;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &walk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  git_revwalk_simplify_first_parent(native_walk);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_sorting */
/* sha: 7c62402bdb3ae1ba635328f24d66dd8f4150d26e364c39b75485f86a0f3328f7 */
#if BIND_git_revwalk_sorting_FUNCTION
#define git_revwalk_sorting_REQUIRED_ARGC 2
#define git_revwalk_sorting_OPTIONAL_ARGC 0
/* git_revwalk_sorting
 *
 * Parameters:
 * - walk: git_revwalk *
 * - sort_mode: unsigned int
 * Return Type: void
 */
mrb_value
mrb_Git_git_revwalk_sorting(mrb_state* mrb, mrb_value self) {
  mrb_value walk;
  mrb_int native_sort_mode;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &walk, &native_sort_mode);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  git_revwalk_sorting(native_walk, native_sort_mode);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_signature_default */
/* sha: 7ebcccf97a6cbd60424e965e0e6158e538b1f3dd58f5a8bab64e4c59d92e965b */
#if BIND_git_signature_default_FUNCTION
#define git_signature_default_REQUIRED_ARGC 1
#define git_signature_default_OPTIONAL_ARGC 0
/* git_signature_default
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_signature_default(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_signature * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_signature_default(&native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_signature(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_signature_dup */
/* sha: 395402047eb64e6b549a9353f91044b21331a1d33150c7820cc30823916950ab */
#if BIND_git_signature_dup_FUNCTION
#define git_signature_dup_REQUIRED_ARGC 1
#define git_signature_dup_OPTIONAL_ARGC 0
/* git_signature_dup
 *
 * Parameters:
 * - sig: const git_signature *
 * Return Type: int
 */
mrb_value
mrb_Git_git_signature_dup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_signature * native_dest = NULL;
  mrb_value sig;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &sig);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, sig, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: sig */
  const git_signature * native_sig = (mrb_nil_p(sig) ? NULL : mruby_unbox_git_signature(sig));

  /* Invocation */
  int native_return_value = git_signature_dup(&native_dest, native_sig);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: dest */
  mrb_value dest = native_dest == NULL ? mrb_nil_value() : mruby_giftwrap_git_signature(mrb, native_dest);

  /* Add out params to results */
  mrb_ary_push(mrb, results, dest);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_signature_free */
/* sha: 05c158517a03633395b2736892296ee8481f59c4580d0561fe94f39592cc7a69 */
#if BIND_git_signature_free_FUNCTION
#define git_signature_free_REQUIRED_ARGC 1
#define git_signature_free_OPTIONAL_ARGC 0
/* git_signature_free
 *
 * Parameters:
 * - sig: git_signature *
 * Return Type: void
 */
mrb_value
mrb_Git_git_signature_free(mrb_state* mrb, mrb_value self) {
  mrb_value sig;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &sig);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, sig, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: sig */
  git_signature * native_sig = (mrb_nil_p(sig) ? NULL : mruby_unbox_git_signature(sig));

  /* Invocation */
  git_signature_free(native_sig);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_signature_new */
/* sha: 199f5d8b152fbe3bf7d831a3b423a69a5371b74ea266e4516e712f641b0cecbb */
#if BIND_git_signature_new_FUNCTION
#define git_signature_new_REQUIRED_ARGC 4
#define git_signature_new_OPTIONAL_ARGC 0
/* git_signature_new
 *
 * Parameters:
 * - name: const char *
 * - email: const char *
 * - time: git_time_t
 * - offset: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_signature_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_signature * native_out = NULL;
  char * native_name = NULL;
  char * native_email = NULL;
  mrb_int native_time;
  mrb_int native_offset;

  /* Fetch the args */
  mrb_get_args(mrb, "zzii", &native_name, &native_email, &native_time, &native_offset);

  /* Invocation */
  int native_return_value = git_signature_new(&native_out, native_name, native_email, native_time, native_offset);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_signature(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_signature_now */
/* sha: 0dcf16ec2a568f3042c800586386497d1acbb786e6ae4b7e8230d7c08c04e8e0 */
#if BIND_git_signature_now_FUNCTION
#define git_signature_now_REQUIRED_ARGC 2
#define git_signature_now_OPTIONAL_ARGC 0
/* git_signature_now
 *
 * Parameters:
 * - name: const char *
 * - email: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_signature_now(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_signature * native_out = NULL;
  char * native_name = NULL;
  char * native_email = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "zz", &native_name, &native_email);

  /* Invocation */
  int native_return_value = git_signature_now(&native_out, native_name, native_email);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_signature(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_stash_apply */
/* sha: 193242f9038417de7353f0b54057372bc2a43e191683e52b0ecc671fc6c71dea */
#if BIND_git_stash_apply_FUNCTION
#define git_stash_apply_REQUIRED_ARGC 3
#define git_stash_apply_OPTIONAL_ARGC 0
/* git_stash_apply
 *
 * Parameters:
 * - repo: git_repository *
 * - index: size_t
 * - options: const git_stash_apply_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_stash_apply(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_int native_index;
  mrb_value options;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &repo, &native_index, &options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, options, StashApplyOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StashApplyOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: options */
  const git_stash_apply_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_stash_apply_options(options));

  /* Invocation */
  int native_return_value = git_stash_apply(native_repo, native_index, native_options);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_stash_apply_init_options */
/* sha: 9b174ecaad15505b5137bbcc95b04e8f901dc09a5209abbb7eaa287f79fbb16d */
#if BIND_git_stash_apply_init_options_FUNCTION
#define git_stash_apply_init_options_REQUIRED_ARGC 2
#define git_stash_apply_init_options_OPTIONAL_ARGC 0
/* git_stash_apply_init_options
 *
 * Parameters:
 * - opts: git_stash_apply_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_stash_apply_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, StashApplyOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StashApplyOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_stash_apply_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_stash_apply_options(opts));

  /* Invocation */
  int native_return_value = git_stash_apply_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_stash_drop */
/* sha: 32465aef268f7b099ca447742e5561f145449377a9aadb0c952b66e7ff5d3801 */
#if BIND_git_stash_drop_FUNCTION
#define git_stash_drop_REQUIRED_ARGC 2
#define git_stash_drop_OPTIONAL_ARGC 0
/* git_stash_drop
 *
 * Parameters:
 * - repo: git_repository *
 * - index: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_stash_drop(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_int native_index;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &repo, &native_index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_stash_drop(native_repo, native_index);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_stash_foreach */
/* sha: 145eaae424114bddd9eef0e2e13930b89ed5c616697bc8ca67a266b63221063f */
#if BIND_git_stash_foreach_FUNCTION
#define git_stash_foreach_REQUIRED_ARGC 3
#define git_stash_foreach_OPTIONAL_ARGC 0
/* git_stash_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_stash_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_stash_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_stash_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_stash_cb native_callback = TODO_mruby_unbox_git_stash_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_stash_foreach(native_repo, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_stash_pop */
/* sha: 47ac4b321d72218ce6b8e78e9e9b30cb66a0e3d2cf3c0766e75864b3879a750e */
#if BIND_git_stash_pop_FUNCTION
#define git_stash_pop_REQUIRED_ARGC 3
#define git_stash_pop_OPTIONAL_ARGC 0
/* git_stash_pop
 *
 * Parameters:
 * - repo: git_repository *
 * - index: size_t
 * - options: const git_stash_apply_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_stash_pop(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_int native_index;
  mrb_value options;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &repo, &native_index, &options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, options, StashApplyOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StashApplyOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: options */
  const git_stash_apply_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_stash_apply_options(options));

  /* Invocation */
  int native_return_value = git_stash_pop(native_repo, native_index, native_options);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_stash_save */
/* sha: 7527223c5dcc440da0c10ed4009c9304bd6a8cfe625483db61ccf7314b0c131e */
#if BIND_git_stash_save_FUNCTION
#define git_stash_save_REQUIRED_ARGC 5
#define git_stash_save_OPTIONAL_ARGC 0
/* git_stash_save
 *
 * Parameters:
 * - out: git_oid *
 * - repo: git_repository *
 * - stasher: const git_signature *
 * - message: const char *
 * - flags: uint32_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_stash_save(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;
  mrb_value stasher;
  char * native_message = NULL;
  mrb_int native_flags;

  /* Fetch the args */
  mrb_get_args(mrb, "ooozi", &out, &repo, &stasher, &native_message, &native_flags);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, stasher, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: stasher */
  const git_signature * native_stasher = (mrb_nil_p(stasher) ? NULL : mruby_unbox_git_signature(stasher));

  /* Invocation */
  int native_return_value = git_stash_save(native_out, native_repo, native_stasher, native_message, native_flags);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_byindex */
/* sha: 2c5a45b6d9881fb2e625bec9b700e5508d11870ffa88ebf59ca75e7ec6a7b428 */
#if BIND_git_status_byindex_FUNCTION
#define git_status_byindex_REQUIRED_ARGC 2
#define git_status_byindex_OPTIONAL_ARGC 0
/* git_status_byindex
 *
 * Parameters:
 * - statuslist: git_status_list *
 * - idx: size_t
 * Return Type: const git_status_entry *
 */
mrb_value
mrb_Git_git_status_byindex(mrb_state* mrb, mrb_value self) {
  mrb_value statuslist;
  mrb_int native_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &statuslist, &native_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, statuslist, StatusList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StatusList expected");
    return mrb_nil_value();
  }

  /* Unbox param: statuslist */
  git_status_list * native_statuslist = (mrb_nil_p(statuslist) ? NULL : mruby_unbox_git_status_list(statuslist));

  /* Invocation */
  const git_status_entry * native_return_value = git_status_byindex(native_statuslist, native_idx);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_status_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_file */
/* sha: 290c3a24afa1ae2ed676bd6249a0489e5915b883acc09a2f5e00dbb32ae86faa */
#if BIND_git_status_file_FUNCTION
#define git_status_file_REQUIRED_ARGC 2
#define git_status_file_OPTIONAL_ARGC 0
/* git_status_file
 *
 * Parameters:
 * - repo: git_repository *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_status_file(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_status_flags;
  mrb_value repo;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_status_file(&native_status_flags, native_repo, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: status_flags */
  mrb_value status_flags = mrb_fixnum_value(native_status_flags);

  /* Add out params to results */
  mrb_ary_push(mrb, results, status_flags);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_foreach */
/* sha: f973156c9c381e30fcd888c7298c79fbec54fbf0b3f2e13d2af6e1fe69ce64f2 */
#if BIND_git_status_foreach_FUNCTION
#define git_status_foreach_REQUIRED_ARGC 3
#define git_status_foreach_OPTIONAL_ARGC 0
/* git_status_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_status_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_status_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_status_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_status_cb native_callback = TODO_mruby_unbox_git_status_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_status_foreach(native_repo, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_foreach_ext */
/* sha: e8208e258097351e841581e966087027121b8f899541492f36e36af9af1f9008 */
#if BIND_git_status_foreach_ext_FUNCTION
#define git_status_foreach_ext_REQUIRED_ARGC 4
#define git_status_foreach_ext_OPTIONAL_ARGC 0
/* git_status_foreach_ext
 *
 * Parameters:
 * - repo: git_repository *
 * - opts: const git_status_options *
 * - callback: git_status_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_status_foreach_ext(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value opts;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &repo, &opts, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, StatusOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StatusOptions expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_status_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: opts */
  const git_status_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_status_options(opts));

  /* Unbox param: callback */
  git_status_cb native_callback = TODO_mruby_unbox_git_status_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_status_foreach_ext(native_repo, native_opts, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_init_options */
/* sha: cfbcc38514d9b0742e756c29056ff62ce34c3dfe70c5c6ecc00643aa593096ac */
#if BIND_git_status_init_options_FUNCTION
#define git_status_init_options_REQUIRED_ARGC 2
#define git_status_init_options_OPTIONAL_ARGC 0
/* git_status_init_options
 *
 * Parameters:
 * - opts: git_status_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_status_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, StatusOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StatusOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_status_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_status_options(opts));

  /* Invocation */
  int native_return_value = git_status_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_list_entrycount */
/* sha: 4ee2413aaed3bc11d4fd5f786b50c10be874efed835ad0bece135aabc0c128c5 */
#if BIND_git_status_list_entrycount_FUNCTION
#define git_status_list_entrycount_REQUIRED_ARGC 1
#define git_status_list_entrycount_OPTIONAL_ARGC 0
/* git_status_list_entrycount
 *
 * Parameters:
 * - statuslist: git_status_list *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_status_list_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value statuslist;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &statuslist);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, statuslist, StatusList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StatusList expected");
    return mrb_nil_value();
  }

  /* Unbox param: statuslist */
  git_status_list * native_statuslist = (mrb_nil_p(statuslist) ? NULL : mruby_unbox_git_status_list(statuslist));

  /* Invocation */
  size_t native_return_value = git_status_list_entrycount(native_statuslist);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_list_free */
/* sha: 9d5795f9018cb09f4958e19c8bb790b07b829d333eaa1bf42e656a338b49dbce */
#if BIND_git_status_list_free_FUNCTION
#define git_status_list_free_REQUIRED_ARGC 1
#define git_status_list_free_OPTIONAL_ARGC 0
/* git_status_list_free
 *
 * Parameters:
 * - statuslist: git_status_list *
 * Return Type: void
 */
mrb_value
mrb_Git_git_status_list_free(mrb_state* mrb, mrb_value self) {
  mrb_value statuslist;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &statuslist);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, statuslist, StatusList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StatusList expected");
    return mrb_nil_value();
  }

  /* Unbox param: statuslist */
  git_status_list * native_statuslist = (mrb_nil_p(statuslist) ? NULL : mruby_unbox_git_status_list(statuslist));

  /* Invocation */
  git_status_list_free(native_statuslist);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_list_new */
/* sha: cdb6cce6fed36096cab533e095fbc7048ee3a2b773088a64d9948ba276b4c7d4 */
#if BIND_git_status_list_new_FUNCTION
#define git_status_list_new_REQUIRED_ARGC 2
#define git_status_list_new_OPTIONAL_ARGC 0
/* git_status_list_new
 *
 * Parameters:
 * - repo: git_repository *
 * - opts: const git_status_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_status_list_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_status_list * native_out = NULL;
  mrb_value repo;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, StatusOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StatusOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: opts */
  const git_status_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_status_options(opts));

  /* Invocation */
  int native_return_value = git_status_list_new(&native_out, native_repo, native_opts);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_status_list(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_should_ignore */
/* sha: b81eb5ddc24d770f0da75c41f4ed1d02894d9692b0af838cf5084e2d78851ddc */
#if BIND_git_status_should_ignore_FUNCTION
#define git_status_should_ignore_REQUIRED_ARGC 3
#define git_status_should_ignore_OPTIONAL_ARGC 0
/* git_status_should_ignore
 *
 * Parameters:
 * - ignored: int *
 * - repo: git_repository *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_status_should_ignore(mrb_state* mrb, mrb_value self) {
  mrb_value ignored;
  mrb_value repo;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &ignored, &repo, &native_path);

  /* Type checking */
  TODO_type_check_int_PTR(ignored);
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: ignored */
  int * native_ignored = TODO_mruby_unbox_int_PTR(ignored);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_status_should_ignore(native_ignored, native_repo, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_strarray_copy */
/* sha: b2f5a170c5878af219cdbe50f9591396899c0ec20899315685417a7b51e7455e */
#if BIND_git_strarray_copy_FUNCTION
#define git_strarray_copy_REQUIRED_ARGC 2
#define git_strarray_copy_OPTIONAL_ARGC 0
/* git_strarray_copy
 *
 * Parameters:
 * - tgt: git_strarray *
 * - src: const git_strarray *
 * Return Type: int
 */
mrb_value
mrb_Git_git_strarray_copy(mrb_state* mrb, mrb_value self) {
  mrb_value tgt;
  mrb_value src;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &tgt, &src);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tgt, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, src, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }

  /* Unbox param: tgt */
  git_strarray * native_tgt = (mrb_nil_p(tgt) ? NULL : mruby_unbox_git_strarray(tgt));

  /* Unbox param: src */
  const git_strarray * native_src = (mrb_nil_p(src) ? NULL : mruby_unbox_git_strarray(src));

  /* Invocation */
  int native_return_value = git_strarray_copy(native_tgt, native_src);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_strarray_free */
/* sha: 6927ac6e8a7782d8295216aab1574d5922b4cbd1bd330f6ec03f1b1ea9f7ea99 */
#if BIND_git_strarray_free_FUNCTION
#define git_strarray_free_REQUIRED_ARGC 1
#define git_strarray_free_OPTIONAL_ARGC 0
/* git_strarray_free
 *
 * Parameters:
 * - array: git_strarray *
 * Return Type: void
 */
mrb_value
mrb_Git_git_strarray_free(mrb_state* mrb, mrb_value self) {
  mrb_value array;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }

  /* Unbox param: array */
  git_strarray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox_git_strarray(array));

  /* Invocation */
  git_strarray_free(native_array);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_add_finalize */
/* sha: 1fc35b9f1fb609685a4bf0b60562035dadc64dd410ae50e8f8d8ef4f6a85b3af */
#if BIND_git_submodule_add_finalize_FUNCTION
#define git_submodule_add_finalize_REQUIRED_ARGC 1
#define git_submodule_add_finalize_OPTIONAL_ARGC 0
/* git_submodule_add_finalize
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_add_finalize(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  int native_return_value = git_submodule_add_finalize(native_submodule);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_add_setup */
/* sha: 92731633788589c8748e00a4d89cd4db6c6cb924e7c0267be0061678f0b908d8 */
#if BIND_git_submodule_add_setup_FUNCTION
#define git_submodule_add_setup_REQUIRED_ARGC 4
#define git_submodule_add_setup_OPTIONAL_ARGC 0
/* git_submodule_add_setup
 *
 * Parameters:
 * - repo: git_repository *
 * - url: const char *
 * - path: const char *
 * - use_gitlink: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_add_setup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_submodule * native_out = NULL;
  mrb_value repo;
  char * native_url = NULL;
  char * native_path = NULL;
  mrb_int native_use_gitlink;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzi", &repo, &native_url, &native_path, &native_use_gitlink);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_add_setup(&native_out, native_repo, native_url, native_path, native_use_gitlink);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_submodule(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_add_to_index */
/* sha: 7719937f6085cebffb5618b4ea42ada6a57bf5c05a358e41b95042787442279b */
#if BIND_git_submodule_add_to_index_FUNCTION
#define git_submodule_add_to_index_REQUIRED_ARGC 2
#define git_submodule_add_to_index_OPTIONAL_ARGC 0
/* git_submodule_add_to_index
 *
 * Parameters:
 * - submodule: git_submodule *
 * - write_index: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_add_to_index(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;
  mrb_int native_write_index;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &submodule, &native_write_index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  int native_return_value = git_submodule_add_to_index(native_submodule, native_write_index);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_branch */
/* sha: 24d87df887f95ae556a9673c95fc8e89d4c46fdec9608e0b250623676db362ae */
#if BIND_git_submodule_branch_FUNCTION
#define git_submodule_branch_REQUIRED_ARGC 1
#define git_submodule_branch_OPTIONAL_ARGC 0
/* git_submodule_branch
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_submodule_branch(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  const char * native_return_value = git_submodule_branch(native_submodule);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_fetch_recurse_submodules */
/* sha: 8d6e9b1dc3eb43866f7d7791f88152a13946b38c27b0da3154cd19a46c0bad31 */
#if BIND_git_submodule_fetch_recurse_submodules_FUNCTION
#define git_submodule_fetch_recurse_submodules_REQUIRED_ARGC 1
#define git_submodule_fetch_recurse_submodules_OPTIONAL_ARGC 0
/* git_submodule_fetch_recurse_submodules
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: git_submodule_recurse_t
 */
mrb_value
mrb_Git_git_submodule_fetch_recurse_submodules(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  git_submodule_recurse_t native_return_value = git_submodule_fetch_recurse_submodules(native_submodule);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_foreach */
/* sha: f0143f999e56fb0e13aaf29ba8aec55933d8690f3a66117bb8d53241ec756c91 */
#if BIND_git_submodule_foreach_FUNCTION
#define git_submodule_foreach_REQUIRED_ARGC 3
#define git_submodule_foreach_OPTIONAL_ARGC 0
/* git_submodule_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_submodule_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_submodule_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_submodule_cb native_callback = TODO_mruby_unbox_git_submodule_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_submodule_foreach(native_repo, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_free */
/* sha: 500db70b425dcca1028ef1a584ce9d63987ae18a8c8c88979a456ec854e334ae */
#if BIND_git_submodule_free_FUNCTION
#define git_submodule_free_REQUIRED_ARGC 1
#define git_submodule_free_OPTIONAL_ARGC 0
/* git_submodule_free
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: void
 */
mrb_value
mrb_Git_git_submodule_free(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  git_submodule_free(native_submodule);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_head_id */
/* sha: 271f50d5cc7a8c5decf9ac3d3ae5f24573f79da52fcf57d749cab80e35496ce4 */
#if BIND_git_submodule_head_id_FUNCTION
#define git_submodule_head_id_REQUIRED_ARGC 1
#define git_submodule_head_id_OPTIONAL_ARGC 0
/* git_submodule_head_id
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_submodule_head_id(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  const git_oid * native_return_value = git_submodule_head_id(native_submodule);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_ignore */
/* sha: b8e5d91399950801775a25fb6701ebbb5c7914e8d057f4c315196460afcfa2fd */
#if BIND_git_submodule_ignore_FUNCTION
#define git_submodule_ignore_REQUIRED_ARGC 1
#define git_submodule_ignore_OPTIONAL_ARGC 0
/* git_submodule_ignore
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: git_submodule_ignore_t
 */
mrb_value
mrb_Git_git_submodule_ignore(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  git_submodule_ignore_t native_return_value = git_submodule_ignore(native_submodule);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_index_id */
/* sha: 7e86e8c3c5f3d952f1cdbbdd34a5948fd618c3fe3c579d83ebd26a6c24c05844 */
#if BIND_git_submodule_index_id_FUNCTION
#define git_submodule_index_id_REQUIRED_ARGC 1
#define git_submodule_index_id_OPTIONAL_ARGC 0
/* git_submodule_index_id
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_submodule_index_id(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  const git_oid * native_return_value = git_submodule_index_id(native_submodule);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_init */
/* sha: be19a983381f217a6984b4fe43e3d53b59d40c104ec0b3e251ae83812163bcc9 */
#if BIND_git_submodule_init_FUNCTION
#define git_submodule_init_REQUIRED_ARGC 2
#define git_submodule_init_OPTIONAL_ARGC 0
/* git_submodule_init
 *
 * Parameters:
 * - submodule: git_submodule *
 * - overwrite: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_init(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;
  mrb_int native_overwrite;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &submodule, &native_overwrite);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  int native_return_value = git_submodule_init(native_submodule, native_overwrite);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_location */
/* sha: 786435c42b6845d5234e6c5cd7864949e81ebba3245c21a73a4c350c0454a8dc */
#if BIND_git_submodule_location_FUNCTION
#define git_submodule_location_REQUIRED_ARGC 1
#define git_submodule_location_OPTIONAL_ARGC 0
/* git_submodule_location
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_location(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_location_status;
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  int native_return_value = git_submodule_location(&native_location_status, native_submodule);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: location_status */
  mrb_value location_status = mrb_fixnum_value(native_location_status);

  /* Add out params to results */
  mrb_ary_push(mrb, results, location_status);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_lookup */
/* sha: 0c076e33b6316906cb81a71d990d2fbd9b290469e48a422d3ad2c605a9bbcc66 */
#if BIND_git_submodule_lookup_FUNCTION
#define git_submodule_lookup_REQUIRED_ARGC 2
#define git_submodule_lookup_OPTIONAL_ARGC 0
/* git_submodule_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_lookup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_submodule * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_lookup(&native_out, native_repo, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_submodule(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_name */
/* sha: 1a3d7ea776b60fe87e8d7470af67aba9df34664eb72e19e455b2c41b5fb552fc */
#if BIND_git_submodule_name_FUNCTION
#define git_submodule_name_REQUIRED_ARGC 1
#define git_submodule_name_OPTIONAL_ARGC 0
/* git_submodule_name
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_submodule_name(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  const char * native_return_value = git_submodule_name(native_submodule);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_open */
/* sha: eae6cbc7700be413539c9d024fd098f6f91da5cf4d668262b7cfcecd0a3869a8 */
#if BIND_git_submodule_open_FUNCTION
#define git_submodule_open_REQUIRED_ARGC 1
#define git_submodule_open_OPTIONAL_ARGC 0
/* git_submodule_open
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_open(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_repository * native_repo = NULL;
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  int native_return_value = git_submodule_open(&native_repo, native_submodule);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: repo */
  mrb_value repo = native_repo == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_repo);

  /* Add out params to results */
  mrb_ary_push(mrb, results, repo);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_owner */
/* sha: 2c8805dd7669c29ed5550cfe85b80535097c53525acee59af92cc79ba16e1886 */
#if BIND_git_submodule_owner_FUNCTION
#define git_submodule_owner_REQUIRED_ARGC 1
#define git_submodule_owner_OPTIONAL_ARGC 0
/* git_submodule_owner
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_submodule_owner(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  git_repository * native_return_value = git_submodule_owner(native_submodule);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_path */
/* sha: 8628bf020227abc6fb136daf841d89829b30332327585c21b58e5b0e530de9bb */
#if BIND_git_submodule_path_FUNCTION
#define git_submodule_path_REQUIRED_ARGC 1
#define git_submodule_path_OPTIONAL_ARGC 0
/* git_submodule_path
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_submodule_path(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  const char * native_return_value = git_submodule_path(native_submodule);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_reload */
/* sha: db0adb14b461bbcb3e88c25205569ec5dad6454dff71242724d3870a60ea0011 */
#if BIND_git_submodule_reload_FUNCTION
#define git_submodule_reload_REQUIRED_ARGC 2
#define git_submodule_reload_OPTIONAL_ARGC 0
/* git_submodule_reload
 *
 * Parameters:
 * - submodule: git_submodule *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_reload(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;
  mrb_int native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &submodule, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  int native_return_value = git_submodule_reload(native_submodule, native_force);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_repo_init */
/* sha: d1a7a9b6d14cbbf967158af6025acf492925d5fdac6a41a681ab6a7d75e57227 */
#if BIND_git_submodule_repo_init_FUNCTION
#define git_submodule_repo_init_REQUIRED_ARGC 2
#define git_submodule_repo_init_OPTIONAL_ARGC 0
/* git_submodule_repo_init
 *
 * Parameters:
 * - sm: const git_submodule *
 * - use_gitlink: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_repo_init(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_repository * native_out = NULL;
  mrb_value sm;
  mrb_int native_use_gitlink;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &sm, &native_use_gitlink);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, sm, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: sm */
  const git_submodule * native_sm = (mrb_nil_p(sm) ? NULL : mruby_unbox_git_submodule(sm));

  /* Invocation */
  int native_return_value = git_submodule_repo_init(&native_out, native_sm, native_use_gitlink);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_resolve_url */
/* sha: 53248ce2fc6579341890e5bd9298d8525b2bfe3a29328d1680735085e41ad0a3 */
#if BIND_git_submodule_resolve_url_FUNCTION
#define git_submodule_resolve_url_REQUIRED_ARGC 3
#define git_submodule_resolve_url_OPTIONAL_ARGC 0
/* git_submodule_resolve_url
 *
 * Parameters:
 * - out: git_buf *
 * - repo: git_repository *
 * - url: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_resolve_url(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value repo;
  char * native_url = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &out, &repo, &native_url);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_buf * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_buf(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_resolve_url(native_out, native_repo, native_url);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_set_branch */
/* sha: 9b1076d0bcf5adbae885498b0844c5b5290013719df053f5dd421c76794b4e70 */
#if BIND_git_submodule_set_branch_FUNCTION
#define git_submodule_set_branch_REQUIRED_ARGC 3
#define git_submodule_set_branch_OPTIONAL_ARGC 0
/* git_submodule_set_branch
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - branch: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_set_branch(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_name = NULL;
  char * native_branch = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_name, &native_branch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_set_branch(native_repo, native_name, native_branch);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_set_fetch_recurse_submodules */
/* sha: c6e478e23d51a07e246e553f02d58af274451a7fa28d81ca2a7780b9b9cbf62e */
#if BIND_git_submodule_set_fetch_recurse_submodules_FUNCTION
#define git_submodule_set_fetch_recurse_submodules_REQUIRED_ARGC 3
#define git_submodule_set_fetch_recurse_submodules_OPTIONAL_ARGC 0
/* git_submodule_set_fetch_recurse_submodules
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - fetch_recurse_submodules: git_submodule_recurse_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_set_fetch_recurse_submodules(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_name = NULL;
  mrb_int native_fetch_recurse_submodules;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &repo, &native_name, &native_fetch_recurse_submodules);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_set_fetch_recurse_submodules(native_repo, native_name, native_fetch_recurse_submodules);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_set_ignore */
/* sha: b82e1c742636c450ed0e4771d8c1b8e5902fb9f6df80d7d9eb18a683f293af53 */
#if BIND_git_submodule_set_ignore_FUNCTION
#define git_submodule_set_ignore_REQUIRED_ARGC 3
#define git_submodule_set_ignore_OPTIONAL_ARGC 0
/* git_submodule_set_ignore
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - ignore: git_submodule_ignore_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_set_ignore(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_name = NULL;
  mrb_int native_ignore;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &repo, &native_name, &native_ignore);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_set_ignore(native_repo, native_name, native_ignore);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_set_update */
/* sha: 21ae595b306ca08ed62d133c44316c20ebde3f610e67bf719f45b108f364bb09 */
#if BIND_git_submodule_set_update_FUNCTION
#define git_submodule_set_update_REQUIRED_ARGC 3
#define git_submodule_set_update_OPTIONAL_ARGC 0
/* git_submodule_set_update
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - update: git_submodule_update_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_set_update(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_name = NULL;
  mrb_int native_update;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &repo, &native_name, &native_update);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_set_update(native_repo, native_name, native_update);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_set_url */
/* sha: 570ffb3969071d864da2e5bb746ad497031c9a7f6236d81dea5dde74f461177b */
#if BIND_git_submodule_set_url_FUNCTION
#define git_submodule_set_url_REQUIRED_ARGC 3
#define git_submodule_set_url_OPTIONAL_ARGC 0
/* git_submodule_set_url
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - url: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_set_url(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_name = NULL;
  char * native_url = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_name, &native_url);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_set_url(native_repo, native_name, native_url);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_status */
/* sha: be51f0186906f18c6d0173e7d794ca3735374a5752446ef9cd8c3121abdedb02 */
#if BIND_git_submodule_status_FUNCTION
#define git_submodule_status_REQUIRED_ARGC 3
#define git_submodule_status_OPTIONAL_ARGC 0
/* git_submodule_status
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - ignore: git_submodule_ignore_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_status(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_status;
  mrb_value repo;
  char * native_name = NULL;
  mrb_int native_ignore;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &repo, &native_name, &native_ignore);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_status(&native_status, native_repo, native_name, native_ignore);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: status */
  mrb_value status = mrb_fixnum_value(native_status);

  /* Add out params to results */
  mrb_ary_push(mrb, results, status);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_sync */
/* sha: 92b5ff5b7f43ba111f701d56347dd2f931b112ed400dfa6581a84440a3c59752 */
#if BIND_git_submodule_sync_FUNCTION
#define git_submodule_sync_REQUIRED_ARGC 1
#define git_submodule_sync_OPTIONAL_ARGC 0
/* git_submodule_sync
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_sync(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  int native_return_value = git_submodule_sync(native_submodule);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_update */
/* sha: 9cf769ed12f58c95e937df42edde664a57da74e119a7930f9bfed261974a2eed */
#if BIND_git_submodule_update_FUNCTION
#define git_submodule_update_REQUIRED_ARGC 3
#define git_submodule_update_OPTIONAL_ARGC 0
/* git_submodule_update
 *
 * Parameters:
 * - submodule: git_submodule *
 * - init: int
 * - options: git_submodule_update_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_update(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;
  mrb_int native_init;
  mrb_value options;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &submodule, &native_init, &options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, options, SubmoduleUpdateOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "SubmoduleUpdateOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Unbox param: options */
  git_submodule_update_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_submodule_update_options(options));

  /* Invocation */
  int native_return_value = git_submodule_update(native_submodule, native_init, native_options);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_update_init_options */
/* sha: 691996b568d5084b1970ae941d395e906c822b7e4994e0622d2e700e5be8a539 */
#if BIND_git_submodule_update_init_options_FUNCTION
#define git_submodule_update_init_options_REQUIRED_ARGC 2
#define git_submodule_update_init_options_OPTIONAL_ARGC 0
/* git_submodule_update_init_options
 *
 * Parameters:
 * - opts: git_submodule_update_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_update_init_options(mrb_state* mrb, mrb_value self) {
  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, SubmoduleUpdateOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "SubmoduleUpdateOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_submodule_update_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_submodule_update_options(opts));

  /* Invocation */
  int native_return_value = git_submodule_update_init_options(native_opts, native_version);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_update_strategy */
/* sha: 0703ebb67562e0501491ef4c3c92b362473c014ffdfa6c6157fc0cc79f76a4a5 */
#if BIND_git_submodule_update_strategy_FUNCTION
#define git_submodule_update_strategy_REQUIRED_ARGC 1
#define git_submodule_update_strategy_OPTIONAL_ARGC 0
/* git_submodule_update_strategy
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: git_submodule_update_t
 */
mrb_value
mrb_Git_git_submodule_update_strategy(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  git_submodule_update_t native_return_value = git_submodule_update_strategy(native_submodule);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_url */
/* sha: 90eeac5834c35dd599edc06df5496532e48e9b75a8aa8f6e5cc8d2d4d23eba38 */
#if BIND_git_submodule_url_FUNCTION
#define git_submodule_url_REQUIRED_ARGC 1
#define git_submodule_url_OPTIONAL_ARGC 0
/* git_submodule_url
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_submodule_url(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  const char * native_return_value = git_submodule_url(native_submodule);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_wd_id */
/* sha: 841f2c3533833db847858f4e4cf36a5bec38edeb7f935e260706529bdbc65838 */
#if BIND_git_submodule_wd_id_FUNCTION
#define git_submodule_wd_id_REQUIRED_ARGC 1
#define git_submodule_wd_id_OPTIONAL_ARGC 0
/* git_submodule_wd_id
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_submodule_wd_id(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  const git_oid * native_return_value = git_submodule_wd_id(native_submodule);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_annotation_create */
/* sha: 5182b7b3e9a3e4883f1e5f19801c2fb8e190ca1f28632837fd96e0ae06ace4c0 */
#if BIND_git_tag_annotation_create_FUNCTION
#define git_tag_annotation_create_REQUIRED_ARGC 6
#define git_tag_annotation_create_OPTIONAL_ARGC 0
/* git_tag_annotation_create
 *
 * Parameters:
 * - oid: git_oid *
 * - repo: git_repository *
 * - tag_name: const char *
 * - target: const git_object *
 * - tagger: const git_signature *
 * - message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_annotation_create(mrb_state* mrb, mrb_value self) {
  mrb_value oid;
  mrb_value repo;
  char * native_tag_name = NULL;
  mrb_value target;
  mrb_value tagger;
  char * native_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oozooz", &oid, &repo, &native_tag_name, &target, &tagger, &native_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, oid, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, tagger, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: oid */
  git_oid * native_oid = (mrb_nil_p(oid) ? NULL : mruby_unbox_git_oid(oid));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: target */
  const git_object * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_object(target));

  /* Unbox param: tagger */
  const git_signature * native_tagger = (mrb_nil_p(tagger) ? NULL : mruby_unbox_git_signature(tagger));

  /* Invocation */
  int native_return_value = git_tag_annotation_create(native_oid, native_repo, native_tag_name, native_target, native_tagger, native_message);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_create */
/* sha: f069c37736391bc84e91c9cde4fb71e0feae689ead033ee86bda4f7108e71689 */
#if BIND_git_tag_create_FUNCTION
#define git_tag_create_REQUIRED_ARGC 7
#define git_tag_create_OPTIONAL_ARGC 0
/* git_tag_create
 *
 * Parameters:
 * - oid: git_oid *
 * - repo: git_repository *
 * - tag_name: const char *
 * - target: const git_object *
 * - tagger: const git_signature *
 * - message: const char *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_create(mrb_state* mrb, mrb_value self) {
  mrb_value oid;
  mrb_value repo;
  char * native_tag_name = NULL;
  mrb_value target;
  mrb_value tagger;
  char * native_message = NULL;
  mrb_int native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "oozoozi", &oid, &repo, &native_tag_name, &target, &tagger, &native_message, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, oid, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, tagger, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: oid */
  git_oid * native_oid = (mrb_nil_p(oid) ? NULL : mruby_unbox_git_oid(oid));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: target */
  const git_object * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_object(target));

  /* Unbox param: tagger */
  const git_signature * native_tagger = (mrb_nil_p(tagger) ? NULL : mruby_unbox_git_signature(tagger));

  /* Invocation */
  int native_return_value = git_tag_create(native_oid, native_repo, native_tag_name, native_target, native_tagger, native_message, native_force);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_create_frombuffer */
/* sha: 6076f1c4e589d05dc46e9bf55ec4b64e430cf50d136d6df4a5d6f405387e7ed7 */
#if BIND_git_tag_create_frombuffer_FUNCTION
#define git_tag_create_frombuffer_REQUIRED_ARGC 4
#define git_tag_create_frombuffer_OPTIONAL_ARGC 0
/* git_tag_create_frombuffer
 *
 * Parameters:
 * - oid: git_oid *
 * - repo: git_repository *
 * - buffer: const char *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_create_frombuffer(mrb_state* mrb, mrb_value self) {
  mrb_value oid;
  mrb_value repo;
  char * native_buffer = NULL;
  mrb_int native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "oozi", &oid, &repo, &native_buffer, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, oid, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: oid */
  git_oid * native_oid = (mrb_nil_p(oid) ? NULL : mruby_unbox_git_oid(oid));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_tag_create_frombuffer(native_oid, native_repo, native_buffer, native_force);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_create_lightweight */
/* sha: 235f87ea7894b38503a4a1bbaaff077ab362deff02b61815dfae28724a5509c0 */
#if BIND_git_tag_create_lightweight_FUNCTION
#define git_tag_create_lightweight_REQUIRED_ARGC 5
#define git_tag_create_lightweight_OPTIONAL_ARGC 0
/* git_tag_create_lightweight
 *
 * Parameters:
 * - oid: git_oid *
 * - repo: git_repository *
 * - tag_name: const char *
 * - target: const git_object *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_create_lightweight(mrb_state* mrb, mrb_value self) {
  mrb_value oid;
  mrb_value repo;
  char * native_tag_name = NULL;
  mrb_value target;
  mrb_int native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "oozoi", &oid, &repo, &native_tag_name, &target, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, oid, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: oid */
  git_oid * native_oid = (mrb_nil_p(oid) ? NULL : mruby_unbox_git_oid(oid));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: target */
  const git_object * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_object(target));

  /* Invocation */
  int native_return_value = git_tag_create_lightweight(native_oid, native_repo, native_tag_name, native_target, native_force);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_delete */
/* sha: 836d9b03b29b6217ed56b19e97438cb0489dafd7be544b2830195d49ce0a8292 */
#if BIND_git_tag_delete_FUNCTION
#define git_tag_delete_REQUIRED_ARGC 2
#define git_tag_delete_OPTIONAL_ARGC 0
/* git_tag_delete
 *
 * Parameters:
 * - repo: git_repository *
 * - tag_name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_delete(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_tag_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_tag_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_tag_delete(native_repo, native_tag_name);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_foreach */
/* sha: 7a401f6c091da5b2460020e65f5fd0fd4cceadaff790bcc59fef6f8312514c0b */
#if BIND_git_tag_foreach_FUNCTION
#define git_tag_foreach_REQUIRED_ARGC 3
#define git_tag_foreach_OPTIONAL_ARGC 0
/* git_tag_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_tag_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_tag_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_tag_foreach_cb native_callback = TODO_mruby_unbox_git_tag_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_tag_foreach(native_repo, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_free */
/* sha: 052b5a2772be6b07bbf26a8b20e15abcf77ef5d91c0d62c2a3af4b5f56b05537 */
#if BIND_git_tag_free_FUNCTION
#define git_tag_free_REQUIRED_ARGC 1
#define git_tag_free_OPTIONAL_ARGC 0
/* git_tag_free
 *
 * Parameters:
 * - tag: git_tag *
 * Return Type: void
 */
mrb_value
mrb_Git_git_tag_free(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  git_tag_free(native_tag);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_id */
/* sha: c32511f6ff9a3efe8b0ecbb4940b21e640736f0fde08ba13f9615ae39256052a */
#if BIND_git_tag_id_FUNCTION
#define git_tag_id_REQUIRED_ARGC 1
#define git_tag_id_OPTIONAL_ARGC 0
/* git_tag_id
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_tag_id(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  const git_oid * native_return_value = git_tag_id(native_tag);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_list */
/* sha: b5216da5993e10ad8a65cb69dbbc1910acdf133cb8cb99689c2a8267b2b7df0f */
#if BIND_git_tag_list_FUNCTION
#define git_tag_list_REQUIRED_ARGC 2
#define git_tag_list_OPTIONAL_ARGC 0
/* git_tag_list
 *
 * Parameters:
 * - tag_names: git_strarray *
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_list(mrb_state* mrb, mrb_value self) {
  mrb_value tag_names;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &tag_names, &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag_names, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag_names */
  git_strarray * native_tag_names = (mrb_nil_p(tag_names) ? NULL : mruby_unbox_git_strarray(tag_names));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_tag_list(native_tag_names, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_list_match */
/* sha: dff341a30b9cac2274c291bf6665923ec319ea9391984b19e4036256ded3a7c2 */
#if BIND_git_tag_list_match_FUNCTION
#define git_tag_list_match_REQUIRED_ARGC 3
#define git_tag_list_match_OPTIONAL_ARGC 0
/* git_tag_list_match
 *
 * Parameters:
 * - tag_names: git_strarray *
 * - pattern: const char *
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_list_match(mrb_state* mrb, mrb_value self) {
  mrb_value tag_names;
  char * native_pattern = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "ozo", &tag_names, &native_pattern, &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag_names, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag_names */
  git_strarray * native_tag_names = (mrb_nil_p(tag_names) ? NULL : mruby_unbox_git_strarray(tag_names));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_tag_list_match(native_tag_names, native_pattern, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_lookup */
/* sha: c0f58644a94f9c4adf4b9b28b5ab0fd58c1ab18d7978ab379c4d6bec7877f197 */
#if BIND_git_tag_lookup_FUNCTION
#define git_tag_lookup_REQUIRED_ARGC 2
#define git_tag_lookup_OPTIONAL_ARGC 0
/* git_tag_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_lookup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_tag * native_out = NULL;
  mrb_value repo;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_tag_lookup(&native_out, native_repo, native_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_tag(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_lookup_prefix */
/* sha: 92ffd68819b600b9e3086c9e3b3ed20d92adbf2d5780fa52dff9887040c1616a */
#if BIND_git_tag_lookup_prefix_FUNCTION
#define git_tag_lookup_prefix_REQUIRED_ARGC 3
#define git_tag_lookup_prefix_OPTIONAL_ARGC 0
/* git_tag_lookup_prefix
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_lookup_prefix(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_tag * native_out = NULL;
  mrb_value repo;
  mrb_value id;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &repo, &id, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_tag_lookup_prefix(&native_out, native_repo, native_id, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_tag(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_message */
/* sha: c4f9a8dfd1f427dfc83b1a7b89932496a73f616ad064c6ccf9fdf83d4a3cc8ce */
#if BIND_git_tag_message_FUNCTION
#define git_tag_message_REQUIRED_ARGC 1
#define git_tag_message_OPTIONAL_ARGC 0
/* git_tag_message
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_tag_message(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  const char * native_return_value = git_tag_message(native_tag);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_name */
/* sha: 3ce6a2aa634632f444a234866aa4bc7a0d2c7a65f79d528e3cf01e33d7a9fdaa */
#if BIND_git_tag_name_FUNCTION
#define git_tag_name_REQUIRED_ARGC 1
#define git_tag_name_OPTIONAL_ARGC 0
/* git_tag_name
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_tag_name(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  const char * native_return_value = git_tag_name(native_tag);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_owner */
/* sha: cdb7acb92cd7feec98eb4639ffc752aaebdce7432cacd9080377b18b753c6f57 */
#if BIND_git_tag_owner_FUNCTION
#define git_tag_owner_REQUIRED_ARGC 1
#define git_tag_owner_OPTIONAL_ARGC 0
/* git_tag_owner
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_tag_owner(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  git_repository * native_return_value = git_tag_owner(native_tag);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_peel */
/* sha: d142e6119d27c1b3096c726125e8c297109b46718739626686a9423abd3f27cd */
#if BIND_git_tag_peel_FUNCTION
#define git_tag_peel_REQUIRED_ARGC 1
#define git_tag_peel_OPTIONAL_ARGC 0
/* git_tag_peel
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_peel(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_object * native_tag_target_out = NULL;
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  int native_return_value = git_tag_peel(&native_tag_target_out, native_tag);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: tag_target_out */
  mrb_value tag_target_out = native_tag_target_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_tag_target_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, tag_target_out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_tagger */
/* sha: c837ab2c914bbb2701a0656ffddb7969f7b2add242bc6f483bbf2cface6d0890 */
#if BIND_git_tag_tagger_FUNCTION
#define git_tag_tagger_REQUIRED_ARGC 1
#define git_tag_tagger_OPTIONAL_ARGC 0
/* git_tag_tagger
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: const git_signature *
 */
mrb_value
mrb_Git_git_tag_tagger(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  const git_signature * native_return_value = git_tag_tagger(native_tag);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_signature(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_target */
/* sha: 729c1eb51daf358c22a9fd470fb60d7d04ad4a2236422082165602170da41474 */
#if BIND_git_tag_target_FUNCTION
#define git_tag_target_REQUIRED_ARGC 1
#define git_tag_target_OPTIONAL_ARGC 0
/* git_tag_target
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_target(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_object * native_target_out = NULL;
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  int native_return_value = git_tag_target(&native_target_out, native_tag);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: target_out */
  mrb_value target_out = native_target_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_target_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, target_out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_target_id */
/* sha: 17b36e87b8a238b13713361688a6b97051a0b8d355369cf28579b332a827776f */
#if BIND_git_tag_target_id_FUNCTION
#define git_tag_target_id_REQUIRED_ARGC 1
#define git_tag_target_id_OPTIONAL_ARGC 0
/* git_tag_target_id
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_tag_target_id(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  const git_oid * native_return_value = git_tag_target_id(native_tag);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_target_type */
/* sha: 15db3e6518567a124504a4db8157e1baf72a5fbd927f27b3eb1f5c0cd3c2496b */
#if BIND_git_tag_target_type_FUNCTION
#define git_tag_target_type_REQUIRED_ARGC 1
#define git_tag_target_type_OPTIONAL_ARGC 0
/* git_tag_target_type
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: git_otype
 */
mrb_value
mrb_Git_git_tag_target_type(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  git_otype native_return_value = git_tag_target_type(native_tag);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_trace_set */
/* sha: ffbe3f6dc665d9d7c279c0f8159f82a627287b452ba555fc07bbc41e62c34331 */
#if BIND_git_trace_set_FUNCTION
#define git_trace_set_REQUIRED_ARGC 2
#define git_trace_set_OPTIONAL_ARGC 0
/* git_trace_set
 *
 * Parameters:
 * - level: git_trace_level_t
 * - cb: git_trace_callback
 * Return Type: int
 */
mrb_value
mrb_Git_git_trace_set(mrb_state* mrb, mrb_value self) {
  mrb_int native_level;
  mrb_value cb;

  /* Fetch the args */
  mrb_get_args(mrb, "io", &native_level, &cb);

  /* Type checking */
  TODO_type_check_git_trace_callback(cb);

  /* Unbox param: cb */
  git_trace_callback native_cb = TODO_mruby_unbox_git_trace_callback(cb);

  /* Invocation */
  int native_return_value = git_trace_set(native_level, native_cb);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_commit */
/* sha: 8088424df500e7ad7f621301a2b2782f96aaa451a59ace7e546a6daa06f0adbb */
#if BIND_git_transaction_commit_FUNCTION
#define git_transaction_commit_REQUIRED_ARGC 1
#define git_transaction_commit_OPTIONAL_ARGC 0
/* git_transaction_commit
 *
 * Parameters:
 * - tx: git_transaction *
 * Return Type: int
 */
mrb_value
mrb_Git_git_transaction_commit(mrb_state* mrb, mrb_value self) {
  mrb_value tx;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tx, Transaction_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Transaction expected");
    return mrb_nil_value();
  }

  /* Unbox param: tx */
  git_transaction * native_tx = (mrb_nil_p(tx) ? NULL : mruby_unbox_git_transaction(tx));

  /* Invocation */
  int native_return_value = git_transaction_commit(native_tx);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_free */
/* sha: 8d5000522bc4eef74bc023782b7100e54b64c10826ad1b890b215a6d8e8c3839 */
#if BIND_git_transaction_free_FUNCTION
#define git_transaction_free_REQUIRED_ARGC 1
#define git_transaction_free_OPTIONAL_ARGC 0
/* git_transaction_free
 *
 * Parameters:
 * - tx: git_transaction *
 * Return Type: void
 */
mrb_value
mrb_Git_git_transaction_free(mrb_state* mrb, mrb_value self) {
  mrb_value tx;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tx, Transaction_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Transaction expected");
    return mrb_nil_value();
  }

  /* Unbox param: tx */
  git_transaction * native_tx = (mrb_nil_p(tx) ? NULL : mruby_unbox_git_transaction(tx));

  /* Invocation */
  git_transaction_free(native_tx);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_lock_ref */
/* sha: 922db4631793f975aab90026086be18ba063021781a1724f2685dd21fa8ae5d0 */
#if BIND_git_transaction_lock_ref_FUNCTION
#define git_transaction_lock_ref_REQUIRED_ARGC 2
#define git_transaction_lock_ref_OPTIONAL_ARGC 0
/* git_transaction_lock_ref
 *
 * Parameters:
 * - tx: git_transaction *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_transaction_lock_ref(mrb_state* mrb, mrb_value self) {
  mrb_value tx;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &tx, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tx, Transaction_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Transaction expected");
    return mrb_nil_value();
  }

  /* Unbox param: tx */
  git_transaction * native_tx = (mrb_nil_p(tx) ? NULL : mruby_unbox_git_transaction(tx));

  /* Invocation */
  int native_return_value = git_transaction_lock_ref(native_tx, native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_new */
/* sha: ed7ca112b7c92b18119772fa2d701bfb83acf308f04b6d0557b5319c52a344c9 */
#if BIND_git_transaction_new_FUNCTION
#define git_transaction_new_REQUIRED_ARGC 1
#define git_transaction_new_OPTIONAL_ARGC 0
/* git_transaction_new
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_transaction_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_transaction * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_transaction_new(&native_out, native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_transaction(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_remove */
/* sha: 6d89ce9697da247d66f08fa597f68abf5b233424357b5e91d75573c44c1e0ff7 */
#if BIND_git_transaction_remove_FUNCTION
#define git_transaction_remove_REQUIRED_ARGC 2
#define git_transaction_remove_OPTIONAL_ARGC 0
/* git_transaction_remove
 *
 * Parameters:
 * - tx: git_transaction *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_transaction_remove(mrb_state* mrb, mrb_value self) {
  mrb_value tx;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &tx, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tx, Transaction_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Transaction expected");
    return mrb_nil_value();
  }

  /* Unbox param: tx */
  git_transaction * native_tx = (mrb_nil_p(tx) ? NULL : mruby_unbox_git_transaction(tx));

  /* Invocation */
  int native_return_value = git_transaction_remove(native_tx, native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_set_reflog */
/* sha: d04922e7bd7290306aa962b9fd2c39e26266c20d05dad0854382b752492ef900 */
#if BIND_git_transaction_set_reflog_FUNCTION
#define git_transaction_set_reflog_REQUIRED_ARGC 3
#define git_transaction_set_reflog_OPTIONAL_ARGC 0
/* git_transaction_set_reflog
 *
 * Parameters:
 * - tx: git_transaction *
 * - refname: const char *
 * - reflog: const git_reflog *
 * Return Type: int
 */
mrb_value
mrb_Git_git_transaction_set_reflog(mrb_state* mrb, mrb_value self) {
  mrb_value tx;
  char * native_refname = NULL;
  mrb_value reflog;

  /* Fetch the args */
  mrb_get_args(mrb, "ozo", &tx, &native_refname, &reflog);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tx, Transaction_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Transaction expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, reflog, Reflog_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reflog expected");
    return mrb_nil_value();
  }

  /* Unbox param: tx */
  git_transaction * native_tx = (mrb_nil_p(tx) ? NULL : mruby_unbox_git_transaction(tx));

  /* Unbox param: reflog */
  const git_reflog * native_reflog = (mrb_nil_p(reflog) ? NULL : mruby_unbox_git_reflog(reflog));

  /* Invocation */
  int native_return_value = git_transaction_set_reflog(native_tx, native_refname, native_reflog);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_set_symbolic_target */
/* sha: daf707fd5afacd87fd5332000c4dcccba99b1eca5faba252f5cb48f450e0555e */
#if BIND_git_transaction_set_symbolic_target_FUNCTION
#define git_transaction_set_symbolic_target_REQUIRED_ARGC 5
#define git_transaction_set_symbolic_target_OPTIONAL_ARGC 0
/* git_transaction_set_symbolic_target
 *
 * Parameters:
 * - tx: git_transaction *
 * - refname: const char *
 * - target: const char *
 * - sig: const git_signature *
 * - msg: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_transaction_set_symbolic_target(mrb_state* mrb, mrb_value self) {
  mrb_value tx;
  char * native_refname = NULL;
  char * native_target = NULL;
  mrb_value sig;
  char * native_msg = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzoz", &tx, &native_refname, &native_target, &sig, &native_msg);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tx, Transaction_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Transaction expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, sig, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: tx */
  git_transaction * native_tx = (mrb_nil_p(tx) ? NULL : mruby_unbox_git_transaction(tx));

  /* Unbox param: sig */
  const git_signature * native_sig = (mrb_nil_p(sig) ? NULL : mruby_unbox_git_signature(sig));

  /* Invocation */
  int native_return_value = git_transaction_set_symbolic_target(native_tx, native_refname, native_target, native_sig, native_msg);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_set_target */
/* sha: 3bc186a6126b4a5d764e0a9fabc8ed21f1e113f8521bba00cc8ffb4d8082ed26 */
#if BIND_git_transaction_set_target_FUNCTION
#define git_transaction_set_target_REQUIRED_ARGC 5
#define git_transaction_set_target_OPTIONAL_ARGC 0
/* git_transaction_set_target
 *
 * Parameters:
 * - tx: git_transaction *
 * - refname: const char *
 * - target: const git_oid *
 * - sig: const git_signature *
 * - msg: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_transaction_set_target(mrb_state* mrb, mrb_value self) {
  mrb_value tx;
  char * native_refname = NULL;
  mrb_value target;
  mrb_value sig;
  char * native_msg = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozooz", &tx, &native_refname, &target, &sig, &native_msg);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tx, Transaction_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Transaction expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, sig, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: tx */
  git_transaction * native_tx = (mrb_nil_p(tx) ? NULL : mruby_unbox_git_transaction(tx));

  /* Unbox param: target */
  const git_oid * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_oid(target));

  /* Unbox param: sig */
  const git_signature * native_sig = (mrb_nil_p(sig) ? NULL : mruby_unbox_git_signature(sig));

  /* Invocation */
  int native_return_value = git_transaction_set_target(native_tx, native_refname, native_target, native_sig, native_msg);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_byid */
/* sha: 8c9e6eef07d1cfaff3f1ab51953d666f17eeff46a863af28b0ef80685a79c74d */
#if BIND_git_tree_entry_byid_FUNCTION
#define git_tree_entry_byid_REQUIRED_ARGC 2
#define git_tree_entry_byid_OPTIONAL_ARGC 0
/* git_tree_entry_byid
 *
 * Parameters:
 * - tree: const git_tree *
 * - id: const git_oid *
 * Return Type: const git_tree_entry *
 */
mrb_value
mrb_Git_git_tree_entry_byid(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &tree, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  const git_tree_entry * native_return_value = git_tree_entry_byid(native_tree, native_id);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_tree_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_byindex */
/* sha: 6b7931048fe5ad835e635f6830b956577abdb67f11ca10bc2cfaf5a96f071236 */
#if BIND_git_tree_entry_byindex_FUNCTION
#define git_tree_entry_byindex_REQUIRED_ARGC 2
#define git_tree_entry_byindex_OPTIONAL_ARGC 0
/* git_tree_entry_byindex
 *
 * Parameters:
 * - tree: const git_tree *
 * - idx: size_t
 * Return Type: const git_tree_entry *
 */
mrb_value
mrb_Git_git_tree_entry_byindex(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  mrb_int native_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &tree, &native_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  const git_tree_entry * native_return_value = git_tree_entry_byindex(native_tree, native_idx);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_tree_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_byname */
/* sha: e2897318c4af374cddf92afaad1877b4431c29305ad7a3ab31cdafddfee68c25 */
#if BIND_git_tree_entry_byname_FUNCTION
#define git_tree_entry_byname_REQUIRED_ARGC 2
#define git_tree_entry_byname_OPTIONAL_ARGC 0
/* git_tree_entry_byname
 *
 * Parameters:
 * - tree: const git_tree *
 * - filename: const char *
 * Return Type: const git_tree_entry *
 */
mrb_value
mrb_Git_git_tree_entry_byname(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  char * native_filename = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &tree, &native_filename);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  const git_tree_entry * native_return_value = git_tree_entry_byname(native_tree, native_filename);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_tree_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_bypath */
/* sha: ef4c56f4e35f58f820b9871d51630a6b9dadd94485a0d7b37c622a859f1eab01 */
#if BIND_git_tree_entry_bypath_FUNCTION
#define git_tree_entry_bypath_REQUIRED_ARGC 2
#define git_tree_entry_bypath_OPTIONAL_ARGC 0
/* git_tree_entry_bypath
 *
 * Parameters:
 * - root: const git_tree *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tree_entry_bypath(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_tree_entry * native_out = NULL;
  mrb_value root;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &root, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, root, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: root */
  const git_tree * native_root = (mrb_nil_p(root) ? NULL : mruby_unbox_git_tree(root));

  /* Invocation */
  int native_return_value = git_tree_entry_bypath(&native_out, native_root, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_tree_entry(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_cmp */
/* sha: 2804fd727f9b2116638292104ce200dd65504f8f6c0ba43e3004c7f518d63877 */
#if BIND_git_tree_entry_cmp_FUNCTION
#define git_tree_entry_cmp_REQUIRED_ARGC 2
#define git_tree_entry_cmp_OPTIONAL_ARGC 0
/* git_tree_entry_cmp
 *
 * Parameters:
 * - e1: const git_tree_entry *
 * - e2: const git_tree_entry *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tree_entry_cmp(mrb_state* mrb, mrb_value self) {
  mrb_value e1;
  mrb_value e2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &e1, &e2);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, e1, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, e2, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: e1 */
  const git_tree_entry * native_e1 = (mrb_nil_p(e1) ? NULL : mruby_unbox_git_tree_entry(e1));

  /* Unbox param: e2 */
  const git_tree_entry * native_e2 = (mrb_nil_p(e2) ? NULL : mruby_unbox_git_tree_entry(e2));

  /* Invocation */
  int native_return_value = git_tree_entry_cmp(native_e1, native_e2);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_dup */
/* sha: a46475fd8380d392d2684cbf6e659752c31b47021c025f76c004a8c7b7833883 */
#if BIND_git_tree_entry_dup_FUNCTION
#define git_tree_entry_dup_REQUIRED_ARGC 1
#define git_tree_entry_dup_OPTIONAL_ARGC 0
/* git_tree_entry_dup
 *
 * Parameters:
 * - source: const git_tree_entry *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tree_entry_dup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_tree_entry * native_dest = NULL;
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: source */
  const git_tree_entry * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox_git_tree_entry(source));

  /* Invocation */
  int native_return_value = git_tree_entry_dup(&native_dest, native_source);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: dest */
  mrb_value dest = native_dest == NULL ? mrb_nil_value() : mruby_giftwrap_git_tree_entry(mrb, native_dest);

  /* Add out params to results */
  mrb_ary_push(mrb, results, dest);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_filemode */
/* sha: 44ab0724911e8a41c53791713ecc3102374a417649ead6394b3b98856e9e3b10 */
#if BIND_git_tree_entry_filemode_FUNCTION
#define git_tree_entry_filemode_REQUIRED_ARGC 1
#define git_tree_entry_filemode_OPTIONAL_ARGC 0
/* git_tree_entry_filemode
 *
 * Parameters:
 * - entry: const git_tree_entry *
 * Return Type: git_filemode_t
 */
mrb_value
mrb_Git_git_tree_entry_filemode(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_tree_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_tree_entry(entry));

  /* Invocation */
  git_filemode_t native_return_value = git_tree_entry_filemode(native_entry);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_filemode_raw */
/* sha: 549701e385b7862e3ae4ec8ca17182d1289957c9293d3491aa424f985f1d96ef */
#if BIND_git_tree_entry_filemode_raw_FUNCTION
#define git_tree_entry_filemode_raw_REQUIRED_ARGC 1
#define git_tree_entry_filemode_raw_OPTIONAL_ARGC 0
/* git_tree_entry_filemode_raw
 *
 * Parameters:
 * - entry: const git_tree_entry *
 * Return Type: git_filemode_t
 */
mrb_value
mrb_Git_git_tree_entry_filemode_raw(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_tree_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_tree_entry(entry));

  /* Invocation */
  git_filemode_t native_return_value = git_tree_entry_filemode_raw(native_entry);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_free */
/* sha: 5e6cce9df0f46a0c5936b884fb061c69518df362f4d972f4ab050d874241b60b */
#if BIND_git_tree_entry_free_FUNCTION
#define git_tree_entry_free_REQUIRED_ARGC 1
#define git_tree_entry_free_OPTIONAL_ARGC 0
/* git_tree_entry_free
 *
 * Parameters:
 * - entry: git_tree_entry *
 * Return Type: void
 */
mrb_value
mrb_Git_git_tree_entry_free(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  git_tree_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_tree_entry(entry));

  /* Invocation */
  git_tree_entry_free(native_entry);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_id */
/* sha: 08a2fed5a60e489c1af03cac778d5dcb423e0a4f324cb0eb5d413161a4e0f7a5 */
#if BIND_git_tree_entry_id_FUNCTION
#define git_tree_entry_id_REQUIRED_ARGC 1
#define git_tree_entry_id_OPTIONAL_ARGC 0
/* git_tree_entry_id
 *
 * Parameters:
 * - entry: const git_tree_entry *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_tree_entry_id(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_tree_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_tree_entry(entry));

  /* Invocation */
  const git_oid * native_return_value = git_tree_entry_id(native_entry);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_name */
/* sha: 86e7cc1296775d3be0b9f9357f49d038d1f6942afa3c5f2cc7bc82b284fee038 */
#if BIND_git_tree_entry_name_FUNCTION
#define git_tree_entry_name_REQUIRED_ARGC 1
#define git_tree_entry_name_OPTIONAL_ARGC 0
/* git_tree_entry_name
 *
 * Parameters:
 * - entry: const git_tree_entry *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_tree_entry_name(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_tree_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_tree_entry(entry));

  /* Invocation */
  const char * native_return_value = git_tree_entry_name(native_entry);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_to_object */
/* sha: 2463dc676ce8e5af9cd70d4ef008d4cfb3ee20b724784cee02bda10a15cc8e4e */
#if BIND_git_tree_entry_to_object_FUNCTION
#define git_tree_entry_to_object_REQUIRED_ARGC 2
#define git_tree_entry_to_object_OPTIONAL_ARGC 0
/* git_tree_entry_to_object
 *
 * Parameters:
 * - repo: git_repository *
 * - entry: const git_tree_entry *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tree_entry_to_object(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_object * native_object_out = NULL;
  mrb_value repo;
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, entry, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: entry */
  const git_tree_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_tree_entry(entry));

  /* Invocation */
  int native_return_value = git_tree_entry_to_object(&native_object_out, native_repo, native_entry);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: object_out */
  mrb_value object_out = native_object_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_object_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, object_out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_type */
/* sha: 67f8b7b3660fe5268110cef6370c2d10800e7682123db8a8a5d8f1c894c3aa7f */
#if BIND_git_tree_entry_type_FUNCTION
#define git_tree_entry_type_REQUIRED_ARGC 1
#define git_tree_entry_type_OPTIONAL_ARGC 0
/* git_tree_entry_type
 *
 * Parameters:
 * - entry: const git_tree_entry *
 * Return Type: git_otype
 */
mrb_value
mrb_Git_git_tree_entry_type(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_tree_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_tree_entry(entry));

  /* Invocation */
  git_otype native_return_value = git_tree_entry_type(native_entry);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entrycount */
/* sha: 0f137dd434ebc8185fbf3610b10df1b91531e9348ad74980fba524f7aa49b2c9 */
#if BIND_git_tree_entrycount_FUNCTION
#define git_tree_entrycount_REQUIRED_ARGC 1
#define git_tree_entrycount_OPTIONAL_ARGC 0
/* git_tree_entrycount
 *
 * Parameters:
 * - tree: const git_tree *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_tree_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  size_t native_return_value = git_tree_entrycount(native_tree);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_free */
/* sha: 589d938eaecbb0439e8104c8b80e67c68741926e0805c495aff47b7932fd6438 */
#if BIND_git_tree_free_FUNCTION
#define git_tree_free_REQUIRED_ARGC 1
#define git_tree_free_OPTIONAL_ARGC 0
/* git_tree_free
 *
 * Parameters:
 * - tree: git_tree *
 * Return Type: void
 */
mrb_value
mrb_Git_git_tree_free(mrb_state* mrb, mrb_value self) {
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  git_tree_free(native_tree);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_id */
/* sha: 5c1fda02a429607a74b957ee496f403f9015a9bdb40388b4f074cb871a2a093c */
#if BIND_git_tree_id_FUNCTION
#define git_tree_id_REQUIRED_ARGC 1
#define git_tree_id_OPTIONAL_ARGC 0
/* git_tree_id
 *
 * Parameters:
 * - tree: const git_tree *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_tree_id(mrb_state* mrb, mrb_value self) {
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  const git_oid * native_return_value = git_tree_id(native_tree);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_lookup */
/* sha: 942084fadd3fcad31fab9c612be0a2c25514aef7d8446691eb8877536743ce80 */
#if BIND_git_tree_lookup_FUNCTION
#define git_tree_lookup_REQUIRED_ARGC 2
#define git_tree_lookup_OPTIONAL_ARGC 0
/* git_tree_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tree_lookup(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_tree * native_out = NULL;
  mrb_value repo;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_tree_lookup(&native_out, native_repo, native_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_tree(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_lookup_prefix */
/* sha: 16d9b6e50c69b6625ec829dc2a74cec4161fe7f27519f4263e7394436a1f9989 */
#if BIND_git_tree_lookup_prefix_FUNCTION
#define git_tree_lookup_prefix_REQUIRED_ARGC 3
#define git_tree_lookup_prefix_OPTIONAL_ARGC 0
/* git_tree_lookup_prefix
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_tree_lookup_prefix(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_tree * native_out = NULL;
  mrb_value repo;
  mrb_value id;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &repo, &id, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_tree_lookup_prefix(&native_out, native_repo, native_id, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_tree(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_owner */
/* sha: 6f022cbaa2c4812e98987ac81685e04ce87b3be89b41f1d9e288cd0bcffc88c3 */
#if BIND_git_tree_owner_FUNCTION
#define git_tree_owner_REQUIRED_ARGC 1
#define git_tree_owner_OPTIONAL_ARGC 0
/* git_tree_owner
 *
 * Parameters:
 * - tree: const git_tree *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_tree_owner(mrb_state* mrb, mrb_value self) {
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  git_repository * native_return_value = git_tree_owner(native_tree);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_walk */
/* sha: 4de2b97266adff4730c0193e1d1be25cef6f2a79371be906c299a01239214f5b */
#if BIND_git_tree_walk_FUNCTION
#define git_tree_walk_REQUIRED_ARGC 4
#define git_tree_walk_OPTIONAL_ARGC 0
/* git_tree_walk
 *
 * Parameters:
 * - tree: const git_tree *
 * - mode: git_treewalk_mode
 * - callback: git_treewalk_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tree_walk(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  mrb_int native_mode;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &tree, &native_mode, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_treewalk_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Unbox param: callback */
  git_treewalk_cb native_callback = TODO_mruby_unbox_git_treewalk_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_tree_walk(native_tree, native_mode, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_clear */
/* sha: 3fe286f018467237aac6ba902b27cf542eab63b1dbb1936947421fb6668946e1 */
#if BIND_git_treebuilder_clear_FUNCTION
#define git_treebuilder_clear_REQUIRED_ARGC 1
#define git_treebuilder_clear_OPTIONAL_ARGC 0
/* git_treebuilder_clear
 *
 * Parameters:
 * - bld: git_treebuilder *
 * Return Type: void
 */
mrb_value
mrb_Git_git_treebuilder_clear(mrb_state* mrb, mrb_value self) {
  mrb_value bld;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &bld);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Invocation */
  git_treebuilder_clear(native_bld);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_entrycount */
/* sha: 43b6e9896bcae861f69a294ab6f4e6a82c69bd3aff3a0a128b256d8619442f52 */
#if BIND_git_treebuilder_entrycount_FUNCTION
#define git_treebuilder_entrycount_REQUIRED_ARGC 1
#define git_treebuilder_entrycount_OPTIONAL_ARGC 0
/* git_treebuilder_entrycount
 *
 * Parameters:
 * - bld: git_treebuilder *
 * Return Type: unsigned int
 */
mrb_value
mrb_Git_git_treebuilder_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value bld;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &bld);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Invocation */
  unsigned int native_return_value = git_treebuilder_entrycount(native_bld);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_filter */
/* sha: 722b45e83c9685f6055bc616faf69da775be2ab0179352c34c42078cd7f680e0 */
#if BIND_git_treebuilder_filter_FUNCTION
#define git_treebuilder_filter_REQUIRED_ARGC 3
#define git_treebuilder_filter_OPTIONAL_ARGC 0
/* git_treebuilder_filter
 *
 * Parameters:
 * - bld: git_treebuilder *
 * - filter: git_treebuilder_filter_cb
 * - payload: void *
 * Return Type: void
 */
mrb_value
mrb_Git_git_treebuilder_filter(mrb_state* mrb, mrb_value self) {
  mrb_value bld;
  mrb_value filter;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &bld, &filter, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_treebuilder_filter_cb(filter);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Unbox param: filter */
  git_treebuilder_filter_cb native_filter = TODO_mruby_unbox_git_treebuilder_filter_cb(filter);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  git_treebuilder_filter(native_bld, native_filter, native_payload);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_free */
/* sha: c101f519dc85a10026fc4a2f3dd097d538550a4465257076886c38133fcf922b */
#if BIND_git_treebuilder_free_FUNCTION
#define git_treebuilder_free_REQUIRED_ARGC 1
#define git_treebuilder_free_OPTIONAL_ARGC 0
/* git_treebuilder_free
 *
 * Parameters:
 * - bld: git_treebuilder *
 * Return Type: void
 */
mrb_value
mrb_Git_git_treebuilder_free(mrb_state* mrb, mrb_value self) {
  mrb_value bld;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &bld);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Invocation */
  git_treebuilder_free(native_bld);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_get */
/* sha: 505e47f26d0f8c1fc1bce13e885bfe5467025e33cb20a16707e79473d15dce0a */
#if BIND_git_treebuilder_get_FUNCTION
#define git_treebuilder_get_REQUIRED_ARGC 2
#define git_treebuilder_get_OPTIONAL_ARGC 0
/* git_treebuilder_get
 *
 * Parameters:
 * - bld: git_treebuilder *
 * - filename: const char *
 * Return Type: const git_tree_entry *
 */
mrb_value
mrb_Git_git_treebuilder_get(mrb_state* mrb, mrb_value self) {
  mrb_value bld;
  char * native_filename = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &bld, &native_filename);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Invocation */
  const git_tree_entry * native_return_value = git_treebuilder_get(native_bld, native_filename);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_tree_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_insert */
/* sha: 82a227710ac456cdef149125c8db907fdbc353fb5eb6c237c8c9387cc3b0a46c */
#if BIND_git_treebuilder_insert_FUNCTION
#define git_treebuilder_insert_REQUIRED_ARGC 4
#define git_treebuilder_insert_OPTIONAL_ARGC 0
/* git_treebuilder_insert
 *
 * Parameters:
 * - bld: git_treebuilder *
 * - filename: const char *
 * - id: const git_oid *
 * - filemode: git_filemode_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_treebuilder_insert(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_tree_entry * native_out;
  mrb_value bld;
  char * native_filename = NULL;
  mrb_value id;
  mrb_int native_filemode;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoi", &bld, &native_filename, &id, &native_filemode);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_treebuilder_insert(&native_out, native_bld, native_filename, native_id, native_filemode);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = mruby_box_git_tree_entry(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_new */
/* sha: 21302eaf5a0065fc1cf137bc5e9977abb5a870086d3cf5a5a81135bf5bb298af */
#if BIND_git_treebuilder_new_FUNCTION
#define git_treebuilder_new_REQUIRED_ARGC 2
#define git_treebuilder_new_OPTIONAL_ARGC 0
/* git_treebuilder_new
 *
 * Parameters:
 * - repo: git_repository *
 * - source: const git_tree *
 * Return Type: int
 */
mrb_value
mrb_Git_git_treebuilder_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_treebuilder * native_out = NULL;
  mrb_value repo;
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, source, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: source */
  const git_tree * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox_git_tree(source));

  /* Invocation */
  int native_return_value = git_treebuilder_new(&native_out, native_repo, native_source);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_treebuilder(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_remove */
/* sha: 289b608683758406552e71505aa0aeb101c8e3f3f519442f853b526dfa6a079b */
#if BIND_git_treebuilder_remove_FUNCTION
#define git_treebuilder_remove_REQUIRED_ARGC 2
#define git_treebuilder_remove_OPTIONAL_ARGC 0
/* git_treebuilder_remove
 *
 * Parameters:
 * - bld: git_treebuilder *
 * - filename: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_treebuilder_remove(mrb_state* mrb, mrb_value self) {
  mrb_value bld;
  char * native_filename = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &bld, &native_filename);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Invocation */
  int native_return_value = git_treebuilder_remove(native_bld, native_filename);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_write */
/* sha: d37e50cad810a5e3852bb73354493d77c02eeabd20b7c678d72ce7f6c0df24d5 */
#if BIND_git_treebuilder_write_FUNCTION
#define git_treebuilder_write_REQUIRED_ARGC 2
#define git_treebuilder_write_OPTIONAL_ARGC 0
/* git_treebuilder_write
 *
 * Parameters:
 * - id: git_oid *
 * - bld: git_treebuilder *
 * Return Type: int
 */
mrb_value
mrb_Git_git_treebuilder_write(mrb_state* mrb, mrb_value self) {
  mrb_value id;
  mrb_value bld;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &id, &bld);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: id */
  git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Invocation */
  int native_return_value = git_treebuilder_write(native_id, native_bld);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: giterr_clear */
/* sha: f88efdc3ef04738822b48b7aa8af4c5f2040c2b9e1953ee98ae0390680f42e3a */
#if BIND_giterr_clear_FUNCTION
#define giterr_clear_REQUIRED_ARGC 0
#define giterr_clear_OPTIONAL_ARGC 0
/* giterr_clear
 *
 * Parameters: None
 * Return Type: void
 */
mrb_value
mrb_Git_giterr_clear(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  giterr_clear();

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: giterr_last */
/* sha: dcaf1211d8add052895d879e9ad87fa09aceb0a31ecdc6a53aa6e615faf19217 */
#if BIND_giterr_last_FUNCTION
#define giterr_last_REQUIRED_ARGC 0
#define giterr_last_OPTIONAL_ARGC 0
/* giterr_last
 *
 * Parameters: None
 * Return Type: const git_error *
 */
mrb_value
mrb_Git_giterr_last(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  const git_error * native_return_value = giterr_last();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_error(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: giterr_set_oom */
/* sha: d9aa95593a2e7e9fc83ee2ef2e99d484dfbc03ef4c309988b095ea68725bbc8b */
#if BIND_giterr_set_oom_FUNCTION
#define giterr_set_oom_REQUIRED_ARGC 0
#define giterr_set_oom_OPTIONAL_ARGC 0
/* giterr_set_oom
 *
 * Parameters: None
 * Return Type: void
 */
mrb_value
mrb_Git_giterr_set_oom(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  giterr_set_oom();

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: giterr_set_str */
/* sha: 75b90fea1ffef69b929a521c6a47187fb536ab5290c48bda2d8f3a9e703573f9 */
#if BIND_giterr_set_str_FUNCTION
#define giterr_set_str_REQUIRED_ARGC 2
#define giterr_set_str_OPTIONAL_ARGC 0
/* giterr_set_str
 *
 * Parameters:
 * - error_class: int
 * - string: const char *
 * Return Type: void
 */
mrb_value
mrb_Git_giterr_set_str(mrb_state* mrb, mrb_value self) {
  mrb_int native_error_class;
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "iz", &native_error_class, &native_string);

  /* Invocation */
  giterr_set_str(native_error_class, native_string);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: imaxdiv */
/* sha: ddb792afe5b5fd82a0a55acc5708adf28546d069d99d56d5718f0ce773017319 */
#if BIND_imaxdiv_FUNCTION
#define imaxdiv_REQUIRED_ARGC 2
#define imaxdiv_OPTIONAL_ARGC 0
/* imaxdiv
 *
 * Parameters:
 * - numer: intmax_t
 * - denom: intmax_t
 * Return Type: int
 */
mrb_value
mrb_Git_imaxdiv(mrb_state* mrb, mrb_value self) {
  mrb_int native_numer;
  mrb_int native_denom;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_numer, &native_denom);

  /* Invocation */
  imaxdiv_t native_return_value = imaxdiv(native_numer, native_denom);
  
  /* TODO: box & return */
}
#endif
/* MRUBY_BINDING_END */


void mrb_mruby_git_gem_init(mrb_state* mrb) {
/* MRUBY_BINDING: pre_module_definition */
/* sha: user_defined */

/* MRUBY_BINDING_END */
  
  struct RClass* Git_module = mrb_define_module(mrb, "Git");
  mruby_Git_define_macro_constants(mrb);
  mruby_Git_define_enum_constants(mrb);

/* MRUBY_BINDING: pre_class_initializations */
/* sha: user_defined */

/* MRUBY_BINDING_END */

/* MRUBY_BINDING: class_initializations */
/* sha: 3bc4c761a5fe8b8ef2822567ea860258a93c5c8650c2090060c1bb1353ed5655 */
#if BIND_AnnotatedCommit_TYPE
  mrb_Git_AnnotatedCommit_init(mrb);
#endif
#if BIND_Blame_TYPE
  mrb_Git_Blame_init(mrb);
#endif
#if BIND_BlameHunk_TYPE
  mrb_Git_BlameHunk_init(mrb);
#endif
#if BIND_BlameOptions_TYPE
  mrb_Git_BlameOptions_init(mrb);
#endif
#if BIND_Blob_TYPE
  mrb_Git_Blob_init(mrb);
#endif
#if BIND_BranchIterator_TYPE
  mrb_Git_BranchIterator_init(mrb);
#endif
#if BIND_Buf_TYPE
  mrb_Git_Buf_init(mrb);
#endif
#if BIND_Cert_TYPE
  mrb_Git_Cert_init(mrb);
#endif
#if BIND_CertHostkey_TYPE
  mrb_Git_CertHostkey_init(mrb);
#endif
#if BIND_CertX509_TYPE
  mrb_Git_CertX509_init(mrb);
#endif
#if BIND_CheckoutOptions_TYPE
  mrb_Git_CheckoutOptions_init(mrb);
#endif
#if BIND_CheckoutPerfdata_TYPE
  mrb_Git_CheckoutPerfdata_init(mrb);
#endif
#if BIND_CherrypickOptions_TYPE
  mrb_Git_CherrypickOptions_init(mrb);
#endif
#if BIND_CloneOptions_TYPE
  mrb_Git_CloneOptions_init(mrb);
#endif
#if BIND_Commit_TYPE
  mrb_Git_Commit_init(mrb);
#endif
#if BIND_Config_TYPE
  mrb_Git_Config_init(mrb);
#endif
#if BIND_ConfigBackend_TYPE
  mrb_Git_ConfigBackend_init(mrb);
#endif
#if BIND_ConfigEntry_TYPE
  mrb_Git_ConfigEntry_init(mrb);
#endif
#if BIND_ConfigIterator_TYPE
  mrb_Git_ConfigIterator_init(mrb);
#endif
#if BIND_Cred_TYPE
  mrb_Git_Cred_init(mrb);
#endif
#if BIND_CredSshCustom_TYPE
  mrb_Git_CredSshCustom_init(mrb);
#endif
#if BIND_CredSshInteractive_TYPE
  mrb_Git_CredSshInteractive_init(mrb);
#endif
#if BIND_CredSshKey_TYPE
  mrb_Git_CredSshKey_init(mrb);
#endif
#if BIND_CredUsername_TYPE
  mrb_Git_CredUsername_init(mrb);
#endif
#if BIND_CredUserpassPayload_TYPE
  mrb_Git_CredUserpassPayload_init(mrb);
#endif
#if BIND_CredUserpassPlaintext_TYPE
  mrb_Git_CredUserpassPlaintext_init(mrb);
#endif
#if BIND_CvarMap_TYPE
  mrb_Git_CvarMap_init(mrb);
#endif
#if BIND_DescribeFormatOptions_TYPE
  mrb_Git_DescribeFormatOptions_init(mrb);
#endif
#if BIND_DescribeOptions_TYPE
  mrb_Git_DescribeOptions_init(mrb);
#endif
#if BIND_DescribeResult_TYPE
  mrb_Git_DescribeResult_init(mrb);
#endif
#if BIND_Diff_TYPE
  mrb_Git_Diff_init(mrb);
#endif
#if BIND_DiffBinary_TYPE
  mrb_Git_DiffBinary_init(mrb);
#endif
#if BIND_DiffBinaryFile_TYPE
  mrb_Git_DiffBinaryFile_init(mrb);
#endif
#if BIND_DiffDelta_TYPE
  mrb_Git_DiffDelta_init(mrb);
#endif
#if BIND_DiffFile_TYPE
  mrb_Git_DiffFile_init(mrb);
#endif
#if BIND_DiffFindOptions_TYPE
  mrb_Git_DiffFindOptions_init(mrb);
#endif
#if BIND_DiffFormatEmailOptions_TYPE
  mrb_Git_DiffFormatEmailOptions_init(mrb);
#endif
#if BIND_DiffHunk_TYPE
  mrb_Git_DiffHunk_init(mrb);
#endif
#if BIND_DiffLine_TYPE
  mrb_Git_DiffLine_init(mrb);
#endif
#if BIND_DiffOptions_TYPE
  mrb_Git_DiffOptions_init(mrb);
#endif
#if BIND_DiffSimilarityMetric_TYPE
  mrb_Git_DiffSimilarityMetric_init(mrb);
#endif
#if BIND_DiffStats_TYPE
  mrb_Git_DiffStats_init(mrb);
#endif
#if BIND_Error_TYPE
  mrb_Git_Error_init(mrb);
#endif
#if BIND_FetchOptions_TYPE
  mrb_Git_FetchOptions_init(mrb);
#endif
#if BIND_Filter_TYPE
  mrb_Git_Filter_init(mrb);
#endif
#if BIND_FilterList_TYPE
  mrb_Git_FilterList_init(mrb);
#endif
#if BIND_ImaxdivT_TYPE
  mrb_Git_ImaxdivT_init(mrb);
#endif
#if BIND_Index_TYPE
  mrb_Git_Index_init(mrb);
#endif
#if BIND_IndexConflictIterator_TYPE
  mrb_Git_IndexConflictIterator_init(mrb);
#endif
#if BIND_IndexEntry_TYPE
  mrb_Git_IndexEntry_init(mrb);
#endif
#if BIND_Indexer_TYPE
  mrb_Git_Indexer_init(mrb);
#endif
#if BIND_IndexTime_TYPE
  mrb_Git_IndexTime_init(mrb);
#endif
#if BIND_LIBSSH2SESSION_TYPE
  mrb_Git_LIBSSH2SESSION_init(mrb);
#endif
#if BIND_LIBSSH2USERAUTHKBDINTPROMPT_TYPE
  mrb_Git_LIBSSH2USERAUTHKBDINTPROMPT_init(mrb);
#endif
#if BIND_LIBSSH2USERAUTHKBDINTRESPONSE_TYPE
  mrb_Git_LIBSSH2USERAUTHKBDINTRESPONSE_init(mrb);
#endif
#if BIND_MergeFileInput_TYPE
  mrb_Git_MergeFileInput_init(mrb);
#endif
#if BIND_MergeFileOptions_TYPE
  mrb_Git_MergeFileOptions_init(mrb);
#endif
#if BIND_MergeFileResult_TYPE
  mrb_Git_MergeFileResult_init(mrb);
#endif
#if BIND_MergeOptions_TYPE
  mrb_Git_MergeOptions_init(mrb);
#endif
#if BIND_MergeResult_TYPE
  mrb_Git_MergeResult_init(mrb);
#endif
#if BIND_Note_TYPE
  mrb_Git_Note_init(mrb);
#endif
#if BIND_NoteIterator_TYPE
  mrb_Git_NoteIterator_init(mrb);
#endif
#if BIND_Object_TYPE
  mrb_Git_Object_init(mrb);
#endif
#if BIND_Odb_TYPE
  mrb_Git_Odb_init(mrb);
#endif
#if BIND_OdbBackend_TYPE
  mrb_Git_OdbBackend_init(mrb);
#endif
#if BIND_OdbObject_TYPE
  mrb_Git_OdbObject_init(mrb);
#endif
#if BIND_OdbStream_TYPE
  mrb_Git_OdbStream_init(mrb);
#endif
#if BIND_OdbWritepack_TYPE
  mrb_Git_OdbWritepack_init(mrb);
#endif
#if BIND_Oid_TYPE
  mrb_Git_Oid_init(mrb);
#endif
#if BIND_Oidarray_TYPE
  mrb_Git_Oidarray_init(mrb);
#endif
#if BIND_OidShorten_TYPE
  mrb_Git_OidShorten_init(mrb);
#endif
#if BIND_Packbuilder_TYPE
  mrb_Git_Packbuilder_init(mrb);
#endif
#if BIND_Patch_TYPE
  mrb_Git_Patch_init(mrb);
#endif
#if BIND_Pathspec_TYPE
  mrb_Git_Pathspec_init(mrb);
#endif
#if BIND_PathspecMatchList_TYPE
  mrb_Git_PathspecMatchList_init(mrb);
#endif
#if BIND_Push_TYPE
  mrb_Git_Push_init(mrb);
#endif
#if BIND_PushOptions_TYPE
  mrb_Git_PushOptions_init(mrb);
#endif
#if BIND_PushUpdate_TYPE
  mrb_Git_PushUpdate_init(mrb);
#endif
#if BIND_Rebase_TYPE
  mrb_Git_Rebase_init(mrb);
#endif
#if BIND_RebaseOperation_TYPE
  mrb_Git_RebaseOperation_init(mrb);
#endif
#if BIND_RebaseOptions_TYPE
  mrb_Git_RebaseOptions_init(mrb);
#endif
#if BIND_Refdb_TYPE
  mrb_Git_Refdb_init(mrb);
#endif
#if BIND_RefdbBackend_TYPE
  mrb_Git_RefdbBackend_init(mrb);
#endif
#if BIND_Reference_TYPE
  mrb_Git_Reference_init(mrb);
#endif
#if BIND_ReferenceIterator_TYPE
  mrb_Git_ReferenceIterator_init(mrb);
#endif
#if BIND_Reflog_TYPE
  mrb_Git_Reflog_init(mrb);
#endif
#if BIND_ReflogEntry_TYPE
  mrb_Git_ReflogEntry_init(mrb);
#endif
#if BIND_Refspec_TYPE
  mrb_Git_Refspec_init(mrb);
#endif
#if BIND_Remote_TYPE
  mrb_Git_Remote_init(mrb);
#endif
#if BIND_RemoteCallbacks_TYPE
  mrb_Git_RemoteCallbacks_init(mrb);
#endif
#if BIND_RemoteHead_TYPE
  mrb_Git_RemoteHead_init(mrb);
#endif
#if BIND_Repository_TYPE
  mrb_Git_Repository_init(mrb);
#endif
#if BIND_RepositoryInitOptions_TYPE
  mrb_Git_RepositoryInitOptions_init(mrb);
#endif
#if BIND_RevertOptions_TYPE
  mrb_Git_RevertOptions_init(mrb);
#endif
#if BIND_Revspec_TYPE
  mrb_Git_Revspec_init(mrb);
#endif
#if BIND_Revwalk_TYPE
  mrb_Git_Revwalk_init(mrb);
#endif
#if BIND_Signature_TYPE
  mrb_Git_Signature_init(mrb);
#endif
#if BIND_StashApplyOptions_TYPE
  mrb_Git_StashApplyOptions_init(mrb);
#endif
#if BIND_StatusEntry_TYPE
  mrb_Git_StatusEntry_init(mrb);
#endif
#if BIND_StatusList_TYPE
  mrb_Git_StatusList_init(mrb);
#endif
#if BIND_StatusOptions_TYPE
  mrb_Git_StatusOptions_init(mrb);
#endif
#if BIND_Strarray_TYPE
  mrb_Git_Strarray_init(mrb);
#endif
#if BIND_Submodule_TYPE
  mrb_Git_Submodule_init(mrb);
#endif
#if BIND_SubmoduleUpdateOptions_TYPE
  mrb_Git_SubmoduleUpdateOptions_init(mrb);
#endif
#if BIND_Tag_TYPE
  mrb_Git_Tag_init(mrb);
#endif
#if BIND_Time_TYPE
  mrb_Git_Time_init(mrb);
#endif
#if BIND_Transaction_TYPE
  mrb_Git_Transaction_init(mrb);
#endif
#if BIND_TransferProgress_TYPE
  mrb_Git_TransferProgress_init(mrb);
#endif
#if BIND_Transport_TYPE
  mrb_Git_Transport_init(mrb);
#endif
#if BIND_Tree_TYPE
  mrb_Git_Tree_init(mrb);
#endif
#if BIND_Treebuilder_TYPE
  mrb_Git_Treebuilder_init(mrb);
#endif
#if BIND_TreeEntry_TYPE
  mrb_Git_TreeEntry_init(mrb);
#endif
#if BIND_Writestream_TYPE
  mrb_Git_Writestream_init(mrb);
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: pre_global_function_initializations */
/* sha: user_defined */

/* MRUBY_BINDING_END */

/* MRUBY_BINDING: global_function_definitions */
/* sha: 402b5b64f2deed15d276bc184deef0adbc24147ec0ad3d39d6e577b0266fdabf */
  /*
   * Global Functions
   */
#if BIND_git_annotated_commit_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "annotated_commit_free", mrb_Git_git_annotated_commit_free, MRB_ARGS_ARG(git_annotated_commit_free_REQUIRED_ARGC, git_annotated_commit_free_OPTIONAL_ARGC));
#endif
#if BIND_git_annotated_commit_from_fetchhead_FUNCTION
  mrb_define_class_method(mrb, Git_module, "annotated_commit_from_fetchhead", mrb_Git_git_annotated_commit_from_fetchhead, MRB_ARGS_ARG(git_annotated_commit_from_fetchhead_REQUIRED_ARGC, git_annotated_commit_from_fetchhead_OPTIONAL_ARGC));
#endif
#if BIND_git_annotated_commit_from_ref_FUNCTION
  mrb_define_class_method(mrb, Git_module, "annotated_commit_from_ref", mrb_Git_git_annotated_commit_from_ref, MRB_ARGS_ARG(git_annotated_commit_from_ref_REQUIRED_ARGC, git_annotated_commit_from_ref_OPTIONAL_ARGC));
#endif
#if BIND_git_annotated_commit_from_revspec_FUNCTION
  mrb_define_class_method(mrb, Git_module, "annotated_commit_from_revspec", mrb_Git_git_annotated_commit_from_revspec, MRB_ARGS_ARG(git_annotated_commit_from_revspec_REQUIRED_ARGC, git_annotated_commit_from_revspec_OPTIONAL_ARGC));
#endif
#if BIND_git_annotated_commit_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "annotated_commit_id", mrb_Git_git_annotated_commit_id, MRB_ARGS_ARG(git_annotated_commit_id_REQUIRED_ARGC, git_annotated_commit_id_OPTIONAL_ARGC));
#endif
#if BIND_git_annotated_commit_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "annotated_commit_lookup", mrb_Git_git_annotated_commit_lookup, MRB_ARGS_ARG(git_annotated_commit_lookup_REQUIRED_ARGC, git_annotated_commit_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_attr_add_macro_FUNCTION
  mrb_define_class_method(mrb, Git_module, "attr_add_macro", mrb_Git_git_attr_add_macro, MRB_ARGS_ARG(git_attr_add_macro_REQUIRED_ARGC, git_attr_add_macro_OPTIONAL_ARGC));
#endif
#if BIND_git_attr_cache_flush_FUNCTION
  mrb_define_class_method(mrb, Git_module, "attr_cache_flush", mrb_Git_git_attr_cache_flush, MRB_ARGS_ARG(git_attr_cache_flush_REQUIRED_ARGC, git_attr_cache_flush_OPTIONAL_ARGC));
#endif
#if BIND_git_attr_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "attr_foreach", mrb_Git_git_attr_foreach, MRB_ARGS_ARG(git_attr_foreach_REQUIRED_ARGC, git_attr_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_attr_get_FUNCTION
  mrb_define_class_method(mrb, Git_module, "attr_get", mrb_Git_git_attr_get, MRB_ARGS_ARG(git_attr_get_REQUIRED_ARGC, git_attr_get_OPTIONAL_ARGC));
#endif
#if BIND_git_attr_get_many_FUNCTION
  mrb_define_class_method(mrb, Git_module, "attr_get_many", mrb_Git_git_attr_get_many, MRB_ARGS_ARG(git_attr_get_many_REQUIRED_ARGC, git_attr_get_many_OPTIONAL_ARGC));
#endif
#if BIND_git_attr_value_FUNCTION
  mrb_define_class_method(mrb, Git_module, "attr_value", mrb_Git_git_attr_value, MRB_ARGS_ARG(git_attr_value_REQUIRED_ARGC, git_attr_value_OPTIONAL_ARGC));
#endif
#if BIND_git_blame_buffer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blame_buffer", mrb_Git_git_blame_buffer, MRB_ARGS_ARG(git_blame_buffer_REQUIRED_ARGC, git_blame_buffer_OPTIONAL_ARGC));
#endif
#if BIND_git_blame_file_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blame_file", mrb_Git_git_blame_file, MRB_ARGS_ARG(git_blame_file_REQUIRED_ARGC, git_blame_file_OPTIONAL_ARGC));
#endif
#if BIND_git_blame_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blame_free", mrb_Git_git_blame_free, MRB_ARGS_ARG(git_blame_free_REQUIRED_ARGC, git_blame_free_OPTIONAL_ARGC));
#endif
#if BIND_git_blame_get_hunk_byindex_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blame_get_hunk_byindex", mrb_Git_git_blame_get_hunk_byindex, MRB_ARGS_ARG(git_blame_get_hunk_byindex_REQUIRED_ARGC, git_blame_get_hunk_byindex_OPTIONAL_ARGC));
#endif
#if BIND_git_blame_get_hunk_byline_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blame_get_hunk_byline", mrb_Git_git_blame_get_hunk_byline, MRB_ARGS_ARG(git_blame_get_hunk_byline_REQUIRED_ARGC, git_blame_get_hunk_byline_OPTIONAL_ARGC));
#endif
#if BIND_git_blame_get_hunk_count_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blame_get_hunk_count", mrb_Git_git_blame_get_hunk_count, MRB_ARGS_ARG(git_blame_get_hunk_count_REQUIRED_ARGC, git_blame_get_hunk_count_OPTIONAL_ARGC));
#endif
#if BIND_git_blame_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blame_init_options", mrb_Git_git_blame_init_options, MRB_ARGS_ARG(git_blame_init_options_REQUIRED_ARGC, git_blame_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_create_frombuffer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_create_frombuffer", mrb_Git_git_blob_create_frombuffer, MRB_ARGS_ARG(git_blob_create_frombuffer_REQUIRED_ARGC, git_blob_create_frombuffer_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_create_fromchunks_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_create_fromchunks", mrb_Git_git_blob_create_fromchunks, MRB_ARGS_ARG(git_blob_create_fromchunks_REQUIRED_ARGC, git_blob_create_fromchunks_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_create_fromdisk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_create_fromdisk", mrb_Git_git_blob_create_fromdisk, MRB_ARGS_ARG(git_blob_create_fromdisk_REQUIRED_ARGC, git_blob_create_fromdisk_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_create_fromworkdir_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_create_fromworkdir", mrb_Git_git_blob_create_fromworkdir, MRB_ARGS_ARG(git_blob_create_fromworkdir_REQUIRED_ARGC, git_blob_create_fromworkdir_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_filtered_content_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_filtered_content", mrb_Git_git_blob_filtered_content, MRB_ARGS_ARG(git_blob_filtered_content_REQUIRED_ARGC, git_blob_filtered_content_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_free", mrb_Git_git_blob_free, MRB_ARGS_ARG(git_blob_free_REQUIRED_ARGC, git_blob_free_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_id", mrb_Git_git_blob_id, MRB_ARGS_ARG(git_blob_id_REQUIRED_ARGC, git_blob_id_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_is_binary_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_is_binary", mrb_Git_git_blob_is_binary, MRB_ARGS_ARG(git_blob_is_binary_REQUIRED_ARGC, git_blob_is_binary_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_lookup", mrb_Git_git_blob_lookup, MRB_ARGS_ARG(git_blob_lookup_REQUIRED_ARGC, git_blob_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_lookup_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_lookup_prefix", mrb_Git_git_blob_lookup_prefix, MRB_ARGS_ARG(git_blob_lookup_prefix_REQUIRED_ARGC, git_blob_lookup_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_owner", mrb_Git_git_blob_owner, MRB_ARGS_ARG(git_blob_owner_REQUIRED_ARGC, git_blob_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_rawcontent_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_rawcontent", mrb_Git_git_blob_rawcontent, MRB_ARGS_ARG(git_blob_rawcontent_REQUIRED_ARGC, git_blob_rawcontent_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_rawsize_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_rawsize", mrb_Git_git_blob_rawsize, MRB_ARGS_ARG(git_blob_rawsize_REQUIRED_ARGC, git_blob_rawsize_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_create", mrb_Git_git_branch_create, MRB_ARGS_ARG(git_branch_create_REQUIRED_ARGC, git_branch_create_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_create_from_annotated_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_create_from_annotated", mrb_Git_git_branch_create_from_annotated, MRB_ARGS_ARG(git_branch_create_from_annotated_REQUIRED_ARGC, git_branch_create_from_annotated_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_delete_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_delete", mrb_Git_git_branch_delete, MRB_ARGS_ARG(git_branch_delete_REQUIRED_ARGC, git_branch_delete_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_is_head_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_is_head", mrb_Git_git_branch_is_head, MRB_ARGS_ARG(git_branch_is_head_REQUIRED_ARGC, git_branch_is_head_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_iterator_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_iterator_free", mrb_Git_git_branch_iterator_free, MRB_ARGS_ARG(git_branch_iterator_free_REQUIRED_ARGC, git_branch_iterator_free_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_iterator_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_iterator_new", mrb_Git_git_branch_iterator_new, MRB_ARGS_ARG(git_branch_iterator_new_REQUIRED_ARGC, git_branch_iterator_new_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_lookup", mrb_Git_git_branch_lookup, MRB_ARGS_ARG(git_branch_lookup_REQUIRED_ARGC, git_branch_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_move_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_move", mrb_Git_git_branch_move, MRB_ARGS_ARG(git_branch_move_REQUIRED_ARGC, git_branch_move_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_name", mrb_Git_git_branch_name, MRB_ARGS_ARG(git_branch_name_REQUIRED_ARGC, git_branch_name_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_next_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_next", mrb_Git_git_branch_next, MRB_ARGS_ARG(git_branch_next_REQUIRED_ARGC, git_branch_next_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_remote_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_remote_name", mrb_Git_git_branch_remote_name, MRB_ARGS_ARG(git_branch_remote_name_REQUIRED_ARGC, git_branch_remote_name_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_set_upstream_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_set_upstream", mrb_Git_git_branch_set_upstream, MRB_ARGS_ARG(git_branch_set_upstream_REQUIRED_ARGC, git_branch_set_upstream_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_upstream_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_upstream", mrb_Git_git_branch_upstream, MRB_ARGS_ARG(git_branch_upstream_REQUIRED_ARGC, git_branch_upstream_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_upstream_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_upstream_name", mrb_Git_git_branch_upstream_name, MRB_ARGS_ARG(git_branch_upstream_name_REQUIRED_ARGC, git_branch_upstream_name_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_upstream_remote_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_upstream_remote", mrb_Git_git_branch_upstream_remote, MRB_ARGS_ARG(git_branch_upstream_remote_REQUIRED_ARGC, git_branch_upstream_remote_OPTIONAL_ARGC));
#endif
#if BIND_git_buf_contains_nul_FUNCTION
  mrb_define_class_method(mrb, Git_module, "buf_contains_nul", mrb_Git_git_buf_contains_nul, MRB_ARGS_ARG(git_buf_contains_nul_REQUIRED_ARGC, git_buf_contains_nul_OPTIONAL_ARGC));
#endif
#if BIND_git_buf_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "buf_free", mrb_Git_git_buf_free, MRB_ARGS_ARG(git_buf_free_REQUIRED_ARGC, git_buf_free_OPTIONAL_ARGC));
#endif
#if BIND_git_buf_grow_FUNCTION
  mrb_define_class_method(mrb, Git_module, "buf_grow", mrb_Git_git_buf_grow, MRB_ARGS_ARG(git_buf_grow_REQUIRED_ARGC, git_buf_grow_OPTIONAL_ARGC));
#endif
#if BIND_git_buf_is_binary_FUNCTION
  mrb_define_class_method(mrb, Git_module, "buf_is_binary", mrb_Git_git_buf_is_binary, MRB_ARGS_ARG(git_buf_is_binary_REQUIRED_ARGC, git_buf_is_binary_OPTIONAL_ARGC));
#endif
#if BIND_git_buf_set_FUNCTION
  mrb_define_class_method(mrb, Git_module, "buf_set", mrb_Git_git_buf_set, MRB_ARGS_ARG(git_buf_set_REQUIRED_ARGC, git_buf_set_OPTIONAL_ARGC));
#endif
#if BIND_git_checkout_head_FUNCTION
  mrb_define_class_method(mrb, Git_module, "checkout_head", mrb_Git_git_checkout_head, MRB_ARGS_ARG(git_checkout_head_REQUIRED_ARGC, git_checkout_head_OPTIONAL_ARGC));
#endif
#if BIND_git_checkout_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "checkout_index", mrb_Git_git_checkout_index, MRB_ARGS_ARG(git_checkout_index_REQUIRED_ARGC, git_checkout_index_OPTIONAL_ARGC));
#endif
#if BIND_git_checkout_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "checkout_init_options", mrb_Git_git_checkout_init_options, MRB_ARGS_ARG(git_checkout_init_options_REQUIRED_ARGC, git_checkout_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_checkout_tree_FUNCTION
  mrb_define_class_method(mrb, Git_module, "checkout_tree", mrb_Git_git_checkout_tree, MRB_ARGS_ARG(git_checkout_tree_REQUIRED_ARGC, git_checkout_tree_OPTIONAL_ARGC));
#endif
#if BIND_git_cherrypick_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cherrypick", mrb_Git_git_cherrypick, MRB_ARGS_ARG(git_cherrypick_REQUIRED_ARGC, git_cherrypick_OPTIONAL_ARGC));
#endif
#if BIND_git_cherrypick_commit_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cherrypick_commit", mrb_Git_git_cherrypick_commit, MRB_ARGS_ARG(git_cherrypick_commit_REQUIRED_ARGC, git_cherrypick_commit_OPTIONAL_ARGC));
#endif
#if BIND_git_cherrypick_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cherrypick_init_options", mrb_Git_git_cherrypick_init_options, MRB_ARGS_ARG(git_cherrypick_init_options_REQUIRED_ARGC, git_cherrypick_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_clone_FUNCTION
  mrb_define_class_method(mrb, Git_module, "clone", mrb_Git_git_clone, MRB_ARGS_ARG(git_clone_REQUIRED_ARGC, git_clone_OPTIONAL_ARGC));
#endif
#if BIND_git_clone_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "clone_init_options", mrb_Git_git_clone_init_options, MRB_ARGS_ARG(git_clone_init_options_REQUIRED_ARGC, git_clone_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_amend_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_amend", mrb_Git_git_commit_amend, MRB_ARGS_ARG(git_commit_amend_REQUIRED_ARGC, git_commit_amend_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_author_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_author", mrb_Git_git_commit_author, MRB_ARGS_ARG(git_commit_author_REQUIRED_ARGC, git_commit_author_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_body_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_body", mrb_Git_git_commit_body, MRB_ARGS_ARG(git_commit_body_REQUIRED_ARGC, git_commit_body_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_committer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_committer", mrb_Git_git_commit_committer, MRB_ARGS_ARG(git_commit_committer_REQUIRED_ARGC, git_commit_committer_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_create", mrb_Git_git_commit_create, MRB_ARGS_ARG(git_commit_create_REQUIRED_ARGC, git_commit_create_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_create_v_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_create_v", mrb_Git_git_commit_create_v, MRB_ARGS_ARG(git_commit_create_v_REQUIRED_ARGC, git_commit_create_v_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_free", mrb_Git_git_commit_free, MRB_ARGS_ARG(git_commit_free_REQUIRED_ARGC, git_commit_free_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_header_field_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_header_field", mrb_Git_git_commit_header_field, MRB_ARGS_ARG(git_commit_header_field_REQUIRED_ARGC, git_commit_header_field_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_id", mrb_Git_git_commit_id, MRB_ARGS_ARG(git_commit_id_REQUIRED_ARGC, git_commit_id_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_lookup", mrb_Git_git_commit_lookup, MRB_ARGS_ARG(git_commit_lookup_REQUIRED_ARGC, git_commit_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_lookup_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_lookup_prefix", mrb_Git_git_commit_lookup_prefix, MRB_ARGS_ARG(git_commit_lookup_prefix_REQUIRED_ARGC, git_commit_lookup_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_message_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_message", mrb_Git_git_commit_message, MRB_ARGS_ARG(git_commit_message_REQUIRED_ARGC, git_commit_message_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_message_encoding_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_message_encoding", mrb_Git_git_commit_message_encoding, MRB_ARGS_ARG(git_commit_message_encoding_REQUIRED_ARGC, git_commit_message_encoding_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_message_raw_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_message_raw", mrb_Git_git_commit_message_raw, MRB_ARGS_ARG(git_commit_message_raw_REQUIRED_ARGC, git_commit_message_raw_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_nth_gen_ancestor_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_nth_gen_ancestor", mrb_Git_git_commit_nth_gen_ancestor, MRB_ARGS_ARG(git_commit_nth_gen_ancestor_REQUIRED_ARGC, git_commit_nth_gen_ancestor_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_owner", mrb_Git_git_commit_owner, MRB_ARGS_ARG(git_commit_owner_REQUIRED_ARGC, git_commit_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_parent_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_parent", mrb_Git_git_commit_parent, MRB_ARGS_ARG(git_commit_parent_REQUIRED_ARGC, git_commit_parent_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_parent_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_parent_id", mrb_Git_git_commit_parent_id, MRB_ARGS_ARG(git_commit_parent_id_REQUIRED_ARGC, git_commit_parent_id_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_parentcount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_parentcount", mrb_Git_git_commit_parentcount, MRB_ARGS_ARG(git_commit_parentcount_REQUIRED_ARGC, git_commit_parentcount_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_raw_header_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_raw_header", mrb_Git_git_commit_raw_header, MRB_ARGS_ARG(git_commit_raw_header_REQUIRED_ARGC, git_commit_raw_header_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_summary_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_summary", mrb_Git_git_commit_summary, MRB_ARGS_ARG(git_commit_summary_REQUIRED_ARGC, git_commit_summary_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_time_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_time", mrb_Git_git_commit_time, MRB_ARGS_ARG(git_commit_time_REQUIRED_ARGC, git_commit_time_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_time_offset_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_time_offset", mrb_Git_git_commit_time_offset, MRB_ARGS_ARG(git_commit_time_offset_REQUIRED_ARGC, git_commit_time_offset_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_tree_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_tree", mrb_Git_git_commit_tree, MRB_ARGS_ARG(git_commit_tree_REQUIRED_ARGC, git_commit_tree_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_tree_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_tree_id", mrb_Git_git_commit_tree_id, MRB_ARGS_ARG(git_commit_tree_id_REQUIRED_ARGC, git_commit_tree_id_OPTIONAL_ARGC));
#endif
#if BIND_git_config_add_file_ondisk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_add_file_ondisk", mrb_Git_git_config_add_file_ondisk, MRB_ARGS_ARG(git_config_add_file_ondisk_REQUIRED_ARGC, git_config_add_file_ondisk_OPTIONAL_ARGC));
#endif
#if BIND_git_config_backend_foreach_match_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_backend_foreach_match", mrb_Git_git_config_backend_foreach_match, MRB_ARGS_ARG(git_config_backend_foreach_match_REQUIRED_ARGC, git_config_backend_foreach_match_OPTIONAL_ARGC));
#endif
#if BIND_git_config_delete_entry_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_delete_entry", mrb_Git_git_config_delete_entry, MRB_ARGS_ARG(git_config_delete_entry_REQUIRED_ARGC, git_config_delete_entry_OPTIONAL_ARGC));
#endif
#if BIND_git_config_delete_multivar_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_delete_multivar", mrb_Git_git_config_delete_multivar, MRB_ARGS_ARG(git_config_delete_multivar_REQUIRED_ARGC, git_config_delete_multivar_OPTIONAL_ARGC));
#endif
#if BIND_git_config_entry_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_entry_free", mrb_Git_git_config_entry_free, MRB_ARGS_ARG(git_config_entry_free_REQUIRED_ARGC, git_config_entry_free_OPTIONAL_ARGC));
#endif
#if BIND_git_config_find_global_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_find_global", mrb_Git_git_config_find_global, MRB_ARGS_ARG(git_config_find_global_REQUIRED_ARGC, git_config_find_global_OPTIONAL_ARGC));
#endif
#if BIND_git_config_find_programdata_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_find_programdata", mrb_Git_git_config_find_programdata, MRB_ARGS_ARG(git_config_find_programdata_REQUIRED_ARGC, git_config_find_programdata_OPTIONAL_ARGC));
#endif
#if BIND_git_config_find_system_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_find_system", mrb_Git_git_config_find_system, MRB_ARGS_ARG(git_config_find_system_REQUIRED_ARGC, git_config_find_system_OPTIONAL_ARGC));
#endif
#if BIND_git_config_find_xdg_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_find_xdg", mrb_Git_git_config_find_xdg, MRB_ARGS_ARG(git_config_find_xdg_REQUIRED_ARGC, git_config_find_xdg_OPTIONAL_ARGC));
#endif
#if BIND_git_config_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_foreach", mrb_Git_git_config_foreach, MRB_ARGS_ARG(git_config_foreach_REQUIRED_ARGC, git_config_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_config_foreach_match_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_foreach_match", mrb_Git_git_config_foreach_match, MRB_ARGS_ARG(git_config_foreach_match_REQUIRED_ARGC, git_config_foreach_match_OPTIONAL_ARGC));
#endif
#if BIND_git_config_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_free", mrb_Git_git_config_free, MRB_ARGS_ARG(git_config_free_REQUIRED_ARGC, git_config_free_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_bool_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_bool", mrb_Git_git_config_get_bool, MRB_ARGS_ARG(git_config_get_bool_REQUIRED_ARGC, git_config_get_bool_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_entry_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_entry", mrb_Git_git_config_get_entry, MRB_ARGS_ARG(git_config_get_entry_REQUIRED_ARGC, git_config_get_entry_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_int32_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_int32", mrb_Git_git_config_get_int32, MRB_ARGS_ARG(git_config_get_int32_REQUIRED_ARGC, git_config_get_int32_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_int64_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_int64", mrb_Git_git_config_get_int64, MRB_ARGS_ARG(git_config_get_int64_REQUIRED_ARGC, git_config_get_int64_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_mapped_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_mapped", mrb_Git_git_config_get_mapped, MRB_ARGS_ARG(git_config_get_mapped_REQUIRED_ARGC, git_config_get_mapped_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_multivar_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_multivar_foreach", mrb_Git_git_config_get_multivar_foreach, MRB_ARGS_ARG(git_config_get_multivar_foreach_REQUIRED_ARGC, git_config_get_multivar_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_path_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_path", mrb_Git_git_config_get_path, MRB_ARGS_ARG(git_config_get_path_REQUIRED_ARGC, git_config_get_path_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_string_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_string", mrb_Git_git_config_get_string, MRB_ARGS_ARG(git_config_get_string_REQUIRED_ARGC, git_config_get_string_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_string_buf_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_string_buf", mrb_Git_git_config_get_string_buf, MRB_ARGS_ARG(git_config_get_string_buf_REQUIRED_ARGC, git_config_get_string_buf_OPTIONAL_ARGC));
#endif
#if BIND_git_config_iterator_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_iterator_free", mrb_Git_git_config_iterator_free, MRB_ARGS_ARG(git_config_iterator_free_REQUIRED_ARGC, git_config_iterator_free_OPTIONAL_ARGC));
#endif
#if BIND_git_config_iterator_glob_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_iterator_glob_new", mrb_Git_git_config_iterator_glob_new, MRB_ARGS_ARG(git_config_iterator_glob_new_REQUIRED_ARGC, git_config_iterator_glob_new_OPTIONAL_ARGC));
#endif
#if BIND_git_config_iterator_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_iterator_new", mrb_Git_git_config_iterator_new, MRB_ARGS_ARG(git_config_iterator_new_REQUIRED_ARGC, git_config_iterator_new_OPTIONAL_ARGC));
#endif
#if BIND_git_config_lock_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_lock", mrb_Git_git_config_lock, MRB_ARGS_ARG(git_config_lock_REQUIRED_ARGC, git_config_lock_OPTIONAL_ARGC));
#endif
#if BIND_git_config_lookup_map_value_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_lookup_map_value", mrb_Git_git_config_lookup_map_value, MRB_ARGS_ARG(git_config_lookup_map_value_REQUIRED_ARGC, git_config_lookup_map_value_OPTIONAL_ARGC));
#endif
#if BIND_git_config_multivar_iterator_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_multivar_iterator_new", mrb_Git_git_config_multivar_iterator_new, MRB_ARGS_ARG(git_config_multivar_iterator_new_REQUIRED_ARGC, git_config_multivar_iterator_new_OPTIONAL_ARGC));
#endif
#if BIND_git_config_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_new", mrb_Git_git_config_new, MRB_ARGS_ARG(git_config_new_REQUIRED_ARGC, git_config_new_OPTIONAL_ARGC));
#endif
#if BIND_git_config_next_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_next", mrb_Git_git_config_next, MRB_ARGS_ARG(git_config_next_REQUIRED_ARGC, git_config_next_OPTIONAL_ARGC));
#endif
#if BIND_git_config_open_default_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_open_default", mrb_Git_git_config_open_default, MRB_ARGS_ARG(git_config_open_default_REQUIRED_ARGC, git_config_open_default_OPTIONAL_ARGC));
#endif
#if BIND_git_config_open_global_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_open_global", mrb_Git_git_config_open_global, MRB_ARGS_ARG(git_config_open_global_REQUIRED_ARGC, git_config_open_global_OPTIONAL_ARGC));
#endif
#if BIND_git_config_open_level_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_open_level", mrb_Git_git_config_open_level, MRB_ARGS_ARG(git_config_open_level_REQUIRED_ARGC, git_config_open_level_OPTIONAL_ARGC));
#endif
#if BIND_git_config_open_ondisk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_open_ondisk", mrb_Git_git_config_open_ondisk, MRB_ARGS_ARG(git_config_open_ondisk_REQUIRED_ARGC, git_config_open_ondisk_OPTIONAL_ARGC));
#endif
#if BIND_git_config_parse_bool_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_parse_bool", mrb_Git_git_config_parse_bool, MRB_ARGS_ARG(git_config_parse_bool_REQUIRED_ARGC, git_config_parse_bool_OPTIONAL_ARGC));
#endif
#if BIND_git_config_parse_int32_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_parse_int32", mrb_Git_git_config_parse_int32, MRB_ARGS_ARG(git_config_parse_int32_REQUIRED_ARGC, git_config_parse_int32_OPTIONAL_ARGC));
#endif
#if BIND_git_config_parse_int64_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_parse_int64", mrb_Git_git_config_parse_int64, MRB_ARGS_ARG(git_config_parse_int64_REQUIRED_ARGC, git_config_parse_int64_OPTIONAL_ARGC));
#endif
#if BIND_git_config_parse_path_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_parse_path", mrb_Git_git_config_parse_path, MRB_ARGS_ARG(git_config_parse_path_REQUIRED_ARGC, git_config_parse_path_OPTIONAL_ARGC));
#endif
#if BIND_git_config_set_bool_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_set_bool", mrb_Git_git_config_set_bool, MRB_ARGS_ARG(git_config_set_bool_REQUIRED_ARGC, git_config_set_bool_OPTIONAL_ARGC));
#endif
#if BIND_git_config_set_int32_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_set_int32", mrb_Git_git_config_set_int32, MRB_ARGS_ARG(git_config_set_int32_REQUIRED_ARGC, git_config_set_int32_OPTIONAL_ARGC));
#endif
#if BIND_git_config_set_int64_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_set_int64", mrb_Git_git_config_set_int64, MRB_ARGS_ARG(git_config_set_int64_REQUIRED_ARGC, git_config_set_int64_OPTIONAL_ARGC));
#endif
#if BIND_git_config_set_multivar_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_set_multivar", mrb_Git_git_config_set_multivar, MRB_ARGS_ARG(git_config_set_multivar_REQUIRED_ARGC, git_config_set_multivar_OPTIONAL_ARGC));
#endif
#if BIND_git_config_set_string_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_set_string", mrb_Git_git_config_set_string, MRB_ARGS_ARG(git_config_set_string_REQUIRED_ARGC, git_config_set_string_OPTIONAL_ARGC));
#endif
#if BIND_git_config_snapshot_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_snapshot", mrb_Git_git_config_snapshot, MRB_ARGS_ARG(git_config_snapshot_REQUIRED_ARGC, git_config_snapshot_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_default_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_default_new", mrb_Git_git_cred_default_new, MRB_ARGS_ARG(git_cred_default_new_REQUIRED_ARGC, git_cred_default_new_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_free", mrb_Git_git_cred_free, MRB_ARGS_ARG(git_cred_free_REQUIRED_ARGC, git_cred_free_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_has_username_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_has_username", mrb_Git_git_cred_has_username, MRB_ARGS_ARG(git_cred_has_username_REQUIRED_ARGC, git_cred_has_username_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_ssh_custom_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_ssh_custom_new", mrb_Git_git_cred_ssh_custom_new, MRB_ARGS_ARG(git_cred_ssh_custom_new_REQUIRED_ARGC, git_cred_ssh_custom_new_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_ssh_interactive_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_ssh_interactive_new", mrb_Git_git_cred_ssh_interactive_new, MRB_ARGS_ARG(git_cred_ssh_interactive_new_REQUIRED_ARGC, git_cred_ssh_interactive_new_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_ssh_key_from_agent_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_ssh_key_from_agent", mrb_Git_git_cred_ssh_key_from_agent, MRB_ARGS_ARG(git_cred_ssh_key_from_agent_REQUIRED_ARGC, git_cred_ssh_key_from_agent_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_ssh_key_memory_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_ssh_key_memory_new", mrb_Git_git_cred_ssh_key_memory_new, MRB_ARGS_ARG(git_cred_ssh_key_memory_new_REQUIRED_ARGC, git_cred_ssh_key_memory_new_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_ssh_key_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_ssh_key_new", mrb_Git_git_cred_ssh_key_new, MRB_ARGS_ARG(git_cred_ssh_key_new_REQUIRED_ARGC, git_cred_ssh_key_new_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_username_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_username_new", mrb_Git_git_cred_username_new, MRB_ARGS_ARG(git_cred_username_new_REQUIRED_ARGC, git_cred_username_new_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_userpass_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_userpass", mrb_Git_git_cred_userpass, MRB_ARGS_ARG(git_cred_userpass_REQUIRED_ARGC, git_cred_userpass_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_userpass_plaintext_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_userpass_plaintext_new", mrb_Git_git_cred_userpass_plaintext_new, MRB_ARGS_ARG(git_cred_userpass_plaintext_new_REQUIRED_ARGC, git_cred_userpass_plaintext_new_OPTIONAL_ARGC));
#endif
#if BIND_git_describe_commit_FUNCTION
  mrb_define_class_method(mrb, Git_module, "describe_commit", mrb_Git_git_describe_commit, MRB_ARGS_ARG(git_describe_commit_REQUIRED_ARGC, git_describe_commit_OPTIONAL_ARGC));
#endif
#if BIND_git_describe_format_FUNCTION
  mrb_define_class_method(mrb, Git_module, "describe_format", mrb_Git_git_describe_format, MRB_ARGS_ARG(git_describe_format_REQUIRED_ARGC, git_describe_format_OPTIONAL_ARGC));
#endif
#if BIND_git_describe_init_format_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "describe_init_format_options", mrb_Git_git_describe_init_format_options, MRB_ARGS_ARG(git_describe_init_format_options_REQUIRED_ARGC, git_describe_init_format_options_OPTIONAL_ARGC));
#endif
#if BIND_git_describe_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "describe_init_options", mrb_Git_git_describe_init_options, MRB_ARGS_ARG(git_describe_init_options_REQUIRED_ARGC, git_describe_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_describe_result_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "describe_result_free", mrb_Git_git_describe_result_free, MRB_ARGS_ARG(git_describe_result_free_REQUIRED_ARGC, git_describe_result_free_OPTIONAL_ARGC));
#endif
#if BIND_git_describe_workdir_FUNCTION
  mrb_define_class_method(mrb, Git_module, "describe_workdir", mrb_Git_git_describe_workdir, MRB_ARGS_ARG(git_describe_workdir_REQUIRED_ARGC, git_describe_workdir_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_blob_to_buffer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_blob_to_buffer", mrb_Git_git_diff_blob_to_buffer, MRB_ARGS_ARG(git_diff_blob_to_buffer_REQUIRED_ARGC, git_diff_blob_to_buffer_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_blobs_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_blobs", mrb_Git_git_diff_blobs, MRB_ARGS_ARG(git_diff_blobs_REQUIRED_ARGC, git_diff_blobs_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_buffers_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_buffers", mrb_Git_git_diff_buffers, MRB_ARGS_ARG(git_diff_buffers_REQUIRED_ARGC, git_diff_buffers_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_commit_as_email_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_commit_as_email", mrb_Git_git_diff_commit_as_email, MRB_ARGS_ARG(git_diff_commit_as_email_REQUIRED_ARGC, git_diff_commit_as_email_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_find_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_find_init_options", mrb_Git_git_diff_find_init_options, MRB_ARGS_ARG(git_diff_find_init_options_REQUIRED_ARGC, git_diff_find_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_find_similar_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_find_similar", mrb_Git_git_diff_find_similar, MRB_ARGS_ARG(git_diff_find_similar_REQUIRED_ARGC, git_diff_find_similar_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_foreach", mrb_Git_git_diff_foreach, MRB_ARGS_ARG(git_diff_foreach_REQUIRED_ARGC, git_diff_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_format_email_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_format_email", mrb_Git_git_diff_format_email, MRB_ARGS_ARG(git_diff_format_email_REQUIRED_ARGC, git_diff_format_email_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_format_email_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_format_email_init_options", mrb_Git_git_diff_format_email_init_options, MRB_ARGS_ARG(git_diff_format_email_init_options_REQUIRED_ARGC, git_diff_format_email_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_free", mrb_Git_git_diff_free, MRB_ARGS_ARG(git_diff_free_REQUIRED_ARGC, git_diff_free_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_get_delta_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_get_delta", mrb_Git_git_diff_get_delta, MRB_ARGS_ARG(git_diff_get_delta_REQUIRED_ARGC, git_diff_get_delta_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_get_stats_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_get_stats", mrb_Git_git_diff_get_stats, MRB_ARGS_ARG(git_diff_get_stats_REQUIRED_ARGC, git_diff_get_stats_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_index_to_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_index_to_index", mrb_Git_git_diff_index_to_index, MRB_ARGS_ARG(git_diff_index_to_index_REQUIRED_ARGC, git_diff_index_to_index_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_index_to_workdir_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_index_to_workdir", mrb_Git_git_diff_index_to_workdir, MRB_ARGS_ARG(git_diff_index_to_workdir_REQUIRED_ARGC, git_diff_index_to_workdir_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_init_options", mrb_Git_git_diff_init_options, MRB_ARGS_ARG(git_diff_init_options_REQUIRED_ARGC, git_diff_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_is_sorted_icase_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_is_sorted_icase", mrb_Git_git_diff_is_sorted_icase, MRB_ARGS_ARG(git_diff_is_sorted_icase_REQUIRED_ARGC, git_diff_is_sorted_icase_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_merge_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_merge", mrb_Git_git_diff_merge, MRB_ARGS_ARG(git_diff_merge_REQUIRED_ARGC, git_diff_merge_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_num_deltas_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_num_deltas", mrb_Git_git_diff_num_deltas, MRB_ARGS_ARG(git_diff_num_deltas_REQUIRED_ARGC, git_diff_num_deltas_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_num_deltas_of_type_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_num_deltas_of_type", mrb_Git_git_diff_num_deltas_of_type, MRB_ARGS_ARG(git_diff_num_deltas_of_type_REQUIRED_ARGC, git_diff_num_deltas_of_type_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_print_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_print", mrb_Git_git_diff_print, MRB_ARGS_ARG(git_diff_print_REQUIRED_ARGC, git_diff_print_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_stats_deletions_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_stats_deletions", mrb_Git_git_diff_stats_deletions, MRB_ARGS_ARG(git_diff_stats_deletions_REQUIRED_ARGC, git_diff_stats_deletions_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_stats_files_changed_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_stats_files_changed", mrb_Git_git_diff_stats_files_changed, MRB_ARGS_ARG(git_diff_stats_files_changed_REQUIRED_ARGC, git_diff_stats_files_changed_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_stats_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_stats_free", mrb_Git_git_diff_stats_free, MRB_ARGS_ARG(git_diff_stats_free_REQUIRED_ARGC, git_diff_stats_free_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_stats_insertions_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_stats_insertions", mrb_Git_git_diff_stats_insertions, MRB_ARGS_ARG(git_diff_stats_insertions_REQUIRED_ARGC, git_diff_stats_insertions_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_stats_to_buf_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_stats_to_buf", mrb_Git_git_diff_stats_to_buf, MRB_ARGS_ARG(git_diff_stats_to_buf_REQUIRED_ARGC, git_diff_stats_to_buf_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_status_char_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_status_char", mrb_Git_git_diff_status_char, MRB_ARGS_ARG(git_diff_status_char_REQUIRED_ARGC, git_diff_status_char_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_tree_to_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_tree_to_index", mrb_Git_git_diff_tree_to_index, MRB_ARGS_ARG(git_diff_tree_to_index_REQUIRED_ARGC, git_diff_tree_to_index_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_tree_to_tree_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_tree_to_tree", mrb_Git_git_diff_tree_to_tree, MRB_ARGS_ARG(git_diff_tree_to_tree_REQUIRED_ARGC, git_diff_tree_to_tree_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_tree_to_workdir_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_tree_to_workdir", mrb_Git_git_diff_tree_to_workdir, MRB_ARGS_ARG(git_diff_tree_to_workdir_REQUIRED_ARGC, git_diff_tree_to_workdir_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_tree_to_workdir_with_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_tree_to_workdir_with_index", mrb_Git_git_diff_tree_to_workdir_with_index, MRB_ARGS_ARG(git_diff_tree_to_workdir_with_index_REQUIRED_ARGC, git_diff_tree_to_workdir_with_index_OPTIONAL_ARGC));
#endif
#if BIND_git_fetch_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "fetch_init_options", mrb_Git_git_fetch_init_options, MRB_ARGS_ARG(git_fetch_init_options_REQUIRED_ARGC, git_fetch_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_apply_to_blob_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_apply_to_blob", mrb_Git_git_filter_list_apply_to_blob, MRB_ARGS_ARG(git_filter_list_apply_to_blob_REQUIRED_ARGC, git_filter_list_apply_to_blob_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_apply_to_data_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_apply_to_data", mrb_Git_git_filter_list_apply_to_data, MRB_ARGS_ARG(git_filter_list_apply_to_data_REQUIRED_ARGC, git_filter_list_apply_to_data_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_apply_to_file_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_apply_to_file", mrb_Git_git_filter_list_apply_to_file, MRB_ARGS_ARG(git_filter_list_apply_to_file_REQUIRED_ARGC, git_filter_list_apply_to_file_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_contains_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_contains", mrb_Git_git_filter_list_contains, MRB_ARGS_ARG(git_filter_list_contains_REQUIRED_ARGC, git_filter_list_contains_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_free", mrb_Git_git_filter_list_free, MRB_ARGS_ARG(git_filter_list_free_REQUIRED_ARGC, git_filter_list_free_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_load_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_load", mrb_Git_git_filter_list_load, MRB_ARGS_ARG(git_filter_list_load_REQUIRED_ARGC, git_filter_list_load_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_stream_blob_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_stream_blob", mrb_Git_git_filter_list_stream_blob, MRB_ARGS_ARG(git_filter_list_stream_blob_REQUIRED_ARGC, git_filter_list_stream_blob_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_stream_data_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_stream_data", mrb_Git_git_filter_list_stream_data, MRB_ARGS_ARG(git_filter_list_stream_data_REQUIRED_ARGC, git_filter_list_stream_data_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_stream_file_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_stream_file", mrb_Git_git_filter_list_stream_file, MRB_ARGS_ARG(git_filter_list_stream_file_REQUIRED_ARGC, git_filter_list_stream_file_OPTIONAL_ARGC));
#endif
#if BIND_git_graph_ahead_behind_FUNCTION
  mrb_define_class_method(mrb, Git_module, "graph_ahead_behind", mrb_Git_git_graph_ahead_behind, MRB_ARGS_ARG(git_graph_ahead_behind_REQUIRED_ARGC, git_graph_ahead_behind_OPTIONAL_ARGC));
#endif
#if BIND_git_graph_descendant_of_FUNCTION
  mrb_define_class_method(mrb, Git_module, "graph_descendant_of", mrb_Git_git_graph_descendant_of, MRB_ARGS_ARG(git_graph_descendant_of_REQUIRED_ARGC, git_graph_descendant_of_OPTIONAL_ARGC));
#endif
#if BIND_git_ignore_add_rule_FUNCTION
  mrb_define_class_method(mrb, Git_module, "ignore_add_rule", mrb_Git_git_ignore_add_rule, MRB_ARGS_ARG(git_ignore_add_rule_REQUIRED_ARGC, git_ignore_add_rule_OPTIONAL_ARGC));
#endif
#if BIND_git_ignore_clear_internal_rules_FUNCTION
  mrb_define_class_method(mrb, Git_module, "ignore_clear_internal_rules", mrb_Git_git_ignore_clear_internal_rules, MRB_ARGS_ARG(git_ignore_clear_internal_rules_REQUIRED_ARGC, git_ignore_clear_internal_rules_OPTIONAL_ARGC));
#endif
#if BIND_git_ignore_path_is_ignored_FUNCTION
  mrb_define_class_method(mrb, Git_module, "ignore_path_is_ignored", mrb_Git_git_ignore_path_is_ignored, MRB_ARGS_ARG(git_ignore_path_is_ignored_REQUIRED_ARGC, git_ignore_path_is_ignored_OPTIONAL_ARGC));
#endif
#if BIND_git_index_add_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_add", mrb_Git_git_index_add, MRB_ARGS_ARG(git_index_add_REQUIRED_ARGC, git_index_add_OPTIONAL_ARGC));
#endif
#if BIND_git_index_add_all_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_add_all", mrb_Git_git_index_add_all, MRB_ARGS_ARG(git_index_add_all_REQUIRED_ARGC, git_index_add_all_OPTIONAL_ARGC));
#endif
#if BIND_git_index_add_bypath_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_add_bypath", mrb_Git_git_index_add_bypath, MRB_ARGS_ARG(git_index_add_bypath_REQUIRED_ARGC, git_index_add_bypath_OPTIONAL_ARGC));
#endif
#if BIND_git_index_add_frombuffer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_add_frombuffer", mrb_Git_git_index_add_frombuffer, MRB_ARGS_ARG(git_index_add_frombuffer_REQUIRED_ARGC, git_index_add_frombuffer_OPTIONAL_ARGC));
#endif
#if BIND_git_index_caps_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_caps", mrb_Git_git_index_caps, MRB_ARGS_ARG(git_index_caps_REQUIRED_ARGC, git_index_caps_OPTIONAL_ARGC));
#endif
#if BIND_git_index_checksum_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_checksum", mrb_Git_git_index_checksum, MRB_ARGS_ARG(git_index_checksum_REQUIRED_ARGC, git_index_checksum_OPTIONAL_ARGC));
#endif
#if BIND_git_index_clear_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_clear", mrb_Git_git_index_clear, MRB_ARGS_ARG(git_index_clear_REQUIRED_ARGC, git_index_clear_OPTIONAL_ARGC));
#endif
#if BIND_git_index_conflict_add_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_conflict_add", mrb_Git_git_index_conflict_add, MRB_ARGS_ARG(git_index_conflict_add_REQUIRED_ARGC, git_index_conflict_add_OPTIONAL_ARGC));
#endif
#if BIND_git_index_conflict_cleanup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_conflict_cleanup", mrb_Git_git_index_conflict_cleanup, MRB_ARGS_ARG(git_index_conflict_cleanup_REQUIRED_ARGC, git_index_conflict_cleanup_OPTIONAL_ARGC));
#endif
#if BIND_git_index_conflict_get_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_conflict_get", mrb_Git_git_index_conflict_get, MRB_ARGS_ARG(git_index_conflict_get_REQUIRED_ARGC, git_index_conflict_get_OPTIONAL_ARGC));
#endif
#if BIND_git_index_conflict_iterator_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_conflict_iterator_free", mrb_Git_git_index_conflict_iterator_free, MRB_ARGS_ARG(git_index_conflict_iterator_free_REQUIRED_ARGC, git_index_conflict_iterator_free_OPTIONAL_ARGC));
#endif
#if BIND_git_index_conflict_iterator_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_conflict_iterator_new", mrb_Git_git_index_conflict_iterator_new, MRB_ARGS_ARG(git_index_conflict_iterator_new_REQUIRED_ARGC, git_index_conflict_iterator_new_OPTIONAL_ARGC));
#endif
#if BIND_git_index_conflict_next_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_conflict_next", mrb_Git_git_index_conflict_next, MRB_ARGS_ARG(git_index_conflict_next_REQUIRED_ARGC, git_index_conflict_next_OPTIONAL_ARGC));
#endif
#if BIND_git_index_conflict_remove_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_conflict_remove", mrb_Git_git_index_conflict_remove, MRB_ARGS_ARG(git_index_conflict_remove_REQUIRED_ARGC, git_index_conflict_remove_OPTIONAL_ARGC));
#endif
#if BIND_git_index_entry_is_conflict_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_entry_is_conflict", mrb_Git_git_index_entry_is_conflict, MRB_ARGS_ARG(git_index_entry_is_conflict_REQUIRED_ARGC, git_index_entry_is_conflict_OPTIONAL_ARGC));
#endif
#if BIND_git_index_entry_stage_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_entry_stage", mrb_Git_git_index_entry_stage, MRB_ARGS_ARG(git_index_entry_stage_REQUIRED_ARGC, git_index_entry_stage_OPTIONAL_ARGC));
#endif
#if BIND_git_index_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_entrycount", mrb_Git_git_index_entrycount, MRB_ARGS_ARG(git_index_entrycount_REQUIRED_ARGC, git_index_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_index_find_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_find", mrb_Git_git_index_find, MRB_ARGS_ARG(git_index_find_REQUIRED_ARGC, git_index_find_OPTIONAL_ARGC));
#endif
#if BIND_git_index_find_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_find_prefix", mrb_Git_git_index_find_prefix, MRB_ARGS_ARG(git_index_find_prefix_REQUIRED_ARGC, git_index_find_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_index_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_free", mrb_Git_git_index_free, MRB_ARGS_ARG(git_index_free_REQUIRED_ARGC, git_index_free_OPTIONAL_ARGC));
#endif
#if BIND_git_index_get_byindex_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_get_byindex", mrb_Git_git_index_get_byindex, MRB_ARGS_ARG(git_index_get_byindex_REQUIRED_ARGC, git_index_get_byindex_OPTIONAL_ARGC));
#endif
#if BIND_git_index_get_bypath_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_get_bypath", mrb_Git_git_index_get_bypath, MRB_ARGS_ARG(git_index_get_bypath_REQUIRED_ARGC, git_index_get_bypath_OPTIONAL_ARGC));
#endif
#if BIND_git_index_has_conflicts_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_has_conflicts", mrb_Git_git_index_has_conflicts, MRB_ARGS_ARG(git_index_has_conflicts_REQUIRED_ARGC, git_index_has_conflicts_OPTIONAL_ARGC));
#endif
#if BIND_git_index_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_new", mrb_Git_git_index_new, MRB_ARGS_ARG(git_index_new_REQUIRED_ARGC, git_index_new_OPTIONAL_ARGC));
#endif
#if BIND_git_index_open_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_open", mrb_Git_git_index_open, MRB_ARGS_ARG(git_index_open_REQUIRED_ARGC, git_index_open_OPTIONAL_ARGC));
#endif
#if BIND_git_index_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_owner", mrb_Git_git_index_owner, MRB_ARGS_ARG(git_index_owner_REQUIRED_ARGC, git_index_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_index_path_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_path", mrb_Git_git_index_path, MRB_ARGS_ARG(git_index_path_REQUIRED_ARGC, git_index_path_OPTIONAL_ARGC));
#endif
#if BIND_git_index_read_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_read", mrb_Git_git_index_read, MRB_ARGS_ARG(git_index_read_REQUIRED_ARGC, git_index_read_OPTIONAL_ARGC));
#endif
#if BIND_git_index_read_tree_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_read_tree", mrb_Git_git_index_read_tree, MRB_ARGS_ARG(git_index_read_tree_REQUIRED_ARGC, git_index_read_tree_OPTIONAL_ARGC));
#endif
#if BIND_git_index_remove_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_remove", mrb_Git_git_index_remove, MRB_ARGS_ARG(git_index_remove_REQUIRED_ARGC, git_index_remove_OPTIONAL_ARGC));
#endif
#if BIND_git_index_remove_all_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_remove_all", mrb_Git_git_index_remove_all, MRB_ARGS_ARG(git_index_remove_all_REQUIRED_ARGC, git_index_remove_all_OPTIONAL_ARGC));
#endif
#if BIND_git_index_remove_bypath_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_remove_bypath", mrb_Git_git_index_remove_bypath, MRB_ARGS_ARG(git_index_remove_bypath_REQUIRED_ARGC, git_index_remove_bypath_OPTIONAL_ARGC));
#endif
#if BIND_git_index_remove_directory_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_remove_directory", mrb_Git_git_index_remove_directory, MRB_ARGS_ARG(git_index_remove_directory_REQUIRED_ARGC, git_index_remove_directory_OPTIONAL_ARGC));
#endif
#if BIND_git_index_set_caps_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_set_caps", mrb_Git_git_index_set_caps, MRB_ARGS_ARG(git_index_set_caps_REQUIRED_ARGC, git_index_set_caps_OPTIONAL_ARGC));
#endif
#if BIND_git_index_update_all_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_update_all", mrb_Git_git_index_update_all, MRB_ARGS_ARG(git_index_update_all_REQUIRED_ARGC, git_index_update_all_OPTIONAL_ARGC));
#endif
#if BIND_git_index_write_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_write", mrb_Git_git_index_write, MRB_ARGS_ARG(git_index_write_REQUIRED_ARGC, git_index_write_OPTIONAL_ARGC));
#endif
#if BIND_git_index_write_tree_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_write_tree", mrb_Git_git_index_write_tree, MRB_ARGS_ARG(git_index_write_tree_REQUIRED_ARGC, git_index_write_tree_OPTIONAL_ARGC));
#endif
#if BIND_git_index_write_tree_to_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_write_tree_to", mrb_Git_git_index_write_tree_to, MRB_ARGS_ARG(git_index_write_tree_to_REQUIRED_ARGC, git_index_write_tree_to_OPTIONAL_ARGC));
#endif
#if BIND_git_indexer_append_FUNCTION
  mrb_define_class_method(mrb, Git_module, "indexer_append", mrb_Git_git_indexer_append, MRB_ARGS_ARG(git_indexer_append_REQUIRED_ARGC, git_indexer_append_OPTIONAL_ARGC));
#endif
#if BIND_git_indexer_commit_FUNCTION
  mrb_define_class_method(mrb, Git_module, "indexer_commit", mrb_Git_git_indexer_commit, MRB_ARGS_ARG(git_indexer_commit_REQUIRED_ARGC, git_indexer_commit_OPTIONAL_ARGC));
#endif
#if BIND_git_indexer_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "indexer_free", mrb_Git_git_indexer_free, MRB_ARGS_ARG(git_indexer_free_REQUIRED_ARGC, git_indexer_free_OPTIONAL_ARGC));
#endif
#if BIND_git_indexer_hash_FUNCTION
  mrb_define_class_method(mrb, Git_module, "indexer_hash", mrb_Git_git_indexer_hash, MRB_ARGS_ARG(git_indexer_hash_REQUIRED_ARGC, git_indexer_hash_OPTIONAL_ARGC));
#endif
#if BIND_git_indexer_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "indexer_new", mrb_Git_git_indexer_new, MRB_ARGS_ARG(git_indexer_new_REQUIRED_ARGC, git_indexer_new_OPTIONAL_ARGC));
#endif
#if BIND_git_libgit2_features_FUNCTION
  mrb_define_class_method(mrb, Git_module, "libgit2_features", mrb_Git_git_libgit2_features, MRB_ARGS_ARG(git_libgit2_features_REQUIRED_ARGC, git_libgit2_features_OPTIONAL_ARGC));
#endif
#if BIND_git_libgit2_init_FUNCTION
  mrb_define_class_method(mrb, Git_module, "libgit2_init", mrb_Git_git_libgit2_init, MRB_ARGS_ARG(git_libgit2_init_REQUIRED_ARGC, git_libgit2_init_OPTIONAL_ARGC));
#endif
#if BIND_git_libgit2_opts_FUNCTION
  mrb_define_class_method(mrb, Git_module, "libgit2_opts", mrb_Git_git_libgit2_opts, MRB_ARGS_ARG(git_libgit2_opts_REQUIRED_ARGC, git_libgit2_opts_OPTIONAL_ARGC));
#endif
#if BIND_git_libgit2_shutdown_FUNCTION
  mrb_define_class_method(mrb, Git_module, "libgit2_shutdown", mrb_Git_git_libgit2_shutdown, MRB_ARGS_ARG(git_libgit2_shutdown_REQUIRED_ARGC, git_libgit2_shutdown_OPTIONAL_ARGC));
#endif
#if BIND_git_libgit2_version_FUNCTION
  mrb_define_class_method(mrb, Git_module, "libgit2_version", mrb_Git_git_libgit2_version, MRB_ARGS_ARG(git_libgit2_version_REQUIRED_ARGC, git_libgit2_version_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge", mrb_Git_git_merge, MRB_ARGS_ARG(git_merge_REQUIRED_ARGC, git_merge_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_analysis_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_analysis", mrb_Git_git_merge_analysis, MRB_ARGS_ARG(git_merge_analysis_REQUIRED_ARGC, git_merge_analysis_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_base_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_base", mrb_Git_git_merge_base, MRB_ARGS_ARG(git_merge_base_REQUIRED_ARGC, git_merge_base_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_base_many_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_base_many", mrb_Git_git_merge_base_many, MRB_ARGS_ARG(git_merge_base_many_REQUIRED_ARGC, git_merge_base_many_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_base_octopus_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_base_octopus", mrb_Git_git_merge_base_octopus, MRB_ARGS_ARG(git_merge_base_octopus_REQUIRED_ARGC, git_merge_base_octopus_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_bases_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_bases", mrb_Git_git_merge_bases, MRB_ARGS_ARG(git_merge_bases_REQUIRED_ARGC, git_merge_bases_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_bases_many_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_bases_many", mrb_Git_git_merge_bases_many, MRB_ARGS_ARG(git_merge_bases_many_REQUIRED_ARGC, git_merge_bases_many_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_commits_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_commits", mrb_Git_git_merge_commits, MRB_ARGS_ARG(git_merge_commits_REQUIRED_ARGC, git_merge_commits_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_file_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_file", mrb_Git_git_merge_file, MRB_ARGS_ARG(git_merge_file_REQUIRED_ARGC, git_merge_file_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_file_from_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_file_from_index", mrb_Git_git_merge_file_from_index, MRB_ARGS_ARG(git_merge_file_from_index_REQUIRED_ARGC, git_merge_file_from_index_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_file_init_input_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_file_init_input", mrb_Git_git_merge_file_init_input, MRB_ARGS_ARG(git_merge_file_init_input_REQUIRED_ARGC, git_merge_file_init_input_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_file_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_file_init_options", mrb_Git_git_merge_file_init_options, MRB_ARGS_ARG(git_merge_file_init_options_REQUIRED_ARGC, git_merge_file_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_file_result_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_file_result_free", mrb_Git_git_merge_file_result_free, MRB_ARGS_ARG(git_merge_file_result_free_REQUIRED_ARGC, git_merge_file_result_free_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_init_options", mrb_Git_git_merge_init_options, MRB_ARGS_ARG(git_merge_init_options_REQUIRED_ARGC, git_merge_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_trees_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_trees", mrb_Git_git_merge_trees, MRB_ARGS_ARG(git_merge_trees_REQUIRED_ARGC, git_merge_trees_OPTIONAL_ARGC));
#endif
#if BIND_git_message_prettify_FUNCTION
  mrb_define_class_method(mrb, Git_module, "message_prettify", mrb_Git_git_message_prettify, MRB_ARGS_ARG(git_message_prettify_REQUIRED_ARGC, git_message_prettify_OPTIONAL_ARGC));
#endif
#if BIND_git_note_author_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_author", mrb_Git_git_note_author, MRB_ARGS_ARG(git_note_author_REQUIRED_ARGC, git_note_author_OPTIONAL_ARGC));
#endif
#if BIND_git_note_committer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_committer", mrb_Git_git_note_committer, MRB_ARGS_ARG(git_note_committer_REQUIRED_ARGC, git_note_committer_OPTIONAL_ARGC));
#endif
#if BIND_git_note_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_create", mrb_Git_git_note_create, MRB_ARGS_ARG(git_note_create_REQUIRED_ARGC, git_note_create_OPTIONAL_ARGC));
#endif
#if BIND_git_note_default_ref_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_default_ref", mrb_Git_git_note_default_ref, MRB_ARGS_ARG(git_note_default_ref_REQUIRED_ARGC, git_note_default_ref_OPTIONAL_ARGC));
#endif
#if BIND_git_note_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_foreach", mrb_Git_git_note_foreach, MRB_ARGS_ARG(git_note_foreach_REQUIRED_ARGC, git_note_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_note_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_free", mrb_Git_git_note_free, MRB_ARGS_ARG(git_note_free_REQUIRED_ARGC, git_note_free_OPTIONAL_ARGC));
#endif
#if BIND_git_note_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_id", mrb_Git_git_note_id, MRB_ARGS_ARG(git_note_id_REQUIRED_ARGC, git_note_id_OPTIONAL_ARGC));
#endif
#if BIND_git_note_iterator_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_iterator_free", mrb_Git_git_note_iterator_free, MRB_ARGS_ARG(git_note_iterator_free_REQUIRED_ARGC, git_note_iterator_free_OPTIONAL_ARGC));
#endif
#if BIND_git_note_iterator_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_iterator_new", mrb_Git_git_note_iterator_new, MRB_ARGS_ARG(git_note_iterator_new_REQUIRED_ARGC, git_note_iterator_new_OPTIONAL_ARGC));
#endif
#if BIND_git_note_message_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_message", mrb_Git_git_note_message, MRB_ARGS_ARG(git_note_message_REQUIRED_ARGC, git_note_message_OPTIONAL_ARGC));
#endif
#if BIND_git_note_next_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_next", mrb_Git_git_note_next, MRB_ARGS_ARG(git_note_next_REQUIRED_ARGC, git_note_next_OPTIONAL_ARGC));
#endif
#if BIND_git_note_read_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_read", mrb_Git_git_note_read, MRB_ARGS_ARG(git_note_read_REQUIRED_ARGC, git_note_read_OPTIONAL_ARGC));
#endif
#if BIND_git_note_remove_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_remove", mrb_Git_git_note_remove, MRB_ARGS_ARG(git_note_remove_REQUIRED_ARGC, git_note_remove_OPTIONAL_ARGC));
#endif
#if BIND_git_object__size_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object__size", mrb_Git_git_object__size, MRB_ARGS_ARG(git_object__size_REQUIRED_ARGC, git_object__size_OPTIONAL_ARGC));
#endif
#if BIND_git_object_dup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_dup", mrb_Git_git_object_dup, MRB_ARGS_ARG(git_object_dup_REQUIRED_ARGC, git_object_dup_OPTIONAL_ARGC));
#endif
#if BIND_git_object_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_free", mrb_Git_git_object_free, MRB_ARGS_ARG(git_object_free_REQUIRED_ARGC, git_object_free_OPTIONAL_ARGC));
#endif
#if BIND_git_object_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_id", mrb_Git_git_object_id, MRB_ARGS_ARG(git_object_id_REQUIRED_ARGC, git_object_id_OPTIONAL_ARGC));
#endif
#if BIND_git_object_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_lookup", mrb_Git_git_object_lookup, MRB_ARGS_ARG(git_object_lookup_REQUIRED_ARGC, git_object_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_object_lookup_bypath_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_lookup_bypath", mrb_Git_git_object_lookup_bypath, MRB_ARGS_ARG(git_object_lookup_bypath_REQUIRED_ARGC, git_object_lookup_bypath_OPTIONAL_ARGC));
#endif
#if BIND_git_object_lookup_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_lookup_prefix", mrb_Git_git_object_lookup_prefix, MRB_ARGS_ARG(git_object_lookup_prefix_REQUIRED_ARGC, git_object_lookup_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_object_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_owner", mrb_Git_git_object_owner, MRB_ARGS_ARG(git_object_owner_REQUIRED_ARGC, git_object_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_object_peel_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_peel", mrb_Git_git_object_peel, MRB_ARGS_ARG(git_object_peel_REQUIRED_ARGC, git_object_peel_OPTIONAL_ARGC));
#endif
#if BIND_git_object_short_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_short_id", mrb_Git_git_object_short_id, MRB_ARGS_ARG(git_object_short_id_REQUIRED_ARGC, git_object_short_id_OPTIONAL_ARGC));
#endif
#if BIND_git_object_string2type_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_string2type", mrb_Git_git_object_string2type, MRB_ARGS_ARG(git_object_string2type_REQUIRED_ARGC, git_object_string2type_OPTIONAL_ARGC));
#endif
#if BIND_git_object_type_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_type", mrb_Git_git_object_type, MRB_ARGS_ARG(git_object_type_REQUIRED_ARGC, git_object_type_OPTIONAL_ARGC));
#endif
#if BIND_git_object_type2string_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_type2string", mrb_Git_git_object_type2string, MRB_ARGS_ARG(git_object_type2string_REQUIRED_ARGC, git_object_type2string_OPTIONAL_ARGC));
#endif
#if BIND_git_object_typeisloose_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_typeisloose", mrb_Git_git_object_typeisloose, MRB_ARGS_ARG(git_object_typeisloose_REQUIRED_ARGC, git_object_typeisloose_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_add_alternate_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_add_alternate", mrb_Git_git_odb_add_alternate, MRB_ARGS_ARG(git_odb_add_alternate_REQUIRED_ARGC, git_odb_add_alternate_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_add_backend_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_add_backend", mrb_Git_git_odb_add_backend, MRB_ARGS_ARG(git_odb_add_backend_REQUIRED_ARGC, git_odb_add_backend_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_add_disk_alternate_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_add_disk_alternate", mrb_Git_git_odb_add_disk_alternate, MRB_ARGS_ARG(git_odb_add_disk_alternate_REQUIRED_ARGC, git_odb_add_disk_alternate_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_backend_loose_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_backend_loose", mrb_Git_git_odb_backend_loose, MRB_ARGS_ARG(git_odb_backend_loose_REQUIRED_ARGC, git_odb_backend_loose_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_backend_one_pack_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_backend_one_pack", mrb_Git_git_odb_backend_one_pack, MRB_ARGS_ARG(git_odb_backend_one_pack_REQUIRED_ARGC, git_odb_backend_one_pack_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_backend_pack_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_backend_pack", mrb_Git_git_odb_backend_pack, MRB_ARGS_ARG(git_odb_backend_pack_REQUIRED_ARGC, git_odb_backend_pack_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_exists_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_exists", mrb_Git_git_odb_exists, MRB_ARGS_ARG(git_odb_exists_REQUIRED_ARGC, git_odb_exists_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_exists_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_exists_prefix", mrb_Git_git_odb_exists_prefix, MRB_ARGS_ARG(git_odb_exists_prefix_REQUIRED_ARGC, git_odb_exists_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_foreach", mrb_Git_git_odb_foreach, MRB_ARGS_ARG(git_odb_foreach_REQUIRED_ARGC, git_odb_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_free", mrb_Git_git_odb_free, MRB_ARGS_ARG(git_odb_free_REQUIRED_ARGC, git_odb_free_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_get_backend_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_get_backend", mrb_Git_git_odb_get_backend, MRB_ARGS_ARG(git_odb_get_backend_REQUIRED_ARGC, git_odb_get_backend_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_hash_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_hash", mrb_Git_git_odb_hash, MRB_ARGS_ARG(git_odb_hash_REQUIRED_ARGC, git_odb_hash_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_hashfile_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_hashfile", mrb_Git_git_odb_hashfile, MRB_ARGS_ARG(git_odb_hashfile_REQUIRED_ARGC, git_odb_hashfile_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_new", mrb_Git_git_odb_new, MRB_ARGS_ARG(git_odb_new_REQUIRED_ARGC, git_odb_new_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_num_backends_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_num_backends", mrb_Git_git_odb_num_backends, MRB_ARGS_ARG(git_odb_num_backends_REQUIRED_ARGC, git_odb_num_backends_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_object_data_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_object_data", mrb_Git_git_odb_object_data, MRB_ARGS_ARG(git_odb_object_data_REQUIRED_ARGC, git_odb_object_data_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_object_dup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_object_dup", mrb_Git_git_odb_object_dup, MRB_ARGS_ARG(git_odb_object_dup_REQUIRED_ARGC, git_odb_object_dup_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_object_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_object_free", mrb_Git_git_odb_object_free, MRB_ARGS_ARG(git_odb_object_free_REQUIRED_ARGC, git_odb_object_free_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_object_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_object_id", mrb_Git_git_odb_object_id, MRB_ARGS_ARG(git_odb_object_id_REQUIRED_ARGC, git_odb_object_id_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_object_size_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_object_size", mrb_Git_git_odb_object_size, MRB_ARGS_ARG(git_odb_object_size_REQUIRED_ARGC, git_odb_object_size_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_object_type_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_object_type", mrb_Git_git_odb_object_type, MRB_ARGS_ARG(git_odb_object_type_REQUIRED_ARGC, git_odb_object_type_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_open_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_open", mrb_Git_git_odb_open, MRB_ARGS_ARG(git_odb_open_REQUIRED_ARGC, git_odb_open_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_open_rstream_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_open_rstream", mrb_Git_git_odb_open_rstream, MRB_ARGS_ARG(git_odb_open_rstream_REQUIRED_ARGC, git_odb_open_rstream_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_open_wstream_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_open_wstream", mrb_Git_git_odb_open_wstream, MRB_ARGS_ARG(git_odb_open_wstream_REQUIRED_ARGC, git_odb_open_wstream_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_read_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_read", mrb_Git_git_odb_read, MRB_ARGS_ARG(git_odb_read_REQUIRED_ARGC, git_odb_read_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_read_header_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_read_header", mrb_Git_git_odb_read_header, MRB_ARGS_ARG(git_odb_read_header_REQUIRED_ARGC, git_odb_read_header_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_read_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_read_prefix", mrb_Git_git_odb_read_prefix, MRB_ARGS_ARG(git_odb_read_prefix_REQUIRED_ARGC, git_odb_read_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_refresh_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_refresh", mrb_Git_git_odb_refresh, MRB_ARGS_ARG(git_odb_refresh_REQUIRED_ARGC, git_odb_refresh_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_stream_finalize_write_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_stream_finalize_write", mrb_Git_git_odb_stream_finalize_write, MRB_ARGS_ARG(git_odb_stream_finalize_write_REQUIRED_ARGC, git_odb_stream_finalize_write_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_stream_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_stream_free", mrb_Git_git_odb_stream_free, MRB_ARGS_ARG(git_odb_stream_free_REQUIRED_ARGC, git_odb_stream_free_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_stream_read_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_stream_read", mrb_Git_git_odb_stream_read, MRB_ARGS_ARG(git_odb_stream_read_REQUIRED_ARGC, git_odb_stream_read_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_stream_write_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_stream_write", mrb_Git_git_odb_stream_write, MRB_ARGS_ARG(git_odb_stream_write_REQUIRED_ARGC, git_odb_stream_write_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_write_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_write", mrb_Git_git_odb_write, MRB_ARGS_ARG(git_odb_write_REQUIRED_ARGC, git_odb_write_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_write_pack_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_write_pack", mrb_Git_git_odb_write_pack, MRB_ARGS_ARG(git_odb_write_pack_REQUIRED_ARGC, git_odb_write_pack_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_cmp_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_cmp", mrb_Git_git_oid_cmp, MRB_ARGS_ARG(git_oid_cmp_REQUIRED_ARGC, git_oid_cmp_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_cpy_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_cpy", mrb_Git_git_oid_cpy, MRB_ARGS_ARG(git_oid_cpy_REQUIRED_ARGC, git_oid_cpy_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_equal_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_equal", mrb_Git_git_oid_equal, MRB_ARGS_ARG(git_oid_equal_REQUIRED_ARGC, git_oid_equal_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_fmt_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_fmt", mrb_Git_git_oid_fmt, MRB_ARGS_ARG(git_oid_fmt_REQUIRED_ARGC, git_oid_fmt_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_fromraw_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_fromraw", mrb_Git_git_oid_fromraw, MRB_ARGS_ARG(git_oid_fromraw_REQUIRED_ARGC, git_oid_fromraw_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_fromstr_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_fromstr", mrb_Git_git_oid_fromstr, MRB_ARGS_ARG(git_oid_fromstr_REQUIRED_ARGC, git_oid_fromstr_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_fromstrn_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_fromstrn", mrb_Git_git_oid_fromstrn, MRB_ARGS_ARG(git_oid_fromstrn_REQUIRED_ARGC, git_oid_fromstrn_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_fromstrp_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_fromstrp", mrb_Git_git_oid_fromstrp, MRB_ARGS_ARG(git_oid_fromstrp_REQUIRED_ARGC, git_oid_fromstrp_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_iszero_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_iszero", mrb_Git_git_oid_iszero, MRB_ARGS_ARG(git_oid_iszero_REQUIRED_ARGC, git_oid_iszero_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_ncmp_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_ncmp", mrb_Git_git_oid_ncmp, MRB_ARGS_ARG(git_oid_ncmp_REQUIRED_ARGC, git_oid_ncmp_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_nfmt_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_nfmt", mrb_Git_git_oid_nfmt, MRB_ARGS_ARG(git_oid_nfmt_REQUIRED_ARGC, git_oid_nfmt_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_pathfmt_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_pathfmt", mrb_Git_git_oid_pathfmt, MRB_ARGS_ARG(git_oid_pathfmt_REQUIRED_ARGC, git_oid_pathfmt_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_shorten_add_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_shorten_add", mrb_Git_git_oid_shorten_add, MRB_ARGS_ARG(git_oid_shorten_add_REQUIRED_ARGC, git_oid_shorten_add_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_shorten_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_shorten_free", mrb_Git_git_oid_shorten_free, MRB_ARGS_ARG(git_oid_shorten_free_REQUIRED_ARGC, git_oid_shorten_free_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_shorten_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_shorten_new", mrb_Git_git_oid_shorten_new, MRB_ARGS_ARG(git_oid_shorten_new_REQUIRED_ARGC, git_oid_shorten_new_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_strcmp_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_strcmp", mrb_Git_git_oid_strcmp, MRB_ARGS_ARG(git_oid_strcmp_REQUIRED_ARGC, git_oid_strcmp_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_streq_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_streq", mrb_Git_git_oid_streq, MRB_ARGS_ARG(git_oid_streq_REQUIRED_ARGC, git_oid_streq_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_tostr_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_tostr", mrb_Git_git_oid_tostr, MRB_ARGS_ARG(git_oid_tostr_REQUIRED_ARGC, git_oid_tostr_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_tostr_s_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_tostr_s", mrb_Git_git_oid_tostr_s, MRB_ARGS_ARG(git_oid_tostr_s_REQUIRED_ARGC, git_oid_tostr_s_OPTIONAL_ARGC));
#endif
#if BIND_git_oidarray_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oidarray_free", mrb_Git_git_oidarray_free, MRB_ARGS_ARG(git_oidarray_free_REQUIRED_ARGC, git_oidarray_free_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_foreach", mrb_Git_git_packbuilder_foreach, MRB_ARGS_ARG(git_packbuilder_foreach_REQUIRED_ARGC, git_packbuilder_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_free", mrb_Git_git_packbuilder_free, MRB_ARGS_ARG(git_packbuilder_free_REQUIRED_ARGC, git_packbuilder_free_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_hash_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_hash", mrb_Git_git_packbuilder_hash, MRB_ARGS_ARG(git_packbuilder_hash_REQUIRED_ARGC, git_packbuilder_hash_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_insert_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_insert", mrb_Git_git_packbuilder_insert, MRB_ARGS_ARG(git_packbuilder_insert_REQUIRED_ARGC, git_packbuilder_insert_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_insert_commit_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_insert_commit", mrb_Git_git_packbuilder_insert_commit, MRB_ARGS_ARG(git_packbuilder_insert_commit_REQUIRED_ARGC, git_packbuilder_insert_commit_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_insert_recur_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_insert_recur", mrb_Git_git_packbuilder_insert_recur, MRB_ARGS_ARG(git_packbuilder_insert_recur_REQUIRED_ARGC, git_packbuilder_insert_recur_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_insert_tree_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_insert_tree", mrb_Git_git_packbuilder_insert_tree, MRB_ARGS_ARG(git_packbuilder_insert_tree_REQUIRED_ARGC, git_packbuilder_insert_tree_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_insert_walk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_insert_walk", mrb_Git_git_packbuilder_insert_walk, MRB_ARGS_ARG(git_packbuilder_insert_walk_REQUIRED_ARGC, git_packbuilder_insert_walk_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_new", mrb_Git_git_packbuilder_new, MRB_ARGS_ARG(git_packbuilder_new_REQUIRED_ARGC, git_packbuilder_new_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_object_count_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_object_count", mrb_Git_git_packbuilder_object_count, MRB_ARGS_ARG(git_packbuilder_object_count_REQUIRED_ARGC, git_packbuilder_object_count_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_set_callbacks_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_set_callbacks", mrb_Git_git_packbuilder_set_callbacks, MRB_ARGS_ARG(git_packbuilder_set_callbacks_REQUIRED_ARGC, git_packbuilder_set_callbacks_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_set_threads_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_set_threads", mrb_Git_git_packbuilder_set_threads, MRB_ARGS_ARG(git_packbuilder_set_threads_REQUIRED_ARGC, git_packbuilder_set_threads_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_write_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_write", mrb_Git_git_packbuilder_write, MRB_ARGS_ARG(git_packbuilder_write_REQUIRED_ARGC, git_packbuilder_write_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_write_buf_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_write_buf", mrb_Git_git_packbuilder_write_buf, MRB_ARGS_ARG(git_packbuilder_write_buf_REQUIRED_ARGC, git_packbuilder_write_buf_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_written_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_written", mrb_Git_git_packbuilder_written, MRB_ARGS_ARG(git_packbuilder_written_REQUIRED_ARGC, git_packbuilder_written_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_free", mrb_Git_git_patch_free, MRB_ARGS_ARG(git_patch_free_REQUIRED_ARGC, git_patch_free_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_from_blob_and_buffer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_from_blob_and_buffer", mrb_Git_git_patch_from_blob_and_buffer, MRB_ARGS_ARG(git_patch_from_blob_and_buffer_REQUIRED_ARGC, git_patch_from_blob_and_buffer_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_from_blobs_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_from_blobs", mrb_Git_git_patch_from_blobs, MRB_ARGS_ARG(git_patch_from_blobs_REQUIRED_ARGC, git_patch_from_blobs_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_from_buffers_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_from_buffers", mrb_Git_git_patch_from_buffers, MRB_ARGS_ARG(git_patch_from_buffers_REQUIRED_ARGC, git_patch_from_buffers_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_from_diff_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_from_diff", mrb_Git_git_patch_from_diff, MRB_ARGS_ARG(git_patch_from_diff_REQUIRED_ARGC, git_patch_from_diff_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_get_delta_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_get_delta", mrb_Git_git_patch_get_delta, MRB_ARGS_ARG(git_patch_get_delta_REQUIRED_ARGC, git_patch_get_delta_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_get_hunk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_get_hunk", mrb_Git_git_patch_get_hunk, MRB_ARGS_ARG(git_patch_get_hunk_REQUIRED_ARGC, git_patch_get_hunk_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_get_line_in_hunk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_get_line_in_hunk", mrb_Git_git_patch_get_line_in_hunk, MRB_ARGS_ARG(git_patch_get_line_in_hunk_REQUIRED_ARGC, git_patch_get_line_in_hunk_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_line_stats_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_line_stats", mrb_Git_git_patch_line_stats, MRB_ARGS_ARG(git_patch_line_stats_REQUIRED_ARGC, git_patch_line_stats_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_num_hunks_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_num_hunks", mrb_Git_git_patch_num_hunks, MRB_ARGS_ARG(git_patch_num_hunks_REQUIRED_ARGC, git_patch_num_hunks_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_num_lines_in_hunk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_num_lines_in_hunk", mrb_Git_git_patch_num_lines_in_hunk, MRB_ARGS_ARG(git_patch_num_lines_in_hunk_REQUIRED_ARGC, git_patch_num_lines_in_hunk_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_print_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_print", mrb_Git_git_patch_print, MRB_ARGS_ARG(git_patch_print_REQUIRED_ARGC, git_patch_print_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_size_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_size", mrb_Git_git_patch_size, MRB_ARGS_ARG(git_patch_size_REQUIRED_ARGC, git_patch_size_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_to_buf_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_to_buf", mrb_Git_git_patch_to_buf, MRB_ARGS_ARG(git_patch_to_buf_REQUIRED_ARGC, git_patch_to_buf_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_free", mrb_Git_git_pathspec_free, MRB_ARGS_ARG(git_pathspec_free_REQUIRED_ARGC, git_pathspec_free_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_diff_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_diff", mrb_Git_git_pathspec_match_diff, MRB_ARGS_ARG(git_pathspec_match_diff_REQUIRED_ARGC, git_pathspec_match_diff_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_index", mrb_Git_git_pathspec_match_index, MRB_ARGS_ARG(git_pathspec_match_index_REQUIRED_ARGC, git_pathspec_match_index_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_list_diff_entry_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_list_diff_entry", mrb_Git_git_pathspec_match_list_diff_entry, MRB_ARGS_ARG(git_pathspec_match_list_diff_entry_REQUIRED_ARGC, git_pathspec_match_list_diff_entry_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_list_entry_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_list_entry", mrb_Git_git_pathspec_match_list_entry, MRB_ARGS_ARG(git_pathspec_match_list_entry_REQUIRED_ARGC, git_pathspec_match_list_entry_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_list_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_list_entrycount", mrb_Git_git_pathspec_match_list_entrycount, MRB_ARGS_ARG(git_pathspec_match_list_entrycount_REQUIRED_ARGC, git_pathspec_match_list_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_list_failed_entry_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_list_failed_entry", mrb_Git_git_pathspec_match_list_failed_entry, MRB_ARGS_ARG(git_pathspec_match_list_failed_entry_REQUIRED_ARGC, git_pathspec_match_list_failed_entry_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_list_failed_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_list_failed_entrycount", mrb_Git_git_pathspec_match_list_failed_entrycount, MRB_ARGS_ARG(git_pathspec_match_list_failed_entrycount_REQUIRED_ARGC, git_pathspec_match_list_failed_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_list_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_list_free", mrb_Git_git_pathspec_match_list_free, MRB_ARGS_ARG(git_pathspec_match_list_free_REQUIRED_ARGC, git_pathspec_match_list_free_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_tree_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_tree", mrb_Git_git_pathspec_match_tree, MRB_ARGS_ARG(git_pathspec_match_tree_REQUIRED_ARGC, git_pathspec_match_tree_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_workdir_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_workdir", mrb_Git_git_pathspec_match_workdir, MRB_ARGS_ARG(git_pathspec_match_workdir_REQUIRED_ARGC, git_pathspec_match_workdir_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_matches_path_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_matches_path", mrb_Git_git_pathspec_matches_path, MRB_ARGS_ARG(git_pathspec_matches_path_REQUIRED_ARGC, git_pathspec_matches_path_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_new", mrb_Git_git_pathspec_new, MRB_ARGS_ARG(git_pathspec_new_REQUIRED_ARGC, git_pathspec_new_OPTIONAL_ARGC));
#endif
#if BIND_git_push_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "push_init_options", mrb_Git_git_push_init_options, MRB_ARGS_ARG(git_push_init_options_REQUIRED_ARGC, git_push_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_abort_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_abort", mrb_Git_git_rebase_abort, MRB_ARGS_ARG(git_rebase_abort_REQUIRED_ARGC, git_rebase_abort_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_commit_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_commit", mrb_Git_git_rebase_commit, MRB_ARGS_ARG(git_rebase_commit_REQUIRED_ARGC, git_rebase_commit_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_finish_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_finish", mrb_Git_git_rebase_finish, MRB_ARGS_ARG(git_rebase_finish_REQUIRED_ARGC, git_rebase_finish_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_free", mrb_Git_git_rebase_free, MRB_ARGS_ARG(git_rebase_free_REQUIRED_ARGC, git_rebase_free_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_init_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_init", mrb_Git_git_rebase_init, MRB_ARGS_ARG(git_rebase_init_REQUIRED_ARGC, git_rebase_init_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_init_options", mrb_Git_git_rebase_init_options, MRB_ARGS_ARG(git_rebase_init_options_REQUIRED_ARGC, git_rebase_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_next_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_next", mrb_Git_git_rebase_next, MRB_ARGS_ARG(git_rebase_next_REQUIRED_ARGC, git_rebase_next_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_open_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_open", mrb_Git_git_rebase_open, MRB_ARGS_ARG(git_rebase_open_REQUIRED_ARGC, git_rebase_open_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_operation_byindex_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_operation_byindex", mrb_Git_git_rebase_operation_byindex, MRB_ARGS_ARG(git_rebase_operation_byindex_REQUIRED_ARGC, git_rebase_operation_byindex_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_operation_current_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_operation_current", mrb_Git_git_rebase_operation_current, MRB_ARGS_ARG(git_rebase_operation_current_REQUIRED_ARGC, git_rebase_operation_current_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_operation_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_operation_entrycount", mrb_Git_git_rebase_operation_entrycount, MRB_ARGS_ARG(git_rebase_operation_entrycount_REQUIRED_ARGC, git_rebase_operation_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_refdb_compress_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refdb_compress", mrb_Git_git_refdb_compress, MRB_ARGS_ARG(git_refdb_compress_REQUIRED_ARGC, git_refdb_compress_OPTIONAL_ARGC));
#endif
#if BIND_git_refdb_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refdb_free", mrb_Git_git_refdb_free, MRB_ARGS_ARG(git_refdb_free_REQUIRED_ARGC, git_refdb_free_OPTIONAL_ARGC));
#endif
#if BIND_git_refdb_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refdb_new", mrb_Git_git_refdb_new, MRB_ARGS_ARG(git_refdb_new_REQUIRED_ARGC, git_refdb_new_OPTIONAL_ARGC));
#endif
#if BIND_git_refdb_open_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refdb_open", mrb_Git_git_refdb_open, MRB_ARGS_ARG(git_refdb_open_REQUIRED_ARGC, git_refdb_open_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_cmp_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_cmp", mrb_Git_git_reference_cmp, MRB_ARGS_ARG(git_reference_cmp_REQUIRED_ARGC, git_reference_cmp_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_create", mrb_Git_git_reference_create, MRB_ARGS_ARG(git_reference_create_REQUIRED_ARGC, git_reference_create_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_create_matching_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_create_matching", mrb_Git_git_reference_create_matching, MRB_ARGS_ARG(git_reference_create_matching_REQUIRED_ARGC, git_reference_create_matching_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_delete_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_delete", mrb_Git_git_reference_delete, MRB_ARGS_ARG(git_reference_delete_REQUIRED_ARGC, git_reference_delete_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_dwim_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_dwim", mrb_Git_git_reference_dwim, MRB_ARGS_ARG(git_reference_dwim_REQUIRED_ARGC, git_reference_dwim_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_ensure_log_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_ensure_log", mrb_Git_git_reference_ensure_log, MRB_ARGS_ARG(git_reference_ensure_log_REQUIRED_ARGC, git_reference_ensure_log_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_foreach", mrb_Git_git_reference_foreach, MRB_ARGS_ARG(git_reference_foreach_REQUIRED_ARGC, git_reference_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_foreach_glob_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_foreach_glob", mrb_Git_git_reference_foreach_glob, MRB_ARGS_ARG(git_reference_foreach_glob_REQUIRED_ARGC, git_reference_foreach_glob_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_foreach_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_foreach_name", mrb_Git_git_reference_foreach_name, MRB_ARGS_ARG(git_reference_foreach_name_REQUIRED_ARGC, git_reference_foreach_name_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_free", mrb_Git_git_reference_free, MRB_ARGS_ARG(git_reference_free_REQUIRED_ARGC, git_reference_free_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_has_log_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_has_log", mrb_Git_git_reference_has_log, MRB_ARGS_ARG(git_reference_has_log_REQUIRED_ARGC, git_reference_has_log_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_is_branch_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_is_branch", mrb_Git_git_reference_is_branch, MRB_ARGS_ARG(git_reference_is_branch_REQUIRED_ARGC, git_reference_is_branch_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_is_note_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_is_note", mrb_Git_git_reference_is_note, MRB_ARGS_ARG(git_reference_is_note_REQUIRED_ARGC, git_reference_is_note_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_is_remote_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_is_remote", mrb_Git_git_reference_is_remote, MRB_ARGS_ARG(git_reference_is_remote_REQUIRED_ARGC, git_reference_is_remote_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_is_tag_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_is_tag", mrb_Git_git_reference_is_tag, MRB_ARGS_ARG(git_reference_is_tag_REQUIRED_ARGC, git_reference_is_tag_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_is_valid_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_is_valid_name", mrb_Git_git_reference_is_valid_name, MRB_ARGS_ARG(git_reference_is_valid_name_REQUIRED_ARGC, git_reference_is_valid_name_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_iterator_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_iterator_free", mrb_Git_git_reference_iterator_free, MRB_ARGS_ARG(git_reference_iterator_free_REQUIRED_ARGC, git_reference_iterator_free_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_iterator_glob_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_iterator_glob_new", mrb_Git_git_reference_iterator_glob_new, MRB_ARGS_ARG(git_reference_iterator_glob_new_REQUIRED_ARGC, git_reference_iterator_glob_new_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_iterator_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_iterator_new", mrb_Git_git_reference_iterator_new, MRB_ARGS_ARG(git_reference_iterator_new_REQUIRED_ARGC, git_reference_iterator_new_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_list_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_list", mrb_Git_git_reference_list, MRB_ARGS_ARG(git_reference_list_REQUIRED_ARGC, git_reference_list_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_lookup", mrb_Git_git_reference_lookup, MRB_ARGS_ARG(git_reference_lookup_REQUIRED_ARGC, git_reference_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_name", mrb_Git_git_reference_name, MRB_ARGS_ARG(git_reference_name_REQUIRED_ARGC, git_reference_name_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_name_to_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_name_to_id", mrb_Git_git_reference_name_to_id, MRB_ARGS_ARG(git_reference_name_to_id_REQUIRED_ARGC, git_reference_name_to_id_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_next_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_next", mrb_Git_git_reference_next, MRB_ARGS_ARG(git_reference_next_REQUIRED_ARGC, git_reference_next_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_next_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_next_name", mrb_Git_git_reference_next_name, MRB_ARGS_ARG(git_reference_next_name_REQUIRED_ARGC, git_reference_next_name_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_normalize_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_normalize_name", mrb_Git_git_reference_normalize_name, MRB_ARGS_ARG(git_reference_normalize_name_REQUIRED_ARGC, git_reference_normalize_name_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_owner", mrb_Git_git_reference_owner, MRB_ARGS_ARG(git_reference_owner_REQUIRED_ARGC, git_reference_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_peel_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_peel", mrb_Git_git_reference_peel, MRB_ARGS_ARG(git_reference_peel_REQUIRED_ARGC, git_reference_peel_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_remove_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_remove", mrb_Git_git_reference_remove, MRB_ARGS_ARG(git_reference_remove_REQUIRED_ARGC, git_reference_remove_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_rename_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_rename", mrb_Git_git_reference_rename, MRB_ARGS_ARG(git_reference_rename_REQUIRED_ARGC, git_reference_rename_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_resolve_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_resolve", mrb_Git_git_reference_resolve, MRB_ARGS_ARG(git_reference_resolve_REQUIRED_ARGC, git_reference_resolve_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_set_target_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_set_target", mrb_Git_git_reference_set_target, MRB_ARGS_ARG(git_reference_set_target_REQUIRED_ARGC, git_reference_set_target_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_shorthand_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_shorthand", mrb_Git_git_reference_shorthand, MRB_ARGS_ARG(git_reference_shorthand_REQUIRED_ARGC, git_reference_shorthand_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_symbolic_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_symbolic_create", mrb_Git_git_reference_symbolic_create, MRB_ARGS_ARG(git_reference_symbolic_create_REQUIRED_ARGC, git_reference_symbolic_create_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_symbolic_create_matching_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_symbolic_create_matching", mrb_Git_git_reference_symbolic_create_matching, MRB_ARGS_ARG(git_reference_symbolic_create_matching_REQUIRED_ARGC, git_reference_symbolic_create_matching_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_symbolic_set_target_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_symbolic_set_target", mrb_Git_git_reference_symbolic_set_target, MRB_ARGS_ARG(git_reference_symbolic_set_target_REQUIRED_ARGC, git_reference_symbolic_set_target_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_symbolic_target_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_symbolic_target", mrb_Git_git_reference_symbolic_target, MRB_ARGS_ARG(git_reference_symbolic_target_REQUIRED_ARGC, git_reference_symbolic_target_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_target_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_target", mrb_Git_git_reference_target, MRB_ARGS_ARG(git_reference_target_REQUIRED_ARGC, git_reference_target_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_target_peel_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_target_peel", mrb_Git_git_reference_target_peel, MRB_ARGS_ARG(git_reference_target_peel_REQUIRED_ARGC, git_reference_target_peel_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_type_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_type", mrb_Git_git_reference_type, MRB_ARGS_ARG(git_reference_type_REQUIRED_ARGC, git_reference_type_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_append_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_append", mrb_Git_git_reflog_append, MRB_ARGS_ARG(git_reflog_append_REQUIRED_ARGC, git_reflog_append_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_delete_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_delete", mrb_Git_git_reflog_delete, MRB_ARGS_ARG(git_reflog_delete_REQUIRED_ARGC, git_reflog_delete_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_drop_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_drop", mrb_Git_git_reflog_drop, MRB_ARGS_ARG(git_reflog_drop_REQUIRED_ARGC, git_reflog_drop_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_entry_byindex_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_entry_byindex", mrb_Git_git_reflog_entry_byindex, MRB_ARGS_ARG(git_reflog_entry_byindex_REQUIRED_ARGC, git_reflog_entry_byindex_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_entry_committer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_entry_committer", mrb_Git_git_reflog_entry_committer, MRB_ARGS_ARG(git_reflog_entry_committer_REQUIRED_ARGC, git_reflog_entry_committer_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_entry_id_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_entry_id_new", mrb_Git_git_reflog_entry_id_new, MRB_ARGS_ARG(git_reflog_entry_id_new_REQUIRED_ARGC, git_reflog_entry_id_new_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_entry_id_old_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_entry_id_old", mrb_Git_git_reflog_entry_id_old, MRB_ARGS_ARG(git_reflog_entry_id_old_REQUIRED_ARGC, git_reflog_entry_id_old_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_entry_message_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_entry_message", mrb_Git_git_reflog_entry_message, MRB_ARGS_ARG(git_reflog_entry_message_REQUIRED_ARGC, git_reflog_entry_message_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_entrycount", mrb_Git_git_reflog_entrycount, MRB_ARGS_ARG(git_reflog_entrycount_REQUIRED_ARGC, git_reflog_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_free", mrb_Git_git_reflog_free, MRB_ARGS_ARG(git_reflog_free_REQUIRED_ARGC, git_reflog_free_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_read_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_read", mrb_Git_git_reflog_read, MRB_ARGS_ARG(git_reflog_read_REQUIRED_ARGC, git_reflog_read_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_rename_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_rename", mrb_Git_git_reflog_rename, MRB_ARGS_ARG(git_reflog_rename_REQUIRED_ARGC, git_reflog_rename_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_write_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_write", mrb_Git_git_reflog_write, MRB_ARGS_ARG(git_reflog_write_REQUIRED_ARGC, git_reflog_write_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_direction_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_direction", mrb_Git_git_refspec_direction, MRB_ARGS_ARG(git_refspec_direction_REQUIRED_ARGC, git_refspec_direction_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_dst_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_dst", mrb_Git_git_refspec_dst, MRB_ARGS_ARG(git_refspec_dst_REQUIRED_ARGC, git_refspec_dst_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_dst_matches_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_dst_matches", mrb_Git_git_refspec_dst_matches, MRB_ARGS_ARG(git_refspec_dst_matches_REQUIRED_ARGC, git_refspec_dst_matches_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_force_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_force", mrb_Git_git_refspec_force, MRB_ARGS_ARG(git_refspec_force_REQUIRED_ARGC, git_refspec_force_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_rtransform_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_rtransform", mrb_Git_git_refspec_rtransform, MRB_ARGS_ARG(git_refspec_rtransform_REQUIRED_ARGC, git_refspec_rtransform_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_src_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_src", mrb_Git_git_refspec_src, MRB_ARGS_ARG(git_refspec_src_REQUIRED_ARGC, git_refspec_src_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_src_matches_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_src_matches", mrb_Git_git_refspec_src_matches, MRB_ARGS_ARG(git_refspec_src_matches_REQUIRED_ARGC, git_refspec_src_matches_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_string_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_string", mrb_Git_git_refspec_string, MRB_ARGS_ARG(git_refspec_string_REQUIRED_ARGC, git_refspec_string_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_transform_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_transform", mrb_Git_git_refspec_transform, MRB_ARGS_ARG(git_refspec_transform_REQUIRED_ARGC, git_refspec_transform_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_add_fetch_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_add_fetch", mrb_Git_git_remote_add_fetch, MRB_ARGS_ARG(git_remote_add_fetch_REQUIRED_ARGC, git_remote_add_fetch_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_add_push_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_add_push", mrb_Git_git_remote_add_push, MRB_ARGS_ARG(git_remote_add_push_REQUIRED_ARGC, git_remote_add_push_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_autotag_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_autotag", mrb_Git_git_remote_autotag, MRB_ARGS_ARG(git_remote_autotag_REQUIRED_ARGC, git_remote_autotag_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_connect_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_connect", mrb_Git_git_remote_connect, MRB_ARGS_ARG(git_remote_connect_REQUIRED_ARGC, git_remote_connect_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_connected_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_connected", mrb_Git_git_remote_connected, MRB_ARGS_ARG(git_remote_connected_REQUIRED_ARGC, git_remote_connected_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_create", mrb_Git_git_remote_create, MRB_ARGS_ARG(git_remote_create_REQUIRED_ARGC, git_remote_create_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_create_anonymous_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_create_anonymous", mrb_Git_git_remote_create_anonymous, MRB_ARGS_ARG(git_remote_create_anonymous_REQUIRED_ARGC, git_remote_create_anonymous_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_create_with_fetchspec_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_create_with_fetchspec", mrb_Git_git_remote_create_with_fetchspec, MRB_ARGS_ARG(git_remote_create_with_fetchspec_REQUIRED_ARGC, git_remote_create_with_fetchspec_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_default_branch_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_default_branch", mrb_Git_git_remote_default_branch, MRB_ARGS_ARG(git_remote_default_branch_REQUIRED_ARGC, git_remote_default_branch_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_delete_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_delete", mrb_Git_git_remote_delete, MRB_ARGS_ARG(git_remote_delete_REQUIRED_ARGC, git_remote_delete_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_disconnect_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_disconnect", mrb_Git_git_remote_disconnect, MRB_ARGS_ARG(git_remote_disconnect_REQUIRED_ARGC, git_remote_disconnect_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_download_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_download", mrb_Git_git_remote_download, MRB_ARGS_ARG(git_remote_download_REQUIRED_ARGC, git_remote_download_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_dup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_dup", mrb_Git_git_remote_dup, MRB_ARGS_ARG(git_remote_dup_REQUIRED_ARGC, git_remote_dup_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_fetch_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_fetch", mrb_Git_git_remote_fetch, MRB_ARGS_ARG(git_remote_fetch_REQUIRED_ARGC, git_remote_fetch_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_free", mrb_Git_git_remote_free, MRB_ARGS_ARG(git_remote_free_REQUIRED_ARGC, git_remote_free_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_get_fetch_refspecs_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_get_fetch_refspecs", mrb_Git_git_remote_get_fetch_refspecs, MRB_ARGS_ARG(git_remote_get_fetch_refspecs_REQUIRED_ARGC, git_remote_get_fetch_refspecs_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_get_push_refspecs_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_get_push_refspecs", mrb_Git_git_remote_get_push_refspecs, MRB_ARGS_ARG(git_remote_get_push_refspecs_REQUIRED_ARGC, git_remote_get_push_refspecs_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_get_refspec_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_get_refspec", mrb_Git_git_remote_get_refspec, MRB_ARGS_ARG(git_remote_get_refspec_REQUIRED_ARGC, git_remote_get_refspec_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_init_callbacks_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_init_callbacks", mrb_Git_git_remote_init_callbacks, MRB_ARGS_ARG(git_remote_init_callbacks_REQUIRED_ARGC, git_remote_init_callbacks_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_is_valid_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_is_valid_name", mrb_Git_git_remote_is_valid_name, MRB_ARGS_ARG(git_remote_is_valid_name_REQUIRED_ARGC, git_remote_is_valid_name_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_list_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_list", mrb_Git_git_remote_list, MRB_ARGS_ARG(git_remote_list_REQUIRED_ARGC, git_remote_list_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_lookup", mrb_Git_git_remote_lookup, MRB_ARGS_ARG(git_remote_lookup_REQUIRED_ARGC, git_remote_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_ls_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_ls", mrb_Git_git_remote_ls, MRB_ARGS_ARG(git_remote_ls_REQUIRED_ARGC, git_remote_ls_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_name", mrb_Git_git_remote_name, MRB_ARGS_ARG(git_remote_name_REQUIRED_ARGC, git_remote_name_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_owner", mrb_Git_git_remote_owner, MRB_ARGS_ARG(git_remote_owner_REQUIRED_ARGC, git_remote_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_prune_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_prune", mrb_Git_git_remote_prune, MRB_ARGS_ARG(git_remote_prune_REQUIRED_ARGC, git_remote_prune_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_prune_refs_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_prune_refs", mrb_Git_git_remote_prune_refs, MRB_ARGS_ARG(git_remote_prune_refs_REQUIRED_ARGC, git_remote_prune_refs_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_push_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_push", mrb_Git_git_remote_push, MRB_ARGS_ARG(git_remote_push_REQUIRED_ARGC, git_remote_push_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_pushurl_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_pushurl", mrb_Git_git_remote_pushurl, MRB_ARGS_ARG(git_remote_pushurl_REQUIRED_ARGC, git_remote_pushurl_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_refspec_count_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_refspec_count", mrb_Git_git_remote_refspec_count, MRB_ARGS_ARG(git_remote_refspec_count_REQUIRED_ARGC, git_remote_refspec_count_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_rename_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_rename", mrb_Git_git_remote_rename, MRB_ARGS_ARG(git_remote_rename_REQUIRED_ARGC, git_remote_rename_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_set_autotag_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_set_autotag", mrb_Git_git_remote_set_autotag, MRB_ARGS_ARG(git_remote_set_autotag_REQUIRED_ARGC, git_remote_set_autotag_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_set_pushurl_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_set_pushurl", mrb_Git_git_remote_set_pushurl, MRB_ARGS_ARG(git_remote_set_pushurl_REQUIRED_ARGC, git_remote_set_pushurl_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_set_url_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_set_url", mrb_Git_git_remote_set_url, MRB_ARGS_ARG(git_remote_set_url_REQUIRED_ARGC, git_remote_set_url_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_stats_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_stats", mrb_Git_git_remote_stats, MRB_ARGS_ARG(git_remote_stats_REQUIRED_ARGC, git_remote_stats_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_stop_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_stop", mrb_Git_git_remote_stop, MRB_ARGS_ARG(git_remote_stop_REQUIRED_ARGC, git_remote_stop_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_update_tips_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_update_tips", mrb_Git_git_remote_update_tips, MRB_ARGS_ARG(git_remote_update_tips_REQUIRED_ARGC, git_remote_update_tips_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_upload_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_upload", mrb_Git_git_remote_upload, MRB_ARGS_ARG(git_remote_upload_REQUIRED_ARGC, git_remote_upload_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_url_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_url", mrb_Git_git_remote_url, MRB_ARGS_ARG(git_remote_url_REQUIRED_ARGC, git_remote_url_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_config_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_config", mrb_Git_git_repository_config, MRB_ARGS_ARG(git_repository_config_REQUIRED_ARGC, git_repository_config_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_config_snapshot_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_config_snapshot", mrb_Git_git_repository_config_snapshot, MRB_ARGS_ARG(git_repository_config_snapshot_REQUIRED_ARGC, git_repository_config_snapshot_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_detach_head_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_detach_head", mrb_Git_git_repository_detach_head, MRB_ARGS_ARG(git_repository_detach_head_REQUIRED_ARGC, git_repository_detach_head_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_discover_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_discover", mrb_Git_git_repository_discover, MRB_ARGS_ARG(git_repository_discover_REQUIRED_ARGC, git_repository_discover_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_fetchhead_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_fetchhead_foreach", mrb_Git_git_repository_fetchhead_foreach, MRB_ARGS_ARG(git_repository_fetchhead_foreach_REQUIRED_ARGC, git_repository_fetchhead_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_free", mrb_Git_git_repository_free, MRB_ARGS_ARG(git_repository_free_REQUIRED_ARGC, git_repository_free_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_get_namespace_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_get_namespace", mrb_Git_git_repository_get_namespace, MRB_ARGS_ARG(git_repository_get_namespace_REQUIRED_ARGC, git_repository_get_namespace_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_hashfile_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_hashfile", mrb_Git_git_repository_hashfile, MRB_ARGS_ARG(git_repository_hashfile_REQUIRED_ARGC, git_repository_hashfile_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_head_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_head", mrb_Git_git_repository_head, MRB_ARGS_ARG(git_repository_head_REQUIRED_ARGC, git_repository_head_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_head_detached_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_head_detached", mrb_Git_git_repository_head_detached, MRB_ARGS_ARG(git_repository_head_detached_REQUIRED_ARGC, git_repository_head_detached_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_head_unborn_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_head_unborn", mrb_Git_git_repository_head_unborn, MRB_ARGS_ARG(git_repository_head_unborn_REQUIRED_ARGC, git_repository_head_unborn_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_ident_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_ident", mrb_Git_git_repository_ident, MRB_ARGS_ARG(git_repository_ident_REQUIRED_ARGC, git_repository_ident_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_index", mrb_Git_git_repository_index, MRB_ARGS_ARG(git_repository_index_REQUIRED_ARGC, git_repository_index_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_init_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_init", mrb_Git_git_repository_init, MRB_ARGS_ARG(git_repository_init_REQUIRED_ARGC, git_repository_init_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_init_ext_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_init_ext", mrb_Git_git_repository_init_ext, MRB_ARGS_ARG(git_repository_init_ext_REQUIRED_ARGC, git_repository_init_ext_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_init_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_init_init_options", mrb_Git_git_repository_init_init_options, MRB_ARGS_ARG(git_repository_init_init_options_REQUIRED_ARGC, git_repository_init_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_is_bare_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_is_bare", mrb_Git_git_repository_is_bare, MRB_ARGS_ARG(git_repository_is_bare_REQUIRED_ARGC, git_repository_is_bare_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_is_empty_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_is_empty", mrb_Git_git_repository_is_empty, MRB_ARGS_ARG(git_repository_is_empty_REQUIRED_ARGC, git_repository_is_empty_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_is_shallow_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_is_shallow", mrb_Git_git_repository_is_shallow, MRB_ARGS_ARG(git_repository_is_shallow_REQUIRED_ARGC, git_repository_is_shallow_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_mergehead_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_mergehead_foreach", mrb_Git_git_repository_mergehead_foreach, MRB_ARGS_ARG(git_repository_mergehead_foreach_REQUIRED_ARGC, git_repository_mergehead_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_message_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_message", mrb_Git_git_repository_message, MRB_ARGS_ARG(git_repository_message_REQUIRED_ARGC, git_repository_message_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_message_remove_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_message_remove", mrb_Git_git_repository_message_remove, MRB_ARGS_ARG(git_repository_message_remove_REQUIRED_ARGC, git_repository_message_remove_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_odb_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_odb", mrb_Git_git_repository_odb, MRB_ARGS_ARG(git_repository_odb_REQUIRED_ARGC, git_repository_odb_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_open_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_open", mrb_Git_git_repository_open, MRB_ARGS_ARG(git_repository_open_REQUIRED_ARGC, git_repository_open_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_open_bare_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_open_bare", mrb_Git_git_repository_open_bare, MRB_ARGS_ARG(git_repository_open_bare_REQUIRED_ARGC, git_repository_open_bare_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_open_ext_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_open_ext", mrb_Git_git_repository_open_ext, MRB_ARGS_ARG(git_repository_open_ext_REQUIRED_ARGC, git_repository_open_ext_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_path_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_path", mrb_Git_git_repository_path, MRB_ARGS_ARG(git_repository_path_REQUIRED_ARGC, git_repository_path_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_refdb_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_refdb", mrb_Git_git_repository_refdb, MRB_ARGS_ARG(git_repository_refdb_REQUIRED_ARGC, git_repository_refdb_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_set_head_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_set_head", mrb_Git_git_repository_set_head, MRB_ARGS_ARG(git_repository_set_head_REQUIRED_ARGC, git_repository_set_head_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_set_head_detached_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_set_head_detached", mrb_Git_git_repository_set_head_detached, MRB_ARGS_ARG(git_repository_set_head_detached_REQUIRED_ARGC, git_repository_set_head_detached_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_set_head_detached_from_annotated_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_set_head_detached_from_annotated", mrb_Git_git_repository_set_head_detached_from_annotated, MRB_ARGS_ARG(git_repository_set_head_detached_from_annotated_REQUIRED_ARGC, git_repository_set_head_detached_from_annotated_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_set_ident_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_set_ident", mrb_Git_git_repository_set_ident, MRB_ARGS_ARG(git_repository_set_ident_REQUIRED_ARGC, git_repository_set_ident_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_set_namespace_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_set_namespace", mrb_Git_git_repository_set_namespace, MRB_ARGS_ARG(git_repository_set_namespace_REQUIRED_ARGC, git_repository_set_namespace_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_set_workdir_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_set_workdir", mrb_Git_git_repository_set_workdir, MRB_ARGS_ARG(git_repository_set_workdir_REQUIRED_ARGC, git_repository_set_workdir_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_state_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_state", mrb_Git_git_repository_state, MRB_ARGS_ARG(git_repository_state_REQUIRED_ARGC, git_repository_state_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_state_cleanup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_state_cleanup", mrb_Git_git_repository_state_cleanup, MRB_ARGS_ARG(git_repository_state_cleanup_REQUIRED_ARGC, git_repository_state_cleanup_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_workdir_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_workdir", mrb_Git_git_repository_workdir, MRB_ARGS_ARG(git_repository_workdir_REQUIRED_ARGC, git_repository_workdir_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_wrap_odb_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_wrap_odb", mrb_Git_git_repository_wrap_odb, MRB_ARGS_ARG(git_repository_wrap_odb_REQUIRED_ARGC, git_repository_wrap_odb_OPTIONAL_ARGC));
#endif
#if BIND_git_reset_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reset", mrb_Git_git_reset, MRB_ARGS_ARG(git_reset_REQUIRED_ARGC, git_reset_OPTIONAL_ARGC));
#endif
#if BIND_git_reset_default_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reset_default", mrb_Git_git_reset_default, MRB_ARGS_ARG(git_reset_default_REQUIRED_ARGC, git_reset_default_OPTIONAL_ARGC));
#endif
#if BIND_git_reset_from_annotated_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reset_from_annotated", mrb_Git_git_reset_from_annotated, MRB_ARGS_ARG(git_reset_from_annotated_REQUIRED_ARGC, git_reset_from_annotated_OPTIONAL_ARGC));
#endif
#if BIND_git_revert_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revert", mrb_Git_git_revert, MRB_ARGS_ARG(git_revert_REQUIRED_ARGC, git_revert_OPTIONAL_ARGC));
#endif
#if BIND_git_revert_commit_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revert_commit", mrb_Git_git_revert_commit, MRB_ARGS_ARG(git_revert_commit_REQUIRED_ARGC, git_revert_commit_OPTIONAL_ARGC));
#endif
#if BIND_git_revert_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revert_init_options", mrb_Git_git_revert_init_options, MRB_ARGS_ARG(git_revert_init_options_REQUIRED_ARGC, git_revert_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_revparse_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revparse", mrb_Git_git_revparse, MRB_ARGS_ARG(git_revparse_REQUIRED_ARGC, git_revparse_OPTIONAL_ARGC));
#endif
#if BIND_git_revparse_ext_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revparse_ext", mrb_Git_git_revparse_ext, MRB_ARGS_ARG(git_revparse_ext_REQUIRED_ARGC, git_revparse_ext_OPTIONAL_ARGC));
#endif
#if BIND_git_revparse_single_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revparse_single", mrb_Git_git_revparse_single, MRB_ARGS_ARG(git_revparse_single_REQUIRED_ARGC, git_revparse_single_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_add_hide_cb_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_add_hide_cb", mrb_Git_git_revwalk_add_hide_cb, MRB_ARGS_ARG(git_revwalk_add_hide_cb_REQUIRED_ARGC, git_revwalk_add_hide_cb_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_free", mrb_Git_git_revwalk_free, MRB_ARGS_ARG(git_revwalk_free_REQUIRED_ARGC, git_revwalk_free_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_hide_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_hide", mrb_Git_git_revwalk_hide, MRB_ARGS_ARG(git_revwalk_hide_REQUIRED_ARGC, git_revwalk_hide_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_hide_glob_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_hide_glob", mrb_Git_git_revwalk_hide_glob, MRB_ARGS_ARG(git_revwalk_hide_glob_REQUIRED_ARGC, git_revwalk_hide_glob_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_hide_head_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_hide_head", mrb_Git_git_revwalk_hide_head, MRB_ARGS_ARG(git_revwalk_hide_head_REQUIRED_ARGC, git_revwalk_hide_head_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_hide_ref_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_hide_ref", mrb_Git_git_revwalk_hide_ref, MRB_ARGS_ARG(git_revwalk_hide_ref_REQUIRED_ARGC, git_revwalk_hide_ref_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_new", mrb_Git_git_revwalk_new, MRB_ARGS_ARG(git_revwalk_new_REQUIRED_ARGC, git_revwalk_new_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_next_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_next", mrb_Git_git_revwalk_next, MRB_ARGS_ARG(git_revwalk_next_REQUIRED_ARGC, git_revwalk_next_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_push_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_push", mrb_Git_git_revwalk_push, MRB_ARGS_ARG(git_revwalk_push_REQUIRED_ARGC, git_revwalk_push_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_push_glob_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_push_glob", mrb_Git_git_revwalk_push_glob, MRB_ARGS_ARG(git_revwalk_push_glob_REQUIRED_ARGC, git_revwalk_push_glob_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_push_head_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_push_head", mrb_Git_git_revwalk_push_head, MRB_ARGS_ARG(git_revwalk_push_head_REQUIRED_ARGC, git_revwalk_push_head_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_push_range_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_push_range", mrb_Git_git_revwalk_push_range, MRB_ARGS_ARG(git_revwalk_push_range_REQUIRED_ARGC, git_revwalk_push_range_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_push_ref_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_push_ref", mrb_Git_git_revwalk_push_ref, MRB_ARGS_ARG(git_revwalk_push_ref_REQUIRED_ARGC, git_revwalk_push_ref_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_repository_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_repository", mrb_Git_git_revwalk_repository, MRB_ARGS_ARG(git_revwalk_repository_REQUIRED_ARGC, git_revwalk_repository_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_reset_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_reset", mrb_Git_git_revwalk_reset, MRB_ARGS_ARG(git_revwalk_reset_REQUIRED_ARGC, git_revwalk_reset_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_simplify_first_parent_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_simplify_first_parent", mrb_Git_git_revwalk_simplify_first_parent, MRB_ARGS_ARG(git_revwalk_simplify_first_parent_REQUIRED_ARGC, git_revwalk_simplify_first_parent_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_sorting_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_sorting", mrb_Git_git_revwalk_sorting, MRB_ARGS_ARG(git_revwalk_sorting_REQUIRED_ARGC, git_revwalk_sorting_OPTIONAL_ARGC));
#endif
#if BIND_git_signature_default_FUNCTION
  mrb_define_class_method(mrb, Git_module, "signature_default", mrb_Git_git_signature_default, MRB_ARGS_ARG(git_signature_default_REQUIRED_ARGC, git_signature_default_OPTIONAL_ARGC));
#endif
#if BIND_git_signature_dup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "signature_dup", mrb_Git_git_signature_dup, MRB_ARGS_ARG(git_signature_dup_REQUIRED_ARGC, git_signature_dup_OPTIONAL_ARGC));
#endif
#if BIND_git_signature_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "signature_free", mrb_Git_git_signature_free, MRB_ARGS_ARG(git_signature_free_REQUIRED_ARGC, git_signature_free_OPTIONAL_ARGC));
#endif
#if BIND_git_signature_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "signature_new", mrb_Git_git_signature_new, MRB_ARGS_ARG(git_signature_new_REQUIRED_ARGC, git_signature_new_OPTIONAL_ARGC));
#endif
#if BIND_git_signature_now_FUNCTION
  mrb_define_class_method(mrb, Git_module, "signature_now", mrb_Git_git_signature_now, MRB_ARGS_ARG(git_signature_now_REQUIRED_ARGC, git_signature_now_OPTIONAL_ARGC));
#endif
#if BIND_git_stash_apply_FUNCTION
  mrb_define_class_method(mrb, Git_module, "stash_apply", mrb_Git_git_stash_apply, MRB_ARGS_ARG(git_stash_apply_REQUIRED_ARGC, git_stash_apply_OPTIONAL_ARGC));
#endif
#if BIND_git_stash_apply_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "stash_apply_init_options", mrb_Git_git_stash_apply_init_options, MRB_ARGS_ARG(git_stash_apply_init_options_REQUIRED_ARGC, git_stash_apply_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_stash_drop_FUNCTION
  mrb_define_class_method(mrb, Git_module, "stash_drop", mrb_Git_git_stash_drop, MRB_ARGS_ARG(git_stash_drop_REQUIRED_ARGC, git_stash_drop_OPTIONAL_ARGC));
#endif
#if BIND_git_stash_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "stash_foreach", mrb_Git_git_stash_foreach, MRB_ARGS_ARG(git_stash_foreach_REQUIRED_ARGC, git_stash_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_stash_pop_FUNCTION
  mrb_define_class_method(mrb, Git_module, "stash_pop", mrb_Git_git_stash_pop, MRB_ARGS_ARG(git_stash_pop_REQUIRED_ARGC, git_stash_pop_OPTIONAL_ARGC));
#endif
#if BIND_git_stash_save_FUNCTION
  mrb_define_class_method(mrb, Git_module, "stash_save", mrb_Git_git_stash_save, MRB_ARGS_ARG(git_stash_save_REQUIRED_ARGC, git_stash_save_OPTIONAL_ARGC));
#endif
#if BIND_git_status_byindex_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_byindex", mrb_Git_git_status_byindex, MRB_ARGS_ARG(git_status_byindex_REQUIRED_ARGC, git_status_byindex_OPTIONAL_ARGC));
#endif
#if BIND_git_status_file_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_file", mrb_Git_git_status_file, MRB_ARGS_ARG(git_status_file_REQUIRED_ARGC, git_status_file_OPTIONAL_ARGC));
#endif
#if BIND_git_status_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_foreach", mrb_Git_git_status_foreach, MRB_ARGS_ARG(git_status_foreach_REQUIRED_ARGC, git_status_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_status_foreach_ext_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_foreach_ext", mrb_Git_git_status_foreach_ext, MRB_ARGS_ARG(git_status_foreach_ext_REQUIRED_ARGC, git_status_foreach_ext_OPTIONAL_ARGC));
#endif
#if BIND_git_status_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_init_options", mrb_Git_git_status_init_options, MRB_ARGS_ARG(git_status_init_options_REQUIRED_ARGC, git_status_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_status_list_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_list_entrycount", mrb_Git_git_status_list_entrycount, MRB_ARGS_ARG(git_status_list_entrycount_REQUIRED_ARGC, git_status_list_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_status_list_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_list_free", mrb_Git_git_status_list_free, MRB_ARGS_ARG(git_status_list_free_REQUIRED_ARGC, git_status_list_free_OPTIONAL_ARGC));
#endif
#if BIND_git_status_list_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_list_new", mrb_Git_git_status_list_new, MRB_ARGS_ARG(git_status_list_new_REQUIRED_ARGC, git_status_list_new_OPTIONAL_ARGC));
#endif
#if BIND_git_status_should_ignore_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_should_ignore", mrb_Git_git_status_should_ignore, MRB_ARGS_ARG(git_status_should_ignore_REQUIRED_ARGC, git_status_should_ignore_OPTIONAL_ARGC));
#endif
#if BIND_git_strarray_copy_FUNCTION
  mrb_define_class_method(mrb, Git_module, "strarray_copy", mrb_Git_git_strarray_copy, MRB_ARGS_ARG(git_strarray_copy_REQUIRED_ARGC, git_strarray_copy_OPTIONAL_ARGC));
#endif
#if BIND_git_strarray_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "strarray_free", mrb_Git_git_strarray_free, MRB_ARGS_ARG(git_strarray_free_REQUIRED_ARGC, git_strarray_free_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_add_finalize_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_add_finalize", mrb_Git_git_submodule_add_finalize, MRB_ARGS_ARG(git_submodule_add_finalize_REQUIRED_ARGC, git_submodule_add_finalize_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_add_setup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_add_setup", mrb_Git_git_submodule_add_setup, MRB_ARGS_ARG(git_submodule_add_setup_REQUIRED_ARGC, git_submodule_add_setup_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_add_to_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_add_to_index", mrb_Git_git_submodule_add_to_index, MRB_ARGS_ARG(git_submodule_add_to_index_REQUIRED_ARGC, git_submodule_add_to_index_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_branch_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_branch", mrb_Git_git_submodule_branch, MRB_ARGS_ARG(git_submodule_branch_REQUIRED_ARGC, git_submodule_branch_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_fetch_recurse_submodules_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_fetch_recurse_submodules", mrb_Git_git_submodule_fetch_recurse_submodules, MRB_ARGS_ARG(git_submodule_fetch_recurse_submodules_REQUIRED_ARGC, git_submodule_fetch_recurse_submodules_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_foreach", mrb_Git_git_submodule_foreach, MRB_ARGS_ARG(git_submodule_foreach_REQUIRED_ARGC, git_submodule_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_free", mrb_Git_git_submodule_free, MRB_ARGS_ARG(git_submodule_free_REQUIRED_ARGC, git_submodule_free_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_head_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_head_id", mrb_Git_git_submodule_head_id, MRB_ARGS_ARG(git_submodule_head_id_REQUIRED_ARGC, git_submodule_head_id_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_ignore_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_ignore", mrb_Git_git_submodule_ignore, MRB_ARGS_ARG(git_submodule_ignore_REQUIRED_ARGC, git_submodule_ignore_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_index_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_index_id", mrb_Git_git_submodule_index_id, MRB_ARGS_ARG(git_submodule_index_id_REQUIRED_ARGC, git_submodule_index_id_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_init_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_init", mrb_Git_git_submodule_init, MRB_ARGS_ARG(git_submodule_init_REQUIRED_ARGC, git_submodule_init_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_location_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_location", mrb_Git_git_submodule_location, MRB_ARGS_ARG(git_submodule_location_REQUIRED_ARGC, git_submodule_location_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_lookup", mrb_Git_git_submodule_lookup, MRB_ARGS_ARG(git_submodule_lookup_REQUIRED_ARGC, git_submodule_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_name", mrb_Git_git_submodule_name, MRB_ARGS_ARG(git_submodule_name_REQUIRED_ARGC, git_submodule_name_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_open_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_open", mrb_Git_git_submodule_open, MRB_ARGS_ARG(git_submodule_open_REQUIRED_ARGC, git_submodule_open_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_owner", mrb_Git_git_submodule_owner, MRB_ARGS_ARG(git_submodule_owner_REQUIRED_ARGC, git_submodule_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_path_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_path", mrb_Git_git_submodule_path, MRB_ARGS_ARG(git_submodule_path_REQUIRED_ARGC, git_submodule_path_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_reload_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_reload", mrb_Git_git_submodule_reload, MRB_ARGS_ARG(git_submodule_reload_REQUIRED_ARGC, git_submodule_reload_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_repo_init_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_repo_init", mrb_Git_git_submodule_repo_init, MRB_ARGS_ARG(git_submodule_repo_init_REQUIRED_ARGC, git_submodule_repo_init_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_resolve_url_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_resolve_url", mrb_Git_git_submodule_resolve_url, MRB_ARGS_ARG(git_submodule_resolve_url_REQUIRED_ARGC, git_submodule_resolve_url_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_set_branch_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_set_branch", mrb_Git_git_submodule_set_branch, MRB_ARGS_ARG(git_submodule_set_branch_REQUIRED_ARGC, git_submodule_set_branch_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_set_fetch_recurse_submodules_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_set_fetch_recurse_submodules", mrb_Git_git_submodule_set_fetch_recurse_submodules, MRB_ARGS_ARG(git_submodule_set_fetch_recurse_submodules_REQUIRED_ARGC, git_submodule_set_fetch_recurse_submodules_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_set_ignore_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_set_ignore", mrb_Git_git_submodule_set_ignore, MRB_ARGS_ARG(git_submodule_set_ignore_REQUIRED_ARGC, git_submodule_set_ignore_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_set_update_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_set_update", mrb_Git_git_submodule_set_update, MRB_ARGS_ARG(git_submodule_set_update_REQUIRED_ARGC, git_submodule_set_update_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_set_url_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_set_url", mrb_Git_git_submodule_set_url, MRB_ARGS_ARG(git_submodule_set_url_REQUIRED_ARGC, git_submodule_set_url_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_status_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_status", mrb_Git_git_submodule_status, MRB_ARGS_ARG(git_submodule_status_REQUIRED_ARGC, git_submodule_status_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_sync_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_sync", mrb_Git_git_submodule_sync, MRB_ARGS_ARG(git_submodule_sync_REQUIRED_ARGC, git_submodule_sync_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_update_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_update", mrb_Git_git_submodule_update, MRB_ARGS_ARG(git_submodule_update_REQUIRED_ARGC, git_submodule_update_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_update_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_update_init_options", mrb_Git_git_submodule_update_init_options, MRB_ARGS_ARG(git_submodule_update_init_options_REQUIRED_ARGC, git_submodule_update_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_update_strategy_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_update_strategy", mrb_Git_git_submodule_update_strategy, MRB_ARGS_ARG(git_submodule_update_strategy_REQUIRED_ARGC, git_submodule_update_strategy_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_url_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_url", mrb_Git_git_submodule_url, MRB_ARGS_ARG(git_submodule_url_REQUIRED_ARGC, git_submodule_url_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_wd_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_wd_id", mrb_Git_git_submodule_wd_id, MRB_ARGS_ARG(git_submodule_wd_id_REQUIRED_ARGC, git_submodule_wd_id_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_annotation_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_annotation_create", mrb_Git_git_tag_annotation_create, MRB_ARGS_ARG(git_tag_annotation_create_REQUIRED_ARGC, git_tag_annotation_create_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_create", mrb_Git_git_tag_create, MRB_ARGS_ARG(git_tag_create_REQUIRED_ARGC, git_tag_create_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_create_frombuffer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_create_frombuffer", mrb_Git_git_tag_create_frombuffer, MRB_ARGS_ARG(git_tag_create_frombuffer_REQUIRED_ARGC, git_tag_create_frombuffer_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_create_lightweight_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_create_lightweight", mrb_Git_git_tag_create_lightweight, MRB_ARGS_ARG(git_tag_create_lightweight_REQUIRED_ARGC, git_tag_create_lightweight_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_delete_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_delete", mrb_Git_git_tag_delete, MRB_ARGS_ARG(git_tag_delete_REQUIRED_ARGC, git_tag_delete_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_foreach", mrb_Git_git_tag_foreach, MRB_ARGS_ARG(git_tag_foreach_REQUIRED_ARGC, git_tag_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_free", mrb_Git_git_tag_free, MRB_ARGS_ARG(git_tag_free_REQUIRED_ARGC, git_tag_free_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_id", mrb_Git_git_tag_id, MRB_ARGS_ARG(git_tag_id_REQUIRED_ARGC, git_tag_id_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_list_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_list", mrb_Git_git_tag_list, MRB_ARGS_ARG(git_tag_list_REQUIRED_ARGC, git_tag_list_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_list_match_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_list_match", mrb_Git_git_tag_list_match, MRB_ARGS_ARG(git_tag_list_match_REQUIRED_ARGC, git_tag_list_match_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_lookup", mrb_Git_git_tag_lookup, MRB_ARGS_ARG(git_tag_lookup_REQUIRED_ARGC, git_tag_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_lookup_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_lookup_prefix", mrb_Git_git_tag_lookup_prefix, MRB_ARGS_ARG(git_tag_lookup_prefix_REQUIRED_ARGC, git_tag_lookup_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_message_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_message", mrb_Git_git_tag_message, MRB_ARGS_ARG(git_tag_message_REQUIRED_ARGC, git_tag_message_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_name", mrb_Git_git_tag_name, MRB_ARGS_ARG(git_tag_name_REQUIRED_ARGC, git_tag_name_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_owner", mrb_Git_git_tag_owner, MRB_ARGS_ARG(git_tag_owner_REQUIRED_ARGC, git_tag_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_peel_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_peel", mrb_Git_git_tag_peel, MRB_ARGS_ARG(git_tag_peel_REQUIRED_ARGC, git_tag_peel_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_tagger_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_tagger", mrb_Git_git_tag_tagger, MRB_ARGS_ARG(git_tag_tagger_REQUIRED_ARGC, git_tag_tagger_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_target_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_target", mrb_Git_git_tag_target, MRB_ARGS_ARG(git_tag_target_REQUIRED_ARGC, git_tag_target_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_target_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_target_id", mrb_Git_git_tag_target_id, MRB_ARGS_ARG(git_tag_target_id_REQUIRED_ARGC, git_tag_target_id_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_target_type_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_target_type", mrb_Git_git_tag_target_type, MRB_ARGS_ARG(git_tag_target_type_REQUIRED_ARGC, git_tag_target_type_OPTIONAL_ARGC));
#endif
#if BIND_git_trace_set_FUNCTION
  mrb_define_class_method(mrb, Git_module, "trace_set", mrb_Git_git_trace_set, MRB_ARGS_ARG(git_trace_set_REQUIRED_ARGC, git_trace_set_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_commit_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_commit", mrb_Git_git_transaction_commit, MRB_ARGS_ARG(git_transaction_commit_REQUIRED_ARGC, git_transaction_commit_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_free", mrb_Git_git_transaction_free, MRB_ARGS_ARG(git_transaction_free_REQUIRED_ARGC, git_transaction_free_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_lock_ref_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_lock_ref", mrb_Git_git_transaction_lock_ref, MRB_ARGS_ARG(git_transaction_lock_ref_REQUIRED_ARGC, git_transaction_lock_ref_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_new", mrb_Git_git_transaction_new, MRB_ARGS_ARG(git_transaction_new_REQUIRED_ARGC, git_transaction_new_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_remove_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_remove", mrb_Git_git_transaction_remove, MRB_ARGS_ARG(git_transaction_remove_REQUIRED_ARGC, git_transaction_remove_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_set_reflog_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_set_reflog", mrb_Git_git_transaction_set_reflog, MRB_ARGS_ARG(git_transaction_set_reflog_REQUIRED_ARGC, git_transaction_set_reflog_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_set_symbolic_target_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_set_symbolic_target", mrb_Git_git_transaction_set_symbolic_target, MRB_ARGS_ARG(git_transaction_set_symbolic_target_REQUIRED_ARGC, git_transaction_set_symbolic_target_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_set_target_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_set_target", mrb_Git_git_transaction_set_target, MRB_ARGS_ARG(git_transaction_set_target_REQUIRED_ARGC, git_transaction_set_target_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_byid_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_byid", mrb_Git_git_tree_entry_byid, MRB_ARGS_ARG(git_tree_entry_byid_REQUIRED_ARGC, git_tree_entry_byid_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_byindex_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_byindex", mrb_Git_git_tree_entry_byindex, MRB_ARGS_ARG(git_tree_entry_byindex_REQUIRED_ARGC, git_tree_entry_byindex_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_byname_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_byname", mrb_Git_git_tree_entry_byname, MRB_ARGS_ARG(git_tree_entry_byname_REQUIRED_ARGC, git_tree_entry_byname_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_bypath_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_bypath", mrb_Git_git_tree_entry_bypath, MRB_ARGS_ARG(git_tree_entry_bypath_REQUIRED_ARGC, git_tree_entry_bypath_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_cmp_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_cmp", mrb_Git_git_tree_entry_cmp, MRB_ARGS_ARG(git_tree_entry_cmp_REQUIRED_ARGC, git_tree_entry_cmp_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_dup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_dup", mrb_Git_git_tree_entry_dup, MRB_ARGS_ARG(git_tree_entry_dup_REQUIRED_ARGC, git_tree_entry_dup_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_filemode_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_filemode", mrb_Git_git_tree_entry_filemode, MRB_ARGS_ARG(git_tree_entry_filemode_REQUIRED_ARGC, git_tree_entry_filemode_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_filemode_raw_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_filemode_raw", mrb_Git_git_tree_entry_filemode_raw, MRB_ARGS_ARG(git_tree_entry_filemode_raw_REQUIRED_ARGC, git_tree_entry_filemode_raw_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_free", mrb_Git_git_tree_entry_free, MRB_ARGS_ARG(git_tree_entry_free_REQUIRED_ARGC, git_tree_entry_free_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_id", mrb_Git_git_tree_entry_id, MRB_ARGS_ARG(git_tree_entry_id_REQUIRED_ARGC, git_tree_entry_id_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_name", mrb_Git_git_tree_entry_name, MRB_ARGS_ARG(git_tree_entry_name_REQUIRED_ARGC, git_tree_entry_name_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_to_object_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_to_object", mrb_Git_git_tree_entry_to_object, MRB_ARGS_ARG(git_tree_entry_to_object_REQUIRED_ARGC, git_tree_entry_to_object_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_type_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_type", mrb_Git_git_tree_entry_type, MRB_ARGS_ARG(git_tree_entry_type_REQUIRED_ARGC, git_tree_entry_type_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entrycount", mrb_Git_git_tree_entrycount, MRB_ARGS_ARG(git_tree_entrycount_REQUIRED_ARGC, git_tree_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_free", mrb_Git_git_tree_free, MRB_ARGS_ARG(git_tree_free_REQUIRED_ARGC, git_tree_free_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_id", mrb_Git_git_tree_id, MRB_ARGS_ARG(git_tree_id_REQUIRED_ARGC, git_tree_id_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_lookup", mrb_Git_git_tree_lookup, MRB_ARGS_ARG(git_tree_lookup_REQUIRED_ARGC, git_tree_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_lookup_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_lookup_prefix", mrb_Git_git_tree_lookup_prefix, MRB_ARGS_ARG(git_tree_lookup_prefix_REQUIRED_ARGC, git_tree_lookup_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_owner", mrb_Git_git_tree_owner, MRB_ARGS_ARG(git_tree_owner_REQUIRED_ARGC, git_tree_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_walk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_walk", mrb_Git_git_tree_walk, MRB_ARGS_ARG(git_tree_walk_REQUIRED_ARGC, git_tree_walk_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_clear_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_clear", mrb_Git_git_treebuilder_clear, MRB_ARGS_ARG(git_treebuilder_clear_REQUIRED_ARGC, git_treebuilder_clear_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_entrycount", mrb_Git_git_treebuilder_entrycount, MRB_ARGS_ARG(git_treebuilder_entrycount_REQUIRED_ARGC, git_treebuilder_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_filter_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_filter", mrb_Git_git_treebuilder_filter, MRB_ARGS_ARG(git_treebuilder_filter_REQUIRED_ARGC, git_treebuilder_filter_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_free", mrb_Git_git_treebuilder_free, MRB_ARGS_ARG(git_treebuilder_free_REQUIRED_ARGC, git_treebuilder_free_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_get_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_get", mrb_Git_git_treebuilder_get, MRB_ARGS_ARG(git_treebuilder_get_REQUIRED_ARGC, git_treebuilder_get_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_insert_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_insert", mrb_Git_git_treebuilder_insert, MRB_ARGS_ARG(git_treebuilder_insert_REQUIRED_ARGC, git_treebuilder_insert_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_new", mrb_Git_git_treebuilder_new, MRB_ARGS_ARG(git_treebuilder_new_REQUIRED_ARGC, git_treebuilder_new_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_remove_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_remove", mrb_Git_git_treebuilder_remove, MRB_ARGS_ARG(git_treebuilder_remove_REQUIRED_ARGC, git_treebuilder_remove_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_write_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_write", mrb_Git_git_treebuilder_write, MRB_ARGS_ARG(git_treebuilder_write_REQUIRED_ARGC, git_treebuilder_write_OPTIONAL_ARGC));
#endif
#if BIND_giterr_clear_FUNCTION
  mrb_define_class_method(mrb, Git_module, "err_clear", mrb_Git_giterr_clear, MRB_ARGS_ARG(giterr_clear_REQUIRED_ARGC, giterr_clear_OPTIONAL_ARGC));
#endif
#if BIND_giterr_last_FUNCTION
  mrb_define_class_method(mrb, Git_module, "err_last", mrb_Git_giterr_last, MRB_ARGS_ARG(giterr_last_REQUIRED_ARGC, giterr_last_OPTIONAL_ARGC));
#endif
#if BIND_giterr_set_oom_FUNCTION
  mrb_define_class_method(mrb, Git_module, "err_set_oom", mrb_Git_giterr_set_oom, MRB_ARGS_ARG(giterr_set_oom_REQUIRED_ARGC, giterr_set_oom_OPTIONAL_ARGC));
#endif
#if BIND_giterr_set_str_FUNCTION
  mrb_define_class_method(mrb, Git_module, "err_set_str", mrb_Git_giterr_set_str, MRB_ARGS_ARG(giterr_set_str_REQUIRED_ARGC, giterr_set_str_OPTIONAL_ARGC));
#endif
#if BIND_imaxdiv_FUNCTION
  mrb_define_class_method(mrb, Git_module, "imaxdiv", mrb_Git_imaxdiv, MRB_ARGS_ARG(imaxdiv_REQUIRED_ARGC, imaxdiv_OPTIONAL_ARGC));
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: post_module_definition */
/* sha: user_defined */

/* MRUBY_BINDING_END */
}

void mrb_mruby_git_gem_final(mrb_state* mrb){
/* MRUBY_BINDING: module_final */
/* sha: user_defined */

/* MRUBY_BINDING_END */
}

/* MRUBY_BINDING: footer */
/* sha: user_defined */

/* MRUBY_BINDING_END */

#ifdef __cplusplus
}
#endif
