#include "mruby_Git.h"

/* MRUBY_BINDING: header */
/* sha: user_defined */

mrb_value
mruby_git_giftwrap_object_virtual(mrb_state * mrb, git_object * native_object) {
  mrb_value object = mrb_nil_value();
  if (native_object == NULL) {
    return object;
  }
  switch (git_object_type(native_object)) {
  case GIT_OBJ_COMMIT:
    object = mruby_giftwrap_git_commit(mrb, (git_commit*)native_object);
    break;
  case GIT_OBJ_TAG:
    object = mruby_giftwrap_git_tag(mrb, (git_tag*)native_object);
    break;
  case GIT_OBJ_BLOB:
    object = mruby_giftwrap_git_blob(mrb, (git_blob*)native_object);
    break;
  case GIT_OBJ_TREE:
    object = mruby_giftwrap_git_tree(mrb, (git_tree*)native_object);
    break;
  }
  return object;
}

static mrb_value
mruby_git_last_error(mrb_state * mrb) {
  const git_error * last_err = giterr_last();
  if (last_err == NULL || last_err->klass == GITERR_NONE) {
    return mrb_nil_value();
  }
  
  struct RClass * err_class = NULL;
  switch (last_err->klass) {
    case GITERR_NOMEMORY:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "NoMemoryError");
      break;
    case GITERR_OS:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "OSError");
      break;
    case GITERR_INVALID:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "InvalidError");
      break;
    case GITERR_REFERENCE:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "ReferenceError");
      break;
    case GITERR_ZLIB:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "ZLibError");
      break;
    case GITERR_REPOSITORY:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "RepositoryError");
      break;
    case GITERR_CONFIG:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "ConfigError");
      break;
    case GITERR_REGEX:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "RegexError");
      break;
    case GITERR_ODB:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "ODBError");
      break;
    case GITERR_INDEX:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "IndexError");
      break;
    case GITERR_OBJECT:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "ObjectError");
      break;
    case GITERR_NET:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "NetError");
      break;
    case GITERR_TAG:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "TagError");
      break;
    case GITERR_TREE:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "TreeError");
      break;
    case GITERR_INDEXER:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "IndexerError");
      break;
    case GITERR_SSL:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "SSLError");
      break;
    case GITERR_SUBMODULE:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "SubmoduleError");
      break;
    case GITERR_THREAD:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "ThreadError");
      break;
    case GITERR_STASH:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "StashError");
      break;
    case GITERR_CHECKOUT:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "CheckoutError");
      break;
    case GITERR_FETCHHEAD:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "FetchHeadError");
      break;
    case GITERR_MERGE:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "MergeError");
      break;
    case GITERR_SSH:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "SSHError");
      break;
    case GITERR_FILTER:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "FilterError");
      break;
    case GITERR_REVERT:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "RevertError");
      break;
    case GITERR_CALLBACK:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "CallbackError");
      break;
    case GITERR_CHERRYPICK:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "CherrypickError");
      break;
    case GITERR_DESCRIBE:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "DescribeError");
      break;
    case GITERR_REBASE:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "RebaseError");
      break;
    case GITERR_FILESYSTEM:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "FileSystemError");
      break;
    default:
      err_class = mrb_class_get_under(mrb, Git_module(mrb), "Error");
  }

  /* initialize the error */
  return mrb_funcall(mrb, mrb_obj_value(err_class), "new", 1, mrb_str_new_cstr(mrb, last_err->message));
}

void raise_git_error(mrb_state * mrb) {
  mrb_value err = mruby_git_last_error(mrb);
  if (!mrb_nil_p(err)) {
    mrb_exc_raise(mrb, err);
  }
}
/* MRUBY_BINDING_END */

#ifdef __cplusplus
extern "C" {
#endif

/* MRUBY_BINDING: git_annotated_commit_free */
/* sha: c10baf7d74ff0b9957c2dad680ed77de3deddc377ee224662800d4bc0eb5ad87 */
#if BIND_git_annotated_commit_free_FUNCTION
#define git_annotated_commit_free_REQUIRED_ARGC 1
#define git_annotated_commit_free_OPTIONAL_ARGC 0
/* git_annotated_commit_free
 *
 * Parameters:
 * - commit: git_annotated_commit *
 * Return Type: void
 */
mrb_value
mrb_Git_git_annotated_commit_free(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  git_annotated_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_annotated_commit(commit));

  /* Invocation */
  git_annotated_commit_free(native_commit);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_annotated_commit_from_fetchhead */
/* sha: 676c1dae43abde1a596c95ef6adb61d99ee5642452d70bf0d537392e9ec5dfd9 */
#if BIND_git_annotated_commit_from_fetchhead_FUNCTION
#define git_annotated_commit_from_fetchhead_REQUIRED_ARGC 4
#define git_annotated_commit_from_fetchhead_OPTIONAL_ARGC 0
/* git_annotated_commit_from_fetchhead
 *
 * Parameters:
 * - repo: git_repository *
 * - branch_name: const char *
 * - remote_url: const char *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_annotated_commit_from_fetchhead(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_annotated_commit * native_out = NULL;
  mrb_value repo;
  char * native_branch_name = NULL;
  char * native_remote_url = NULL;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzo", &repo, &native_branch_name, &native_remote_url, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_annotated_commit_from_fetchhead(&native_out, native_repo, native_branch_name, native_remote_url, native_id);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_annotated_commit(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_annotated_commit_from_ref */
/* sha: 32fcbbc5ba82533a46f703be20e83230eeebc5b66f89321d5645de646c651299 */
#if BIND_git_annotated_commit_from_ref_FUNCTION
#define git_annotated_commit_from_ref_REQUIRED_ARGC 2
#define git_annotated_commit_from_ref_OPTIONAL_ARGC 0
/* git_annotated_commit_from_ref
 *
 * Parameters:
 * - repo: git_repository *
 * - ref: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_annotated_commit_from_ref(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_annotated_commit * native_out = NULL;
  mrb_value repo;
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_annotated_commit_from_ref(&native_out, native_repo, native_ref);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_annotated_commit(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_annotated_commit_from_revspec */
/* sha: 7e9d4a97e1f74bc4c198e342a45a8673261ca4c8a462130de08b9159e7127e11 */
#if BIND_git_annotated_commit_from_revspec_FUNCTION
#define git_annotated_commit_from_revspec_REQUIRED_ARGC 2
#define git_annotated_commit_from_revspec_OPTIONAL_ARGC 0
/* git_annotated_commit_from_revspec
 *
 * Parameters:
 * - repo: git_repository *
 * - revspec: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_annotated_commit_from_revspec(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_annotated_commit * native_out = NULL;
  mrb_value repo;
  char * native_revspec = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_revspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_annotated_commit_from_revspec(&native_out, native_repo, native_revspec);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_annotated_commit(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_annotated_commit_id */
/* sha: 03aac0a4fd8cc604fa9cd0334de237690566b81f0931152451681720f820288d */
#if BIND_git_annotated_commit_id_FUNCTION
#define git_annotated_commit_id_REQUIRED_ARGC 1
#define git_annotated_commit_id_OPTIONAL_ARGC 0
/* git_annotated_commit_id
 *
 * Parameters:
 * - commit: const git_annotated_commit *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_annotated_commit_id(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_annotated_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_annotated_commit(commit));

  /* Invocation */
  const git_oid * native_return_value = git_annotated_commit_id(native_commit);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_annotated_commit_lookup */
/* sha: 189470f4d049d22b3224ba1b405ba63c134872ad538a46080a7686ec87c9739c */
#if BIND_git_annotated_commit_lookup_FUNCTION
#define git_annotated_commit_lookup_REQUIRED_ARGC 2
#define git_annotated_commit_lookup_OPTIONAL_ARGC 0
/* git_annotated_commit_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_annotated_commit_lookup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_annotated_commit * native_out = NULL;
  mrb_value repo;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_annotated_commit_lookup(&native_out, native_repo, native_id);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_annotated_commit(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_attr_add_macro */
/* sha: f2488236819471731e17b780e8f568754c1f1cb051a43d5dee2ba4ffe0e26fce */
#if BIND_git_attr_add_macro_FUNCTION
#define git_attr_add_macro_REQUIRED_ARGC 3
#define git_attr_add_macro_OPTIONAL_ARGC 0
/* git_attr_add_macro
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - values: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_attr_add_macro(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_name = NULL;
  char * native_values = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_name, &native_values);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_attr_add_macro(native_repo, native_name, native_values);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_attr_cache_flush */
/* sha: 06ab8bcb73a66e6e03b44c29654356edb8528e60e5d15493b23828c8cf482979 */
#if BIND_git_attr_cache_flush_FUNCTION
#define git_attr_cache_flush_REQUIRED_ARGC 1
#define git_attr_cache_flush_OPTIONAL_ARGC 0
/* git_attr_cache_flush
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: void
 */
mrb_value
mrb_Git_git_attr_cache_flush(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  git_attr_cache_flush(native_repo);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_attr_foreach */
/* sha: 7aca95848f9849f8264596d518bb142f627e7d34b1d60c992276ba6d71105695 */
#if BIND_git_attr_foreach_FUNCTION
#define git_attr_foreach_REQUIRED_ARGC 5
#define git_attr_foreach_OPTIONAL_ARGC 0
/* git_attr_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - flags: uint32_t
 * - path: const char *
 * - callback: git_attr_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_attr_foreach(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_int native_flags;
  char * native_path = NULL;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oizoo", &repo, &native_flags, &native_path, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  int (*native_callback)(const char *, const char *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_attr_foreach(native_repo, native_flags, native_path, native_callback, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_attr_get */
/* sha: a1d9436c75450c39125f1a24d69df9f6bdb6c32a1f310d6a5e75b064bf1911aa */
#if BIND_git_attr_get_FUNCTION
#define git_attr_get_REQUIRED_ARGC 4
#define git_attr_get_OPTIONAL_ARGC 0
/* git_attr_get
 *
 * Parameters:
 * - repo: git_repository *
 * - flags: uint32_t
 * - path: const char *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_attr_get(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  char * native_value_out = NULL;
  mrb_value repo;
  mrb_int native_flags;
  char * native_path = NULL;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oizz", &repo, &native_flags, &native_path, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_attr_get(&native_value_out, native_repo, native_flags, native_path, native_name);

  /* Box out param: value_out */
  mrb_value value_out = native_value_out ==  NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_value_out);

  RAISE_GIT_ERROR(native_return_value);

  return value_out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_attr_get_many */
/* sha: ac94a0409b2fb27d5d7642afd00050e911680f6db4a7b47f2cb13da9825dd1b1 */
#if BIND_git_attr_get_many_FUNCTION
#define git_attr_get_many_REQUIRED_ARGC 6
#define git_attr_get_many_OPTIONAL_ARGC 0
/* git_attr_get_many
 *
 * Parameters:
 * - values_out: const char **
 * - repo: git_repository *
 * - flags: uint32_t
 * - path: const char *
 * - num_attr: size_t
 * - names: const char **
 * Return Type: int
 */
mrb_value
mrb_Git_git_attr_get_many(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value values_out;
  mrb_value repo;
  mrb_int native_flags;
  char * native_path = NULL;
  mrb_int native_num_attr;
  mrb_value names;

  /* Fetch the args */
  mrb_get_args(mrb, "ooizio", &values_out, &repo, &native_flags, &native_path, &native_num_attr, &names);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(values_out);
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_PTR(names);

  /* Unbox param: values_out */
  const char ** native_values_out = TODO_mruby_unbox_char_PTR_PTR(values_out);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: names */
  const char ** native_names = TODO_mruby_unbox_char_PTR_PTR(names);

  /* Invocation */
  int native_return_value = git_attr_get_many(native_values_out, native_repo, native_flags, native_path, native_num_attr, native_names);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_attr_value */
/* sha: aa487003555e3ef7b4d32d313cb98152218e21f7d4ce94425fb1c69b436508b9 */
#if BIND_git_attr_value_FUNCTION
#define git_attr_value_REQUIRED_ARGC 1
#define git_attr_value_OPTIONAL_ARGC 0
/* git_attr_value
 *
 * Parameters:
 * - attr: const char *
 * Return Type: git_attr_t
 */
mrb_value
mrb_Git_git_attr_value(mrb_state* mrb, mrb_value self) {
  char * native_attr = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_attr);

  /* Invocation */
  git_attr_t native_return_value = git_attr_value(native_attr);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blame_buffer */
/* sha: a938962ea7ae165f7c866070ce7ef399983031b4c8d5dd93b6515d3ea2bef2db */
#if BIND_git_blame_buffer_FUNCTION
#define git_blame_buffer_REQUIRED_ARGC 3
#define git_blame_buffer_OPTIONAL_ARGC 0
/* git_blame_buffer
 *
 * Parameters:
 * - reference: git_blame *
 * - buffer: const char *
 * - buffer_len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_blame_buffer(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_blame * native_out = NULL;
  mrb_value reference;
  char * native_buffer = NULL;
  mrb_int native_buffer_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &reference, &native_buffer, &native_buffer_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, reference, Blame_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blame expected");
    return mrb_nil_value();
  }

  /* Unbox param: reference */
  git_blame * native_reference = (mrb_nil_p(reference) ? NULL : mruby_unbox_git_blame(reference));

  /* Invocation */
  int native_return_value = git_blame_buffer(&native_out, native_reference, native_buffer, native_buffer_len);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_blame(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blame_file */
/* sha: 81654dd2321f5f45848caddaf6ddf39485b1d9ef6a63a049d093eb8a2708aff0 */
#if BIND_git_blame_file_FUNCTION
#define git_blame_file_REQUIRED_ARGC 3
#define git_blame_file_OPTIONAL_ARGC 0
/* git_blame_file
 *
 * Parameters:
 * - repo: git_repository *
 * - path: const char *
 * - options: git_blame_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_blame_file(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_blame * native_out = NULL;
  mrb_value repo;
  char * native_path = NULL;
  mrb_value options;

  /* Fetch the args */
  mrb_get_args(mrb, "ozo", &repo, &native_path, &options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, options, BlameOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "BlameOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: options */
  git_blame_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_blame_options(options));

  /* Invocation */
  int native_return_value = git_blame_file(&native_out, native_repo, native_path, native_options);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_blame(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blame_free */
/* sha: 1b57908a45f2826eb88205486f3d228fcbf435982ec3c3f1f2ddea8fcab4cc2b */
#if BIND_git_blame_free_FUNCTION
#define git_blame_free_REQUIRED_ARGC 1
#define git_blame_free_OPTIONAL_ARGC 0
/* git_blame_free
 *
 * Parameters:
 * - blame: git_blame *
 * Return Type: void
 */
mrb_value
mrb_Git_git_blame_free(mrb_state* mrb, mrb_value self) {
  mrb_value blame;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blame);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blame, Blame_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blame expected");
    return mrb_nil_value();
  }

  /* Unbox param: blame */
  git_blame * native_blame = (mrb_nil_p(blame) ? NULL : mruby_unbox_git_blame(blame));

  /* Invocation */
  git_blame_free(native_blame);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blame_get_hunk_byindex */
/* sha: c0617822a989e5f3144a46ce55bc378335d4010697f44d7bdd33e194bdf3b47f */
#if BIND_git_blame_get_hunk_byindex_FUNCTION
#define git_blame_get_hunk_byindex_REQUIRED_ARGC 2
#define git_blame_get_hunk_byindex_OPTIONAL_ARGC 0
/* git_blame_get_hunk_byindex
 *
 * Parameters:
 * - blame: git_blame *
 * - index: uint32_t
 * Return Type: const git_blame_hunk *
 */
mrb_value
mrb_Git_git_blame_get_hunk_byindex(mrb_state* mrb, mrb_value self) {
  mrb_value blame;
  mrb_int native_index;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &blame, &native_index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blame, Blame_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blame expected");
    return mrb_nil_value();
  }

  /* Unbox param: blame */
  git_blame * native_blame = (mrb_nil_p(blame) ? NULL : mruby_unbox_git_blame(blame));

  /* Invocation */
  const git_blame_hunk * native_return_value = git_blame_get_hunk_byindex(native_blame, native_index);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_blame_hunk(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blame_get_hunk_byline */
/* sha: 6db3ad327fd85c4b9147929b14693d78b52df57bffe6fa668bb8c5c2a15c9905 */
#if BIND_git_blame_get_hunk_byline_FUNCTION
#define git_blame_get_hunk_byline_REQUIRED_ARGC 2
#define git_blame_get_hunk_byline_OPTIONAL_ARGC 0
/* git_blame_get_hunk_byline
 *
 * Parameters:
 * - blame: git_blame *
 * - lineno: size_t
 * Return Type: const git_blame_hunk *
 */
mrb_value
mrb_Git_git_blame_get_hunk_byline(mrb_state* mrb, mrb_value self) {
  mrb_value blame;
  mrb_int native_lineno;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &blame, &native_lineno);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blame, Blame_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blame expected");
    return mrb_nil_value();
  }

  /* Unbox param: blame */
  git_blame * native_blame = (mrb_nil_p(blame) ? NULL : mruby_unbox_git_blame(blame));

  /* Invocation */
  const git_blame_hunk * native_return_value = git_blame_get_hunk_byline(native_blame, native_lineno);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_blame_hunk(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blame_get_hunk_count */
/* sha: be71c2091e98575d45968474ac4ae42431cac959c7668db9ae554806e15d7835 */
#if BIND_git_blame_get_hunk_count_FUNCTION
#define git_blame_get_hunk_count_REQUIRED_ARGC 1
#define git_blame_get_hunk_count_OPTIONAL_ARGC 0
/* git_blame_get_hunk_count
 *
 * Parameters:
 * - blame: git_blame *
 * Return Type: uint32_t
 */
mrb_value
mrb_Git_git_blame_get_hunk_count(mrb_state* mrb, mrb_value self) {
  mrb_value blame;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blame);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blame, Blame_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blame expected");
    return mrb_nil_value();
  }

  /* Unbox param: blame */
  git_blame * native_blame = (mrb_nil_p(blame) ? NULL : mruby_unbox_git_blame(blame));

  /* Invocation */
  uint32_t native_return_value = git_blame_get_hunk_count(native_blame);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blame_init_options */
/* sha: e2c2551743de84a6ba521ddec8d0b1514717458c9e542816c041fc78a96c22fb */
#if BIND_git_blame_init_options_FUNCTION
#define git_blame_init_options_REQUIRED_ARGC 2
#define git_blame_init_options_OPTIONAL_ARGC 0
/* git_blame_init_options
 *
 * Parameters:
 * - opts: git_blame_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_blame_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, BlameOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "BlameOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_blame_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_blame_options(opts));

  /* Invocation */
  int native_return_value = git_blame_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_create_frombuffer */
/* sha: 4c53e60a43be90978456a0bd3547af319986d235e2a9b1ff622ddc92b5554371 */
#if BIND_git_blob_create_frombuffer_FUNCTION
#define git_blob_create_frombuffer_REQUIRED_ARGC 2
#define git_blob_create_frombuffer_OPTIONAL_ARGC 0
/* git_blob_create_frombuffer
 *
 * Parameters:
 * - repo: git_repository *
 * - buffer: const void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_create_frombuffer(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_oid * native_id = (git_oid*)calloc(1, sizeof(git_oid));
  mrb_value repo;
  mrb_value native_buffer;

  /* Fetch the args */
  mrb_get_args(mrb, "oS", &repo, &native_buffer);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_blob_create_frombuffer(native_id, native_repo, RSTRING_PTR(native_buffer), RSTRING_LEN(native_buffer));

  /* Box out param: id */
  mrb_value id = native_id == NULL ? mrb_nil_value() : mruby_giftwrap_git_oid(mrb, native_id);

  RAISE_GIT_ERROR(native_return_value);

  return id;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_create_fromchunks */
/* sha: ee42c2c7627d3d0f928b639b6eb643f71381b5ac80bc0c79a81b46a46245ff55 */
#if BIND_git_blob_create_fromchunks_FUNCTION
#define git_blob_create_fromchunks_REQUIRED_ARGC 4
#define git_blob_create_fromchunks_OPTIONAL_ARGC 0
/* git_blob_create_fromchunks
 *
 * Parameters:
 * - repo: git_repository *
 * - hintpath: const char *
 * - callback: git_blob_chunk_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_create_fromchunks(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_oid * native_id = (git_oid*)calloc(1, sizeof(git_oid));
  mrb_value repo;
  char * native_hintpath = NULL;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoo", &repo, &native_hintpath, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_blob_chunk_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_blob_chunk_cb native_callback = TODO_mruby_unbox_git_blob_chunk_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_blob_create_fromchunks(native_id, native_repo, native_hintpath, native_callback, native_payload);

  /* Box out param: id */
  mrb_value id = native_id == NULL ? mrb_nil_value() : mruby_giftwrap_git_oid(mrb, native_id);

  RAISE_GIT_ERROR(native_return_value);

  return id;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_create_fromdisk */
/* sha: 8d6c96c60d23f29a0b2ac053b3c57021dafce164a0dc3a26acd9c6e6d718a429 */
#if BIND_git_blob_create_fromdisk_FUNCTION
#define git_blob_create_fromdisk_REQUIRED_ARGC 2
#define git_blob_create_fromdisk_OPTIONAL_ARGC 0
/* git_blob_create_fromdisk
 *
 * Parameters:
 * - repo: git_repository *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_create_fromdisk(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_oid * native_id = (git_oid*)calloc(1, sizeof(git_oid));
  mrb_value repo;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_blob_create_fromdisk(native_id, native_repo, native_path);

  /* Box out param: id */
  mrb_value id = native_id == NULL ? mrb_nil_value() : mruby_giftwrap_git_oid(mrb, native_id);

  RAISE_GIT_ERROR(native_return_value);

  return id;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_create_fromworkdir */
/* sha: b99a6d73d0745683b7a4e76fd1a415240234555f245ec0e2491f582aff79741f */
#if BIND_git_blob_create_fromworkdir_FUNCTION
#define git_blob_create_fromworkdir_REQUIRED_ARGC 2
#define git_blob_create_fromworkdir_OPTIONAL_ARGC 0
/* git_blob_create_fromworkdir
 *
 * Parameters:
 * - repo: git_repository *
 * - relative_path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_create_fromworkdir(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_oid * native_id = (git_oid*)calloc(1, sizeof(git_oid));
  mrb_value repo;
  char * native_relative_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_relative_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_blob_create_fromworkdir(native_id, native_repo, native_relative_path);

  /* Box out param: id */
  mrb_value id = native_id == NULL ? mrb_nil_value() : mruby_giftwrap_git_oid(mrb, native_id);

  RAISE_GIT_ERROR(native_return_value);

  return id;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_filtered_content */
/* sha: aec971b40aacddb9822651510fbe04600ae55c57ceaa5a407fa662a366f0acfe */
#if BIND_git_blob_filtered_content_FUNCTION
#define git_blob_filtered_content_REQUIRED_ARGC 3
#define git_blob_filtered_content_OPTIONAL_ARGC 0
/* git_blob_filtered_content
 *
 * Parameters:
 * - blob: git_blob *
 * - as_path: const char *
 * - check_for_binary_data: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_filtered_content(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value blob;
  char * native_as_path = NULL;
  mrb_bool native_check_for_binary_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ozb", &blob, &native_as_path, &native_check_for_binary_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: blob */
  git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  int native_return_value = git_blob_filtered_content(native_out, native_blob, native_as_path, native_check_for_binary_data);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_free */
/* sha: 3744d2bfbb352180afe3ed04719d78a9150ea254b5c58f3c8d8d9e1cbf9decfe */
#if BIND_git_blob_free_FUNCTION
#define git_blob_free_REQUIRED_ARGC 1
#define git_blob_free_OPTIONAL_ARGC 0
/* git_blob_free
 *
 * Parameters:
 * - blob: git_blob *
 * Return Type: void
 */
mrb_value
mrb_Git_git_blob_free(mrb_state* mrb, mrb_value self) {
  mrb_value blob;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: blob */
  git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  git_blob_free(native_blob);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_id */
/* sha: b5b29714d61b778872f26ffc811953341159921eda09351ee33ebcde2cf53e9c */
#if BIND_git_blob_id_FUNCTION
#define git_blob_id_REQUIRED_ARGC 1
#define git_blob_id_OPTIONAL_ARGC 0
/* git_blob_id
 *
 * Parameters:
 * - blob: const git_blob *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_blob_id(mrb_state* mrb, mrb_value self) {
  mrb_value blob;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: blob */
  const git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  const git_oid * native_return_value = git_blob_id(native_blob);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_is_binary */
/* sha: 00a17bf21c068e00ec7becfa8a6869010640a43614f486b16fe3465cfd52f956 */
#if BIND_git_blob_is_binary_FUNCTION
#define git_blob_is_binary_REQUIRED_ARGC 1
#define git_blob_is_binary_OPTIONAL_ARGC 0
/* git_blob_is_binary
 *
 * Parameters:
 * - blob: const git_blob *
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_is_binary(mrb_state* mrb, mrb_value self) {
  mrb_value blob;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: blob */
  const git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  int native_return_value = git_blob_is_binary(native_blob);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_lookup */
/* sha: 581017244ad822804471ec888c9a5a2dd16709e44a38e8e312e86a45be6b9848 */
#if BIND_git_blob_lookup_FUNCTION
#define git_blob_lookup_REQUIRED_ARGC 2
#define git_blob_lookup_OPTIONAL_ARGC 0
/* git_blob_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_lookup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_blob * native_blob = NULL;
  mrb_value repo;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_blob_lookup(&native_blob, native_repo, native_id);

  /* Box out param: blob */
  mrb_value blob = native_blob == NULL ? mrb_nil_value() : mruby_giftwrap_git_blob(mrb, native_blob);

  RAISE_GIT_ERROR(native_return_value);

  return blob;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_lookup_prefix */
/* sha: 3a4829ac33b8a0937c0d23f18be47aa8ff61b94d30a72fe772d0360a0cdf8c82 */
#if BIND_git_blob_lookup_prefix_FUNCTION
#define git_blob_lookup_prefix_REQUIRED_ARGC 3
#define git_blob_lookup_prefix_OPTIONAL_ARGC 0
/* git_blob_lookup_prefix
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_blob_lookup_prefix(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_blob * native_blob = NULL;
  mrb_value repo;
  mrb_value id;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &repo, &id, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_blob_lookup_prefix(&native_blob, native_repo, native_id, native_len);

  /* Box out param: blob */
  mrb_value blob = native_blob == NULL ? mrb_nil_value() : mruby_giftwrap_git_blob(mrb, native_blob);

  RAISE_GIT_ERROR(native_return_value);

  return blob;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_owner */
/* sha: 101b87a1ab77b319d5b62b43b8d05b93eb02d35cb3017b33ddb7eee9a29890ba */
#if BIND_git_blob_owner_FUNCTION
#define git_blob_owner_REQUIRED_ARGC 1
#define git_blob_owner_OPTIONAL_ARGC 0
/* git_blob_owner
 *
 * Parameters:
 * - blob: const git_blob *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_blob_owner(mrb_state* mrb, mrb_value self) {
  mrb_value blob;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: blob */
  const git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  git_repository * native_return_value = git_blob_owner(native_blob);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_rawcontent */
/* sha: b2a3a017925156cbd6e918dc4690ee3354917ad5267f78949c2f5367d15f995c */
#if BIND_git_blob_rawcontent_FUNCTION
#define git_blob_rawcontent_REQUIRED_ARGC 1
#define git_blob_rawcontent_OPTIONAL_ARGC 0
/* git_blob_rawcontent
 *
 * Parameters:
 * - blob: const git_blob *
 * Return Type: const void *
 */
mrb_value
mrb_Git_git_blob_rawcontent(mrb_state* mrb, mrb_value self) {
  mrb_value blob;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: blob */
  const git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  const void * native_return_value = git_blob_rawcontent(native_blob);

  /* Box the return value */
  mrb_value return_value = mrb_str_new(mrb, native_return_value, git_blob_rawsize(native_blob));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_blob_rawsize */
/* sha: ba5e16b3937112d5802e80bff2ddd0a4a05d203ec7b36a3296a2031599619f28 */
#if BIND_git_blob_rawsize_FUNCTION
#define git_blob_rawsize_REQUIRED_ARGC 1
#define git_blob_rawsize_OPTIONAL_ARGC 0
/* git_blob_rawsize
 *
 * Parameters:
 * - blob: const git_blob *
 * Return Type: git_off_t
 */
mrb_value
mrb_Git_git_blob_rawsize(mrb_state* mrb, mrb_value self) {
  mrb_value blob;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &blob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: blob */
  const git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  git_off_t native_return_value = git_blob_rawsize(native_blob);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_create */
/* sha: d63dce40712196092743f1279085281d6dafdfe5a89d586061c852a38fe6cb3b */
#if BIND_git_branch_create_FUNCTION
#define git_branch_create_REQUIRED_ARGC 4
#define git_branch_create_OPTIONAL_ARGC 0
/* git_branch_create
 *
 * Parameters:
 * - repo: git_repository *
 * - branch_name: const char *
 * - target: const git_commit *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_create(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_branch_name = NULL;
  mrb_value target;
  mrb_bool native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "ozob", &repo, &native_branch_name, &target, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: target */
  const git_commit * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_commit(target));

  /* Invocation */
  int native_return_value = git_branch_create(&native_out, native_repo, native_branch_name, native_target, native_force);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_create_from_annotated */
/* sha: d1f71d70f7b1c6244b13c41667c2db14032a852dc714d16b062da636ae7db2b7 */
#if BIND_git_branch_create_from_annotated_FUNCTION
#define git_branch_create_from_annotated_REQUIRED_ARGC 4
#define git_branch_create_from_annotated_OPTIONAL_ARGC 0
/* git_branch_create_from_annotated
 *
 * Parameters:
 * - repository: git_repository *
 * - branch_name: const char *
 * - commit: const git_annotated_commit *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_create_from_annotated(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_ref_out = NULL;
  mrb_value repository;
  char * native_branch_name = NULL;
  mrb_value commit;
  mrb_bool native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "ozob", &repository, &native_branch_name, &commit, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repository, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }

  /* Unbox param: repository */
  git_repository * native_repository = (mrb_nil_p(repository) ? NULL : mruby_unbox_git_repository(repository));

  /* Unbox param: commit */
  const git_annotated_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_annotated_commit(commit));

  /* Invocation */
  int native_return_value = git_branch_create_from_annotated(&native_ref_out, native_repository, native_branch_name, native_commit, native_force);

  /* Box out param: ref_out */
  mrb_value ref_out = native_ref_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_ref_out);

  RAISE_GIT_ERROR(native_return_value);

  return ref_out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_delete */
/* sha: 33617916fde76bd50ae24775f17236a24ef6ba58a5f4ea178a45709e983d4d05 */
#if BIND_git_branch_delete_FUNCTION
#define git_branch_delete_REQUIRED_ARGC 1
#define git_branch_delete_OPTIONAL_ARGC 0
/* git_branch_delete
 *
 * Parameters:
 * - branch: git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_delete(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value branch;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &branch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, branch, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: branch */
  git_reference * native_branch = (mrb_nil_p(branch) ? NULL : mruby_unbox_git_reference(branch));

  /* Invocation */
  int native_return_value = git_branch_delete(native_branch);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_is_head */
/* sha: 7dd6e435c50d010bf3830a4e7eaceec1fdef30c51e83792936afc00dda67a3f2 */
#if BIND_git_branch_is_head_FUNCTION
#define git_branch_is_head_REQUIRED_ARGC 1
#define git_branch_is_head_OPTIONAL_ARGC 0
/* git_branch_is_head
 *
 * Parameters:
 * - branch: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_is_head(mrb_state* mrb, mrb_value self) {
  mrb_value branch;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &branch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, branch, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: branch */
  const git_reference * native_branch = (mrb_nil_p(branch) ? NULL : mruby_unbox_git_reference(branch));

  /* Invocation */
  int native_return_value = git_branch_is_head(native_branch);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_iterator_free */
/* sha: 10adfc0dcf298a072da40069d7bbe88314047f0006cca4286cb7a690323f3a21 */
#if BIND_git_branch_iterator_free_FUNCTION
#define git_branch_iterator_free_REQUIRED_ARGC 1
#define git_branch_iterator_free_OPTIONAL_ARGC 0
/* git_branch_iterator_free
 *
 * Parameters:
 * - iter: git_branch_iterator *
 * Return Type: void
 */
mrb_value
mrb_Git_git_branch_iterator_free(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, BranchIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "BranchIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iter */
  git_branch_iterator * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox_git_branch_iterator(iter));

  /* Invocation */
  git_branch_iterator_free(native_iter);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_iterator_new */
/* sha: c209ea27165e8ef0d01f7ec01a6af0180fa0288df5e07fc682099d72d8f9b6b2 */
#if BIND_git_branch_iterator_new_FUNCTION
#define git_branch_iterator_new_REQUIRED_ARGC 2
#define git_branch_iterator_new_OPTIONAL_ARGC 0
/* git_branch_iterator_new
 *
 * Parameters:
 * - repo: git_repository *
 * - list_flags: git_branch_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_iterator_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_branch_iterator * native_out = NULL;
  mrb_value repo;
  mrb_int native_list_flags;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &repo, &native_list_flags);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_branch_iterator_new(&native_out, native_repo, native_list_flags);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_branch_iterator(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_lookup */
/* sha: c0220e8217242520221ff05649cafba062d284246ba883b1cba174a8452cff2f */
#if BIND_git_branch_lookup_FUNCTION
#define git_branch_lookup_REQUIRED_ARGC 3
#define git_branch_lookup_OPTIONAL_ARGC 0
/* git_branch_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - branch_name: const char *
 * - branch_type: git_branch_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_lookup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_branch_name = NULL;
  mrb_int native_branch_type;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &repo, &native_branch_name, &native_branch_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_branch_lookup(&native_out, native_repo, native_branch_name, native_branch_type);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_move */
/* sha: a255874fe452f3d981ee4c655f2cf21cb9b0eeeeb4f65121e8979058da45b06d */
#if BIND_git_branch_move_FUNCTION
#define git_branch_move_REQUIRED_ARGC 3
#define git_branch_move_OPTIONAL_ARGC 0
/* git_branch_move
 *
 * Parameters:
 * - branch: git_reference *
 * - new_branch_name: const char *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_move(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_out = NULL;
  mrb_value branch;
  char * native_new_branch_name = NULL;
  mrb_bool native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "ozb", &branch, &native_new_branch_name, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, branch, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: branch */
  git_reference * native_branch = (mrb_nil_p(branch) ? NULL : mruby_unbox_git_reference(branch));

  /* Invocation */
  int native_return_value = git_branch_move(&native_out, native_branch, native_new_branch_name, native_force);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_name */
/* sha: 166ccf7ac92de5ad6ce56a873df45fc482cdbd3f5b1588bb6778437e422ca405 */
#if BIND_git_branch_name_FUNCTION
#define git_branch_name_REQUIRED_ARGC 1
#define git_branch_name_OPTIONAL_ARGC 0
/* git_branch_name
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_name(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  char * native_out = NULL;
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_branch_name(&native_out, native_ref);

  /* Box out param: out */
  mrb_value out = native_out ==  NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_next */
/* sha: 99d61fdb217c117e7c6dc4f8480769404ccb79352ec837916f5e52d5ccc2870d */
#if BIND_git_branch_next_FUNCTION
#define git_branch_next_REQUIRED_ARGC 1
#define git_branch_next_OPTIONAL_ARGC 0
/* git_branch_next
 *
 * Parameters:
 * - iter: git_branch_iterator *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_next(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value results = mrb_ary_new(mrb);
  git_reference * native_out = NULL;
  int native_out_type;
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, BranchIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "BranchIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iter */
  git_branch_iterator * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox_git_branch_iterator(iter));

  /* Invocation */
  int native_return_value = git_branch_next(&native_out, &native_out_type, native_iter);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);
  /* Box out param: out_type */
  mrb_value out_type = mrb_fixnum_value(native_out_type);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);
  mrb_ary_push(mrb, results, out_type);

  RAISE_GIT_ERROR(native_return_value);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_remote_name */
/* sha: 5fcdad3983b1da4d146d9a36aa4ffa9ea884519a03cba29c825a96c48853d5f5 */
#if BIND_git_branch_remote_name_FUNCTION
#define git_branch_remote_name_REQUIRED_ARGC 2
#define git_branch_remote_name_OPTIONAL_ARGC 0
/* git_branch_remote_name
 *
 * Parameters:
 * - repo: git_repository *
 * - canonical_branch_name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_remote_name(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value repo;
  char * native_canonical_branch_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_canonical_branch_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_branch_remote_name(native_out, native_repo, native_canonical_branch_name);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_set_upstream */
/* sha: 8635b34ac90c3a84216d758f4b7abedff283e1a5498543d2d19e8e06a969f4b7 */
#if BIND_git_branch_set_upstream_FUNCTION
#define git_branch_set_upstream_REQUIRED_ARGC 2
#define git_branch_set_upstream_OPTIONAL_ARGC 0
/* git_branch_set_upstream
 *
 * Parameters:
 * - branch: git_reference *
 * - upstream_name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_set_upstream(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value branch;
  char * native_upstream_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &branch, &native_upstream_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, branch, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: branch */
  git_reference * native_branch = (mrb_nil_p(branch) ? NULL : mruby_unbox_git_reference(branch));

  /* Invocation */
  int native_return_value = git_branch_set_upstream(native_branch, native_upstream_name);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_upstream */
/* sha: 402988534a993b1336833e0763572efa36c298ec8d94e7347588d8c017d8fbf3 */
#if BIND_git_branch_upstream_FUNCTION
#define git_branch_upstream_REQUIRED_ARGC 1
#define git_branch_upstream_OPTIONAL_ARGC 0
/* git_branch_upstream
 *
 * Parameters:
 * - branch: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_upstream(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_out = NULL;
  mrb_value branch;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &branch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, branch, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: branch */
  const git_reference * native_branch = (mrb_nil_p(branch) ? NULL : mruby_unbox_git_reference(branch));

  /* Invocation */
  int native_return_value = git_branch_upstream(&native_out, native_branch);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_upstream_name */
/* sha: 156e40c0fd7b7aa17d4e931cb0db464ee9dc928d6918d32154108c8cc51d173f */
#if BIND_git_branch_upstream_name_FUNCTION
#define git_branch_upstream_name_REQUIRED_ARGC 2
#define git_branch_upstream_name_OPTIONAL_ARGC 0
/* git_branch_upstream_name
 *
 * Parameters:
 * - repo: git_repository *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_upstream_name(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value repo;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_branch_upstream_name(native_out, native_repo, native_refname);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_branch_upstream_remote */
/* sha: 15b85231e13d703c293da0dbfdabc07f27fd9b937461c33e74437df17deb8535 */
#if BIND_git_branch_upstream_remote_FUNCTION
#define git_branch_upstream_remote_REQUIRED_ARGC 2
#define git_branch_upstream_remote_OPTIONAL_ARGC 0
/* git_branch_upstream_remote
 *
 * Parameters:
 * - repo: git_repository *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_branch_upstream_remote(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_buf = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value repo;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_branch_upstream_remote(native_buf, native_repo, native_refname);

  /* Box out param: buf */
  mrb_value buf = native_buf == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_buf);

  RAISE_GIT_ERROR(native_return_value);

  return buf;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_buf_contains_nul */
/* sha: 68dd5fc5899563be2983c1f5780a0ea566241a7cd60252bbc046c747d68e0de2 */
#if BIND_git_buf_contains_nul_FUNCTION
#define git_buf_contains_nul_REQUIRED_ARGC 1
#define git_buf_contains_nul_OPTIONAL_ARGC 0
/* git_buf_contains_nul
 *
 * Parameters:
 * - buf: const git_buf *
 * Return Type: int
 */
mrb_value
mrb_Git_git_buf_contains_nul(mrb_state* mrb, mrb_value self) {
  mrb_value buf;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &buf);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, buf, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: buf */
  git_buf * native_buf = mrb_nil_p(buf) ? NULL : mruby_unbox_git_buf(buf);

  /* Invocation */
  int native_return_value = git_buf_contains_nul(native_buf);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_buf_free */
/* sha: 7822f3652a3efef7ae1742cd08f9ebad3bef7e65ba9a6ad92e5cedab923220f4 */
#if BIND_git_buf_free_FUNCTION
#define git_buf_free_REQUIRED_ARGC 1
#define git_buf_free_OPTIONAL_ARGC 0
/* git_buf_free
 *
 * Parameters:
 * - buffer: git_buf *
 * Return Type: void
 */
mrb_value
mrb_Git_git_buf_free(mrb_state* mrb, mrb_value self) {
  mrb_value buffer;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &buffer);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, buffer, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: buffer */
  git_buf * native_buffer = mrb_nil_p(buffer) ? NULL : mruby_unbox_git_buf(buffer);

  /* Invocation */
  git_buf_free(native_buffer);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_buf_grow */
/* sha: deb9eaef714bc3ad0104b0ae89bf34a7a0e5af8df2d52f93f675ffb93deedc1d */
#if BIND_git_buf_grow_FUNCTION
#define git_buf_grow_REQUIRED_ARGC 2
#define git_buf_grow_OPTIONAL_ARGC 0
/* git_buf_grow
 *
 * Parameters:
 * - buffer: git_buf *
 * - target_size: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_buf_grow(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value buffer;
  mrb_int native_target_size;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &buffer, &native_target_size);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, buffer, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: buffer */
  git_buf * native_buffer = mrb_nil_p(buffer) ? NULL : mruby_unbox_git_buf(buffer);

  /* Invocation */
  int native_return_value = git_buf_grow(native_buffer, native_target_size);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_buf_is_binary */
/* sha: cd813b5b603a56595a0ac908b03a4fc61581637518d9d46fc6c55be87c9d2ad6 */
#if BIND_git_buf_is_binary_FUNCTION
#define git_buf_is_binary_REQUIRED_ARGC 1
#define git_buf_is_binary_OPTIONAL_ARGC 0
/* git_buf_is_binary
 *
 * Parameters:
 * - buf: const git_buf *
 * Return Type: int
 */
mrb_value
mrb_Git_git_buf_is_binary(mrb_state* mrb, mrb_value self) {
  mrb_value buf;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &buf);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, buf, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: buf */
  git_buf * native_buf = mrb_nil_p(buf) ? NULL : mruby_unbox_git_buf(buf);

  /* Invocation */
  int native_return_value = git_buf_is_binary(native_buf);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_buf_set */
/* sha: e6c96dc529b92b9b546a1ef6d6421bbb79857295b1a13621814ebb0ed7c483ba */
#if BIND_git_buf_set_FUNCTION
#define git_buf_set_REQUIRED_ARGC 2
#define git_buf_set_OPTIONAL_ARGC 0
/* git_buf_set
 *
 * Parameters:
 * - buffer: git_buf *
 * - data: const void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_buf_set(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value buffer;
  mrb_value native_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oS", &buffer, &native_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, buffer, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: buffer */
  git_buf * native_buffer = mrb_nil_p(buffer) ? NULL : mruby_unbox_git_buf(buffer);

  /* Invocation */
  int native_return_value = git_buf_set(native_buffer, RSTRING_PTR(native_data), RSTRING_LEN(native_data));

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_checkout_head */
/* sha: b0a1a9a51c6e5d8f9236b2c77b6609cc6b85eb2be53d82c27c4645be87c5ebd5 */
#if BIND_git_checkout_head_FUNCTION
#define git_checkout_head_REQUIRED_ARGC 2
#define git_checkout_head_OPTIONAL_ARGC 0
/* git_checkout_head
 *
 * Parameters:
 * - repo: git_repository *
 * - opts: const git_checkout_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_checkout_head(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, CheckoutOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CheckoutOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: opts */
  const git_checkout_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_checkout_options(opts));

  /* Invocation */
  int native_return_value = git_checkout_head(native_repo, native_opts);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_checkout_index */
/* sha: 51ddd6a77a7e744cf38bc089c271fb68df29480f1987b03cc4e51e5dd07f9665 */
#if BIND_git_checkout_index_FUNCTION
#define git_checkout_index_REQUIRED_ARGC 3
#define git_checkout_index_OPTIONAL_ARGC 0
/* git_checkout_index
 *
 * Parameters:
 * - repo: git_repository *
 * - index: git_index *
 * - opts: const git_checkout_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_checkout_index(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value index;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &index, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, CheckoutOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CheckoutOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: opts */
  const git_checkout_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_checkout_options(opts));

  /* Invocation */
  int native_return_value = git_checkout_index(native_repo, native_index, native_opts);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_checkout_init_options */
/* sha: f3f22a616277593c049cde2123400c11b3125b6a52f64158eeb5648a265a2f3f */
#if BIND_git_checkout_init_options_FUNCTION
#define git_checkout_init_options_REQUIRED_ARGC 2
#define git_checkout_init_options_OPTIONAL_ARGC 0
/* git_checkout_init_options
 *
 * Parameters:
 * - opts: git_checkout_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_checkout_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, CheckoutOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CheckoutOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_checkout_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_checkout_options(opts));

  /* Invocation */
  int native_return_value = git_checkout_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_checkout_tree */
/* sha: cc84a823dd6f1b284b52cca8b7b6bf4b9870feb3653a816756707eb167d83503 */
#if BIND_git_checkout_tree_FUNCTION
#define git_checkout_tree_REQUIRED_ARGC 3
#define git_checkout_tree_OPTIONAL_ARGC 0
/* git_checkout_tree
 *
 * Parameters:
 * - repo: git_repository *
 * - treeish: const git_object *
 * - opts: const git_checkout_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_checkout_tree(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value treeish;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &treeish, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, treeish, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, CheckoutOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CheckoutOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: treeish */
  const git_object * native_treeish = (mrb_nil_p(treeish) ? NULL : mruby_unbox_git_object(treeish));

  /* Unbox param: opts */
  const git_checkout_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_checkout_options(opts));

  /* Invocation */
  int native_return_value = git_checkout_tree(native_repo, native_treeish, native_opts);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cherrypick */
/* sha: f8cc9f0fd6246d3510bd0cef98470b7b3d1670bd78bf20f39748199734d6e982 */
#if BIND_git_cherrypick_FUNCTION
#define git_cherrypick_REQUIRED_ARGC 3
#define git_cherrypick_OPTIONAL_ARGC 0
/* git_cherrypick
 *
 * Parameters:
 * - repo: git_repository *
 * - commit: git_commit *
 * - cherrypick_options: const git_cherrypick_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cherrypick(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value commit;
  mrb_value cherrypick_options;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &commit, &cherrypick_options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, cherrypick_options, CherrypickOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CherrypickOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: commit */
  git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Unbox param: cherrypick_options */
  const git_cherrypick_options * native_cherrypick_options = (mrb_nil_p(cherrypick_options) ? NULL : mruby_unbox_git_cherrypick_options(cherrypick_options));

  /* Invocation */
  int native_return_value = git_cherrypick(native_repo, native_commit, native_cherrypick_options);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cherrypick_commit */
/* sha: 0c236d15f022c2c2e50b1af245ed4fd7399df056a1e337b9eedd048b6f947c9a */
#if BIND_git_cherrypick_commit_FUNCTION
#define git_cherrypick_commit_REQUIRED_ARGC 5
#define git_cherrypick_commit_OPTIONAL_ARGC 0
/* git_cherrypick_commit
 *
 * Parameters:
 * - repo: git_repository *
 * - cherrypick_commit: git_commit *
 * - our_commit: git_commit *
 * - mainline: unsigned int
 * - merge_options: const git_merge_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cherrypick_commit(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_index * native_out = NULL;
  mrb_value repo;
  mrb_value cherrypick_commit;
  mrb_value our_commit;
  mrb_int native_mainline;
  mrb_value merge_options;

  /* Fetch the args */
  mrb_get_args(mrb, "oooio", &repo, &cherrypick_commit, &our_commit, &native_mainline, &merge_options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, cherrypick_commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, our_commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, merge_options, MergeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: cherrypick_commit */
  git_commit * native_cherrypick_commit = (mrb_nil_p(cherrypick_commit) ? NULL : mruby_unbox_git_commit(cherrypick_commit));

  /* Unbox param: our_commit */
  git_commit * native_our_commit = (mrb_nil_p(our_commit) ? NULL : mruby_unbox_git_commit(our_commit));

  /* Unbox param: merge_options */
  const git_merge_options * native_merge_options = (mrb_nil_p(merge_options) ? NULL : mruby_unbox_git_merge_options(merge_options));

  /* Invocation */
  int native_return_value = git_cherrypick_commit(&native_out, native_repo, native_cherrypick_commit, native_our_commit, native_mainline, native_merge_options);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cherrypick_init_options */
/* sha: fb83ee425a225007d3aab86bbb8a9b4bf37b6a5432ad80a94e68b589395405b5 */
#if BIND_git_cherrypick_init_options_FUNCTION
#define git_cherrypick_init_options_REQUIRED_ARGC 2
#define git_cherrypick_init_options_OPTIONAL_ARGC 0
/* git_cherrypick_init_options
 *
 * Parameters:
 * - opts: git_cherrypick_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_cherrypick_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, CherrypickOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CherrypickOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_cherrypick_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_cherrypick_options(opts));

  /* Invocation */
  int native_return_value = git_cherrypick_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_clone */
/* sha: 13a856b9feed28b84ca40267ceb5bc4abe5079b0ad2040e549bb00d031b4b2f7 */
#if BIND_git_clone_FUNCTION
#define git_clone_REQUIRED_ARGC 3
#define git_clone_OPTIONAL_ARGC 0
/* git_clone
 *
 * Parameters:
 * - url: const char *
 * - local_path: const char *
 * - options: const git_clone_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_clone(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_repository * native_out = NULL;
  char * native_url = NULL;
  char * native_local_path = NULL;
  mrb_value options;

  /* Fetch the args */
  mrb_get_args(mrb, "zzo", &native_url, &native_local_path, &options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, options, CloneOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CloneOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: options */
  const git_clone_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_clone_options(options));

  /* Invocation */
  int native_return_value = git_clone(&native_out, native_url, native_local_path, native_options);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_clone_init_options */
/* sha: 9fad781bf1b57cb03ab79a33c206ecd95dac9e6350d069ddb4391265aa1dcf09 */
#if BIND_git_clone_init_options_FUNCTION
#define git_clone_init_options_REQUIRED_ARGC 2
#define git_clone_init_options_OPTIONAL_ARGC 0
/* git_clone_init_options
 *
 * Parameters:
 * - opts: git_clone_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_clone_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, CloneOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CloneOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_clone_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_clone_options(opts));

  /* Invocation */
  int native_return_value = git_clone_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_amend */
/* sha: 6ea5bd8df922e81e42b66ddeb26f6d5acf6d96179350df3e52ec13db71b43418 */
#if BIND_git_commit_amend_FUNCTION
#define git_commit_amend_REQUIRED_ARGC 8
#define git_commit_amend_OPTIONAL_ARGC 0
/* git_commit_amend
 *
 * Parameters:
 * - id: git_oid *
 * - commit_to_amend: const git_commit *
 * - update_ref: const char *
 * - author: const git_signature *
 * - committer: const git_signature *
 * - message_encoding: const char *
 * - message: const char *
 * - tree: const git_tree *
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_amend(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value id;
  mrb_value commit_to_amend;
  char * native_update_ref = NULL;
  mrb_value author;
  mrb_value committer;
  char * native_message_encoding = NULL;
  char * native_message = NULL;
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "oozoozzo", &id, &commit_to_amend, &native_update_ref, &author, &committer, &native_message_encoding, &native_message, &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit_to_amend, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, author, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, committer, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: id */
  git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Unbox param: commit_to_amend */
  const git_commit * native_commit_to_amend = (mrb_nil_p(commit_to_amend) ? NULL : mruby_unbox_git_commit(commit_to_amend));

  /* Unbox param: author */
  const git_signature * native_author = (mrb_nil_p(author) ? NULL : mruby_unbox_git_signature(author));

  /* Unbox param: committer */
  const git_signature * native_committer = (mrb_nil_p(committer) ? NULL : mruby_unbox_git_signature(committer));

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  int native_return_value = git_commit_amend(native_id, native_commit_to_amend, native_update_ref, native_author, native_committer, native_message_encoding, native_message, native_tree);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_author */
/* sha: 1f6aa41b5da02b22eb3bd373b6b9edb373a986e01c5974692bd9075c10d5fe40 */
#if BIND_git_commit_author_FUNCTION
#define git_commit_author_REQUIRED_ARGC 1
#define git_commit_author_OPTIONAL_ARGC 0
/* git_commit_author
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const git_signature *
 */
mrb_value
mrb_Git_git_commit_author(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const git_signature * native_return_value = git_commit_author(native_commit);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_signature(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_body */
/* sha: 0c49e748877cdbaa65c4ab674afe70869b4301364394a04d6e92a3034ec4f87a */
#if BIND_git_commit_body_FUNCTION
#define git_commit_body_REQUIRED_ARGC 1
#define git_commit_body_OPTIONAL_ARGC 0
/* git_commit_body
 *
 * Parameters:
 * - commit: git_commit *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_commit_body(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const char * native_return_value = git_commit_body(native_commit);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_committer */
/* sha: 02b88b6ee1641d6c619a2a99d5bb620ffa64afc654548be0d64991d72c6a29a6 */
#if BIND_git_commit_committer_FUNCTION
#define git_commit_committer_REQUIRED_ARGC 1
#define git_commit_committer_OPTIONAL_ARGC 0
/* git_commit_committer
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const git_signature *
 */
mrb_value
mrb_Git_git_commit_committer(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const git_signature * native_return_value = git_commit_committer(native_commit);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_signature(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_create */
/* sha: fe94a9c093a320218fc69eef120660a557bf7a7d60be6044007692c7fdd4c527 */
#if BIND_git_commit_create_FUNCTION
#define git_commit_create_REQUIRED_ARGC 8
#define git_commit_create_OPTIONAL_ARGC 0
/* git_commit_create
 *
 * @param id Pointer in which to store the OID of the newly created commit
 *
 * @param repo Repository where to store the commit
 *
 * @param update_ref If not NULL, name of the reference that
 *	will be updated to point to this commit. If the reference
 *	is not direct, it will be resolved to a direct reference.
 *	Use "HEAD" to update the HEAD of the current branch and
 *	make it point to this commit. If the reference doesn't
 *	exist yet, it will be created. If it does exist, the first
 *	parent must be the tip of this branch.
 *
 * @param author Signature with author and author time of commit
 *
 * @param committer Signature with committer and * commit time of commit
 *
 * @param message_encoding The encoding for the message in the
 *  commit, represented with a standard encoding name.
 *  E.g. "UTF-8". If NULL, no encoding header is written and
 *  UTF-8 is assumed.
 *
 * @param message Full message for this commit
 *
 * @param tree An instance of a `git_tree` object that will
 *  be used as the tree for the commit. This tree object must
 *  also be owned by the given `repo`.
 *
 * @param parents Array of `parent_count` pointers to `git_commit`
 *  objects that will be used as the parents for this commit. This
 *  array may be NULL if `parent_count` is 0 (root commit). All the
 *  given commits must be owned by the `repo`.
 */
mrb_value
mrb_Git_git_commit_create(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_oid * native_id = (git_oid*)calloc(1, sizeof(git_oid));
  mrb_value repo;
  char * native_update_ref = NULL;
  mrb_value author;
  mrb_value committer;
  char * native_message_encoding = NULL;
  char * native_message = NULL;
  mrb_value tree;
  mrb_int native_parent_count;
  mrb_value * parents;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!ooz!zoa",
    &repo,
    &native_update_ref,
    &author, 
    &committer,
    &native_message_encoding,
    &native_message,
    &tree,
    &parents,
    &native_parent_count);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, author, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, committer, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  
  git_commit ** native_parents = (git_commit**)calloc(native_parent_count, sizeof(git_commit *));
  for (int i = 0; i < native_parent_count; ++i) {
    if (!mrb_obj_is_kind_of(mrb, parents[i], Commit_class(mrb))) {
      mrb_raise(mrb, E_TYPE_ERROR, "Expected parents to be an array of Commits");
      return mrb_nil_value();
    } else {
      native_parents[i] = mruby_unbox_git_commit(parents[i]);
    }
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: author */
  const git_signature * native_author = (mrb_nil_p(author) ? NULL : mruby_unbox_git_signature(author));

  /* Unbox param: committer */
  const git_signature * native_committer = (mrb_nil_p(committer) ? NULL : mruby_unbox_git_signature(committer));

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  int native_return_value = git_commit_create(native_id, native_repo, native_update_ref, native_author, native_committer, native_message_encoding, native_message, native_tree, native_parent_count, native_parents);

  /* Box out param: id */
  mrb_value id = native_id == NULL ? mrb_nil_value() : mruby_giftwrap_git_oid(mrb, native_id);

  RAISE_GIT_ERROR(native_return_value);

  return id;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_create_v */
/* sha: cff7ad1efb5277de3b2a96716c2735d68d34298b944e0b1f30693ee198ce02b7 */
#if BIND_git_commit_create_v_FUNCTION
#define git_commit_create_v_REQUIRED_ARGC 8
#define git_commit_create_v_OPTIONAL_ARGC 0
/* git_commit_create_v
 *
 * Parameters:
 * - repo: git_repository *
 * - update_ref: const char *
 * - author: const git_signature *
 * - committer: const git_signature *
 * - message_encoding: const char *
 * - message: const char *
 * - tree: const git_tree *
 * - parent_count: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_create_v(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_oid * native_id = (git_oid*)calloc(1, sizeof(git_oid));
  mrb_value repo;
  char * native_update_ref = NULL;
  mrb_value author;
  mrb_value committer;
  char * native_message_encoding = NULL;
  char * native_message = NULL;
  mrb_value tree;
  mrb_int native_parent_count;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoozzoi", &repo, &native_update_ref, &author, &committer, &native_message_encoding, &native_message, &tree, &native_parent_count);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, author, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, committer, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: author */
  const git_signature * native_author = (mrb_nil_p(author) ? NULL : mruby_unbox_git_signature(author));

  /* Unbox param: committer */
  const git_signature * native_committer = (mrb_nil_p(committer) ? NULL : mruby_unbox_git_signature(committer));

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  int native_return_value = git_commit_create_v(native_id, native_repo, native_update_ref, native_author, native_committer, native_message_encoding, native_message, native_tree, native_parent_count);

  /* Box out param: id */
  mrb_value id = native_id == NULL ? mrb_nil_value() : mruby_giftwrap_git_oid(mrb, native_id);

  RAISE_GIT_ERROR(native_return_value);

  return id;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_free */
/* sha: f70363f18aa37ea0ceabb563e6e45eacd21edf87974e5775a426e3a2660a2abe */
#if BIND_git_commit_free_FUNCTION
#define git_commit_free_REQUIRED_ARGC 1
#define git_commit_free_OPTIONAL_ARGC 0
/* git_commit_free
 *
 * Parameters:
 * - commit: git_commit *
 * Return Type: void
 */
mrb_value
mrb_Git_git_commit_free(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  git_commit_free(native_commit);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_header_field */
/* sha: 7e8898ab169f21b2752a34623ea892560b38bf2f9db0c3306c0d03e39ab62401 */
#if BIND_git_commit_header_field_FUNCTION
#define git_commit_header_field_REQUIRED_ARGC 2
#define git_commit_header_field_OPTIONAL_ARGC 0
/* git_commit_header_field
 *
 * Parameters:
 * - commit: const git_commit *
 * - field: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_header_field(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value commit;
  char * native_field = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &commit, &native_field);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  int native_return_value = git_commit_header_field(native_out, native_commit, native_field);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_id */
/* sha: cc3f84d5d4846ae10bfa1537ee523c62a3549eb32ad06f3613cb00e87c43814a */
#if BIND_git_commit_id_FUNCTION
#define git_commit_id_REQUIRED_ARGC 1
#define git_commit_id_OPTIONAL_ARGC 0
/* git_commit_id
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_commit_id(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const git_oid * native_return_value = git_commit_id(native_commit);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_lookup */
/* sha: c92e4b83fdb81eb5ec71ab5f8c20db4b323354da9692a9a3913002a28353fc0e */
#if BIND_git_commit_lookup_FUNCTION
#define git_commit_lookup_REQUIRED_ARGC 2
#define git_commit_lookup_OPTIONAL_ARGC 0
/* git_commit_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_lookup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_commit * native_commit = NULL;
  mrb_value repo;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_commit_lookup(&native_commit, native_repo, native_id);

  /* Box out param: commit */
  mrb_value commit = native_commit == NULL ? mrb_nil_value() : mruby_giftwrap_git_commit(mrb, native_commit);

  RAISE_GIT_ERROR(native_return_value);

  return commit;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_lookup_prefix */
/* sha: 671e77364ca3a6f5a456eabb50d1380ac6adda04a0de7f5d93616a31ced3e4e6 */
#if BIND_git_commit_lookup_prefix_FUNCTION
#define git_commit_lookup_prefix_REQUIRED_ARGC 3
#define git_commit_lookup_prefix_OPTIONAL_ARGC 0
/* git_commit_lookup_prefix
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_lookup_prefix(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_commit * native_commit = NULL;
  mrb_value repo;
  mrb_value id;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &repo, &id, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_commit_lookup_prefix(&native_commit, native_repo, native_id, native_len);

  /* Box out param: commit */
  mrb_value commit = native_commit == NULL ? mrb_nil_value() : mruby_giftwrap_git_commit(mrb, native_commit);

  RAISE_GIT_ERROR(native_return_value);

  return commit;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_message */
/* sha: ff1bad69213e76473efe7b2865bc0d21d9f89c76a49b91eb5c5b0ad8493ecbcc */
#if BIND_git_commit_message_FUNCTION
#define git_commit_message_REQUIRED_ARGC 1
#define git_commit_message_OPTIONAL_ARGC 0
/* git_commit_message
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_commit_message(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const char * native_return_value = git_commit_message(native_commit);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_message_encoding */
/* sha: c353517d5ec6ef938585e27ae5f4b4013029f13317e087da031f86866aec5292 */
#if BIND_git_commit_message_encoding_FUNCTION
#define git_commit_message_encoding_REQUIRED_ARGC 1
#define git_commit_message_encoding_OPTIONAL_ARGC 0
/* git_commit_message_encoding
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_commit_message_encoding(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const char * native_return_value = git_commit_message_encoding(native_commit);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_message_raw */
/* sha: 5154a7c34384a14a5c44cd97d9c8f598e80dcd5e8549e514844aa492169f19a9 */
#if BIND_git_commit_message_raw_FUNCTION
#define git_commit_message_raw_REQUIRED_ARGC 1
#define git_commit_message_raw_OPTIONAL_ARGC 0
/* git_commit_message_raw
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_commit_message_raw(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const char * native_return_value = git_commit_message_raw(native_commit);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_nth_gen_ancestor */
/* sha: 7a5478ab18e4120446afcffe7e4a838a61eaa9555cc7e171a046e6c58ea91f8e */
#if BIND_git_commit_nth_gen_ancestor_FUNCTION
#define git_commit_nth_gen_ancestor_REQUIRED_ARGC 2
#define git_commit_nth_gen_ancestor_OPTIONAL_ARGC 0
/* git_commit_nth_gen_ancestor
 *
 * Parameters:
 * - commit: const git_commit *
 * - n: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_nth_gen_ancestor(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_commit * native_ancestor = NULL;
  mrb_value commit;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &commit, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  int native_return_value = git_commit_nth_gen_ancestor(&native_ancestor, native_commit, native_n);

  /* Box out param: ancestor */
  mrb_value ancestor = native_ancestor == NULL ? mrb_nil_value() : mruby_giftwrap_git_commit(mrb, native_ancestor);

  RAISE_GIT_ERROR(native_return_value);

  return ancestor;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_owner */
/* sha: 8304aec89de65b19830c942421cb7ee29f8e059ba2b758d56ba6260139a24bf0 */
#if BIND_git_commit_owner_FUNCTION
#define git_commit_owner_REQUIRED_ARGC 1
#define git_commit_owner_OPTIONAL_ARGC 0
/* git_commit_owner
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_commit_owner(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  git_repository * native_return_value = git_commit_owner(native_commit);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_parent */
/* sha: 4c53559b194d154a1c68231a9ae784f274da05fc4cef1fb6920f703b84b8af09 */
#if BIND_git_commit_parent_FUNCTION
#define git_commit_parent_REQUIRED_ARGC 2
#define git_commit_parent_OPTIONAL_ARGC 0
/* git_commit_parent
 *
 * Parameters:
 * - commit: const git_commit *
 * - n: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_parent(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_commit * native_out = NULL;
  mrb_value commit;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &commit, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  int native_return_value = git_commit_parent(&native_out, native_commit, native_n);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_commit(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_parent_id */
/* sha: 5c5949f38fd5aa3337b609dea1cc85c1b379beec3d95598624d8452f20f405c8 */
#if BIND_git_commit_parent_id_FUNCTION
#define git_commit_parent_id_REQUIRED_ARGC 2
#define git_commit_parent_id_OPTIONAL_ARGC 0
/* git_commit_parent_id
 *
 * Parameters:
 * - commit: const git_commit *
 * - n: unsigned int
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_commit_parent_id(mrb_state* mrb, mrb_value self) {
  mrb_value commit;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &commit, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const git_oid * native_return_value = git_commit_parent_id(native_commit, native_n);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_parentcount */
/* sha: c35e39f49bcfcb01312b6028efb4b77a5ba1ca171287cbe9b338ecee5be40605 */
#if BIND_git_commit_parentcount_FUNCTION
#define git_commit_parentcount_REQUIRED_ARGC 1
#define git_commit_parentcount_OPTIONAL_ARGC 0
/* git_commit_parentcount
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: unsigned int
 */
mrb_value
mrb_Git_git_commit_parentcount(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  unsigned int native_return_value = git_commit_parentcount(native_commit);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_raw_header */
/* sha: b0612fa1c5daf9aad7aaf406b934a52a505d372ffd30dc00a5c7dd3fdb397c4e */
#if BIND_git_commit_raw_header_FUNCTION
#define git_commit_raw_header_REQUIRED_ARGC 1
#define git_commit_raw_header_OPTIONAL_ARGC 0
/* git_commit_raw_header
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_commit_raw_header(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const char * native_return_value = git_commit_raw_header(native_commit);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_summary */
/* sha: edc528da2e506accc2743d23989c2a29de3d0b77b727fbdf041f6027e2a70fe3 */
#if BIND_git_commit_summary_FUNCTION
#define git_commit_summary_REQUIRED_ARGC 1
#define git_commit_summary_OPTIONAL_ARGC 0
/* git_commit_summary
 *
 * Parameters:
 * - commit: git_commit *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_commit_summary(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const char * native_return_value = git_commit_summary(native_commit);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_time */
/* sha: 7b10a305e83289d2d81fe2ca30d9fd2e8ab49d44bcf3b9bde5a04ba36f980740 */
#if BIND_git_commit_time_FUNCTION
#define git_commit_time_REQUIRED_ARGC 1
#define git_commit_time_OPTIONAL_ARGC 0
/* git_commit_time
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: git_time_t
 */
mrb_value
mrb_Git_git_commit_time(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  git_time_t native_return_value = git_commit_time(native_commit);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_time_offset */
/* sha: e291e73fc818b190ed97da8e57f2404042c5aed6039026728ee664a778680d85 */
#if BIND_git_commit_time_offset_FUNCTION
#define git_commit_time_offset_REQUIRED_ARGC 1
#define git_commit_time_offset_OPTIONAL_ARGC 0
/* git_commit_time_offset
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_time_offset(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  int native_return_value = git_commit_time_offset(native_commit);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_tree */
/* sha: 539c229b646a5ca16c6a20bc00711aaf8ce45f645247646f315b9c5cdc67ee2c */
#if BIND_git_commit_tree_FUNCTION
#define git_commit_tree_REQUIRED_ARGC 1
#define git_commit_tree_OPTIONAL_ARGC 0
/* git_commit_tree
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: int
 */
mrb_value
mrb_Git_git_commit_tree(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_tree * native_tree_out = NULL;
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  int native_return_value = git_commit_tree(&native_tree_out, native_commit);

  /* Box out param: tree_out */
  mrb_value tree_out = native_tree_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_tree(mrb, native_tree_out);

  RAISE_GIT_ERROR(native_return_value);

  return tree_out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_commit_tree_id */
/* sha: 6012ae18fceaa498561b6cb024805262877794f831d17159402aea58b686c745 */
#if BIND_git_commit_tree_id_FUNCTION
#define git_commit_tree_id_REQUIRED_ARGC 1
#define git_commit_tree_id_OPTIONAL_ARGC 0
/* git_commit_tree_id
 *
 * Parameters:
 * - commit: const git_commit *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_commit_tree_id(mrb_state* mrb, mrb_value self) {
  mrb_value commit;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &commit);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }

  /* Unbox param: commit */
  const git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Invocation */
  const git_oid * native_return_value = git_commit_tree_id(native_commit);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_add_file_ondisk */
/* sha: 0fd25a6dd22f45f76fb6e694d23e64e3de27ada377c3384f972592762f231889 */
#if BIND_git_config_add_file_ondisk_FUNCTION
#define git_config_add_file_ondisk_REQUIRED_ARGC 4
#define git_config_add_file_ondisk_OPTIONAL_ARGC 0
/* git_config_add_file_ondisk
 *
 * Parameters:
 * - cfg: git_config *
 * - path: const char *
 * - level: git_config_level_t
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_add_file_ondisk(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value cfg;
  char * native_path = NULL;
  mrb_int native_level;
  mrb_bool native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "ozib", &cfg, &native_path, &native_level, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_add_file_ondisk(native_cfg, native_path, native_level, native_force);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_backend_foreach_match */
/* sha: 89df72269bc9140d76329e3d56e5ec1d6e788ae37f83413a5322201504839e18 */
#if BIND_git_config_backend_foreach_match_FUNCTION
#define git_config_backend_foreach_match_REQUIRED_ARGC 4
#define git_config_backend_foreach_match_OPTIONAL_ARGC 0
/* git_config_backend_foreach_match
 *
 * Parameters:
 * - backend: git_config_backend *
 * - regexp: const char *
 * - callback: git_config_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_backend_foreach_match(mrb_state* mrb, mrb_value self) {
  mrb_value backend;
  char * native_regexp = NULL;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoo", &backend, &native_regexp, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, backend, ConfigBackend_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ConfigBackend expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_config_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: backend */
  git_config_backend * native_backend = (mrb_nil_p(backend) ? NULL : mruby_unbox_git_config_backend(backend));

  /* Unbox param: callback */
  git_config_foreach_cb native_callback = TODO_mruby_unbox_git_config_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_config_backend_foreach_match(native_backend, native_regexp, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_delete_entry */
/* sha: bcd28585b55c617ca8c3df8161334cdb17558a3eb62d583618b7b3e8fa0bf9ab */
#if BIND_git_config_delete_entry_FUNCTION
#define git_config_delete_entry_REQUIRED_ARGC 2
#define git_config_delete_entry_OPTIONAL_ARGC 0
/* git_config_delete_entry
 *
 * Parameters:
 * - cfg: git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_delete_entry(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_delete_entry(native_cfg, native_name);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_delete_multivar */
/* sha: e531a24174a231746a2b1c3f3565b92e36db0b72d4fa3ed4862e2a9a64f49415 */
#if BIND_git_config_delete_multivar_FUNCTION
#define git_config_delete_multivar_REQUIRED_ARGC 3
#define git_config_delete_multivar_OPTIONAL_ARGC 0
/* git_config_delete_multivar
 *
 * Parameters:
 * - cfg: git_config *
 * - name: const char *
 * - regexp: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_delete_multivar(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value cfg;
  char * native_name = NULL;
  char * native_regexp = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &cfg, &native_name, &native_regexp);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_delete_multivar(native_cfg, native_name, native_regexp);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_entry_free */
/* sha: d38ab356806e2f38e75869f6a813b5a4c381c70774bba5a50d6d4bfd686b4dff */
#if BIND_git_config_entry_free_FUNCTION
#define git_config_entry_free_REQUIRED_ARGC 1
#define git_config_entry_free_OPTIONAL_ARGC 0
/* git_config_entry_free
 *
 * Parameters:
 * - arg1: git_config_entry *
 * Return Type: void
 */
mrb_value
mrb_Git_git_config_entry_free(mrb_state* mrb, mrb_value self) {
  mrb_value arg1;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &arg1);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, arg1, ConfigEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ConfigEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: arg1 */
  git_config_entry * native_arg1 = (mrb_nil_p(arg1) ? NULL : mruby_unbox_git_config_entry(arg1));

  /* Invocation */
  git_config_entry_free(native_arg1);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_find_global */
/* sha: 35ed313a84abbac60f1e678117c8fff11a9585ed2d17eb4dd7e058216e52578c */
#if BIND_git_config_find_global_FUNCTION
#define git_config_find_global_REQUIRED_ARGC 0
#define git_config_find_global_OPTIONAL_ARGC 0
/* git_config_find_global
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_find_global(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));


  /* Invocation */
  int native_return_value = git_config_find_global(native_out);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_find_programdata */
/* sha: fae9fcd4588198091178796bab40498e826b2de181f8f8451bdf069bd9008ff8 */
#if BIND_git_config_find_programdata_FUNCTION
#define git_config_find_programdata_REQUIRED_ARGC 0
#define git_config_find_programdata_OPTIONAL_ARGC 0
/* git_config_find_programdata
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_find_programdata(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));


  /* Invocation */
  int native_return_value = git_config_find_programdata(native_out);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_find_system */
/* sha: 993b5200dca912579bb9b273fafee91d07685026b76f68022ee09263d6d8a0fb */
#if BIND_git_config_find_system_FUNCTION
#define git_config_find_system_REQUIRED_ARGC 0
#define git_config_find_system_OPTIONAL_ARGC 0
/* git_config_find_system
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_find_system(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));


  /* Invocation */
  int native_return_value = git_config_find_system(native_out);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_find_xdg */
/* sha: 0284beffb764be6404c8f3d796b6be8de1105dc7ae7776be0fb90d76bbdbf9ce */
#if BIND_git_config_find_xdg_FUNCTION
#define git_config_find_xdg_REQUIRED_ARGC 0
#define git_config_find_xdg_OPTIONAL_ARGC 0
/* git_config_find_xdg
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_find_xdg(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));


  /* Invocation */
  int native_return_value = git_config_find_xdg(native_out);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_foreach */
/* sha: 26be3395e3699c034b55c07c2e884d9952a3d8a67e5cb3e2429439e54ea95805 */
#if BIND_git_config_foreach_FUNCTION
#define git_config_foreach_REQUIRED_ARGC 3
#define git_config_foreach_OPTIONAL_ARGC 0
/* git_config_foreach
 *
 * Parameters:
 * - cfg: const git_config *
 * - callback: git_config_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_foreach(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value cfg;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &cfg, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_config_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Unbox param: callback */
  git_config_foreach_cb native_callback = TODO_mruby_unbox_git_config_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_config_foreach(native_cfg, native_callback, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_foreach_match */
/* sha: 7bbe5964226ebee035a62cff2a4c1604e27262f08fad0de790bde52719a87c26 */
#if BIND_git_config_foreach_match_FUNCTION
#define git_config_foreach_match_REQUIRED_ARGC 4
#define git_config_foreach_match_OPTIONAL_ARGC 0
/* git_config_foreach_match
 *
 * Parameters:
 * - cfg: const git_config *
 * - regexp: const char *
 * - callback: git_config_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_foreach_match(mrb_state* mrb, mrb_value self) {
  mrb_value cfg;
  char * native_regexp = NULL;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoo", &cfg, &native_regexp, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_config_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Unbox param: callback */
  git_config_foreach_cb native_callback = TODO_mruby_unbox_git_config_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_config_foreach_match(native_cfg, native_regexp, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_free */
/* sha: d09f64fffd45922ab7f3c9125144edf2e7ee2365cd27e41db51d49a89e98ab9b */
#if BIND_git_config_free_FUNCTION
#define git_config_free_REQUIRED_ARGC 1
#define git_config_free_OPTIONAL_ARGC 0
/* git_config_free
 *
 * Parameters:
 * - cfg: git_config *
 * Return Type: void
 */
mrb_value
mrb_Git_git_config_free(mrb_state* mrb, mrb_value self) {
  mrb_value cfg;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &cfg);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  git_config_free(native_cfg);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_bool */
/* sha: d30f83fb0ab982e82d2efd8a880d33f36bc8cb3cbfff5ea6890f8d9b0ce5d012 */
#if BIND_git_config_get_bool_FUNCTION
#define git_config_get_bool_REQUIRED_ARGC 2
#define git_config_get_bool_OPTIONAL_ARGC 0
/* git_config_get_bool
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_bool(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  int native_out;
  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_get_bool(&native_out, native_cfg, native_name);

  /* Box out param: out */
  mrb_value out = native_out == 0 ? mrb_false_value() : mrb_true_value();

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_entry */
/* sha: 14bb87d3b9bc9124050a48e7a1a4d9b2e1f6bdb0896eecacd6588ab6b3fee7c4 */
#if BIND_git_config_get_entry_FUNCTION
#define git_config_get_entry_REQUIRED_ARGC 2
#define git_config_get_entry_OPTIONAL_ARGC 0
/* git_config_get_entry
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_entry(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_config_entry * native_out = NULL;
  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_get_entry(&native_out, native_cfg, native_name);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config_entry(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_int32 */
/* sha: 56084d25c51fe0bab3c7605d1e33fdf64e95f7bdebf136f27f006e7d8da1f1c8 */
#if BIND_git_config_get_int32_FUNCTION
#define git_config_get_int32_REQUIRED_ARGC 2
#define git_config_get_int32_OPTIONAL_ARGC 0
/* git_config_get_int32
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_int32(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  int native_out;
  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_get_int32(&native_out, native_cfg, native_name);

  /* Box out param: out */
  mrb_value out = mrb_fixnum_value(native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_int64 */
/* sha: 55226fec59bf6fac3697c9feccdd3211e610a2f0c2012ed5e4ace782a5b3024c */
#if BIND_git_config_get_int64_FUNCTION
#define git_config_get_int64_REQUIRED_ARGC 2
#define git_config_get_int64_OPTIONAL_ARGC 0
/* git_config_get_int64
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_int64(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  int native_out;
  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_get_int64(&native_out, native_cfg, native_name);

  /* Box out param: out */
  mrb_value out = mrb_fixnum_value(native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_mapped */
/* sha: f6484c45bb039e8b3f9623f1ec2b6c43386ea6a4c60717abed6c56ad285e40a1 */
#if BIND_git_config_get_mapped_FUNCTION
#define git_config_get_mapped_REQUIRED_ARGC 4
#define git_config_get_mapped_OPTIONAL_ARGC 0
/* git_config_get_mapped
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * - maps: const git_cvar_map *
 * - map_n: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_mapped(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  int native_out;
  mrb_value cfg;
  char * native_name = NULL;
  mrb_value maps;
  mrb_int native_map_n;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoi", &cfg, &native_name, &maps, &native_map_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, maps, CvarMap_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CvarMap expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Unbox param: maps */
  const git_cvar_map * native_maps = (mrb_nil_p(maps) ? NULL : mruby_unbox_git_cvar_map(maps));

  /* Invocation */
  int native_return_value = git_config_get_mapped(&native_out, native_cfg, native_name, native_maps, native_map_n);

  /* Box out param: out */
  mrb_value out = mrb_fixnum_value(native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_multivar_foreach */
/* sha: 40c7e3be1b7abeffbd2a1db61e50292de792d1a442dde1b16b86c6e6caf216e4 */
#if BIND_git_config_get_multivar_foreach_FUNCTION
#define git_config_get_multivar_foreach_REQUIRED_ARGC 5
#define git_config_get_multivar_foreach_OPTIONAL_ARGC 0
/* git_config_get_multivar_foreach
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * - regexp: const char *
 * - callback: git_config_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_multivar_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value cfg;
  char * native_name = NULL;
  char * native_regexp = NULL;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzoo", &cfg, &native_name, &native_regexp, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_config_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Unbox param: callback */
  git_config_foreach_cb native_callback = TODO_mruby_unbox_git_config_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_config_get_multivar_foreach(native_cfg, native_name, native_regexp, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_path */
/* sha: 19f2f6aa74599559f3ca37f9b248c215973234ebeb42eab5d4f364819a00c95f */
#if BIND_git_config_get_path_FUNCTION
#define git_config_get_path_REQUIRED_ARGC 2
#define git_config_get_path_OPTIONAL_ARGC 0
/* git_config_get_path
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_path(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_get_path(native_out, native_cfg, native_name);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_string */
/* sha: e3e8dcd2064dd0970976a2e4bb57dc06c796087f78b17edd4524564cfb218d37 */
#if BIND_git_config_get_string_FUNCTION
#define git_config_get_string_REQUIRED_ARGC 2
#define git_config_get_string_OPTIONAL_ARGC 0
/* git_config_get_string
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_string(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  char * native_out = NULL;
  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_get_string(&native_out, native_cfg, native_name);

  /* Box out param: out */
  mrb_value out = native_out ==  NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_get_string_buf */
/* sha: 346e9207e12f2f996329b3ee805e1f1bbd4f1132a3c95d3f1db26704e5f80a0c */
#if BIND_git_config_get_string_buf_FUNCTION
#define git_config_get_string_buf_REQUIRED_ARGC 2
#define git_config_get_string_buf_OPTIONAL_ARGC 0
/* git_config_get_string_buf
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_get_string_buf(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value cfg;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_get_string_buf(native_out, native_cfg, native_name);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_iterator_free */
/* sha: b52ea96b15f875471910e4261e115e2ff141a9f817852dcf52356a72e53e4188 */
#if BIND_git_config_iterator_free_FUNCTION
#define git_config_iterator_free_REQUIRED_ARGC 1
#define git_config_iterator_free_OPTIONAL_ARGC 0
/* git_config_iterator_free
 *
 * Parameters:
 * - iter: git_config_iterator *
 * Return Type: void
 */
mrb_value
mrb_Git_git_config_iterator_free(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, ConfigIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ConfigIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iter */
  git_config_iterator * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox_git_config_iterator(iter));

  /* Invocation */
  git_config_iterator_free(native_iter);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_iterator_glob_new */
/* sha: 790c81e8cd1e09e527b5212f42bfd770c5ecd9b5f4c28a842f7171b73e551947 */
#if BIND_git_config_iterator_glob_new_FUNCTION
#define git_config_iterator_glob_new_REQUIRED_ARGC 2
#define git_config_iterator_glob_new_OPTIONAL_ARGC 0
/* git_config_iterator_glob_new
 *
 * Parameters:
 * - cfg: const git_config *
 * - regexp: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_iterator_glob_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_config_iterator * native_out = NULL;
  mrb_value cfg;
  char * native_regexp = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &cfg, &native_regexp);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_iterator_glob_new(&native_out, native_cfg, native_regexp);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config_iterator(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_iterator_new */
/* sha: b10bd44027cb8ff96c8d06f76bd38eee099dd07e30af6e773021cd4c35c479fd */
#if BIND_git_config_iterator_new_FUNCTION
#define git_config_iterator_new_REQUIRED_ARGC 1
#define git_config_iterator_new_OPTIONAL_ARGC 0
/* git_config_iterator_new
 *
 * Parameters:
 * - cfg: const git_config *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_iterator_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_config_iterator * native_out = NULL;
  mrb_value cfg;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &cfg);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_iterator_new(&native_out, native_cfg);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config_iterator(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_lock */
/* sha: a69dd2f0c287274c5e7342ca420407f4b1f452bbcc400f30df0e7b253cfd75c0 */
#if BIND_git_config_lock_FUNCTION
#define git_config_lock_REQUIRED_ARGC 1
#define git_config_lock_OPTIONAL_ARGC 0
/* git_config_lock
 *
 * Parameters:
 * - cfg: git_config *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_lock(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_transaction * native_tx = NULL;
  mrb_value cfg;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &cfg);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_lock(&native_tx, native_cfg);

  /* Box out param: tx */
  mrb_value tx = native_tx == NULL ? mrb_nil_value() : mruby_giftwrap_git_transaction(mrb, native_tx);

  RAISE_GIT_ERROR(native_return_value);

  return tx;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_lookup_map_value */
/* sha: f50eb33671ad67b6da9c7d99c7fdde651db93e3e36c626f374709f30a2b46eb1 */
#if BIND_git_config_lookup_map_value_FUNCTION
#define git_config_lookup_map_value_REQUIRED_ARGC 3
#define git_config_lookup_map_value_OPTIONAL_ARGC 0
/* git_config_lookup_map_value
 *
 * Parameters:
 * - maps: const git_cvar_map *
 * - map_n: size_t
 * - value: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_lookup_map_value(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  int native_out;
  mrb_value maps;
  mrb_int native_map_n;
  char * native_value = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oiz", &maps, &native_map_n, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, maps, CvarMap_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CvarMap expected");
    return mrb_nil_value();
  }

  /* Unbox param: maps */
  const git_cvar_map * native_maps = (mrb_nil_p(maps) ? NULL : mruby_unbox_git_cvar_map(maps));

  /* Invocation */
  int native_return_value = git_config_lookup_map_value(&native_out, native_maps, native_map_n, native_value);

  /* Box out param: out */
  mrb_value out = mrb_fixnum_value(native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_multivar_iterator_new */
/* sha: 7abdf61df40c64fa511a8b52ffdc2aea34a73d1ac4575a789984c71251d4f894 */
#if BIND_git_config_multivar_iterator_new_FUNCTION
#define git_config_multivar_iterator_new_REQUIRED_ARGC 3
#define git_config_multivar_iterator_new_OPTIONAL_ARGC 0
/* git_config_multivar_iterator_new
 *
 * Parameters:
 * - cfg: const git_config *
 * - name: const char *
 * - regexp: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_multivar_iterator_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_config_iterator * native_out = NULL;
  mrb_value cfg;
  char * native_name = NULL;
  char * native_regexp = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &cfg, &native_name, &native_regexp);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  const git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_multivar_iterator_new(&native_out, native_cfg, native_name, native_regexp);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config_iterator(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_new */
/* sha: 4b573476b52b98b801aa66950cea9fefc798a5f232b020310d013bf6f7cdf473 */
#if BIND_git_config_new_FUNCTION
#define git_config_new_REQUIRED_ARGC 0
#define git_config_new_OPTIONAL_ARGC 0
/* git_config_new
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_config * native_out = NULL;


  /* Invocation */
  int native_return_value = git_config_new(&native_out);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_next */
/* sha: 84db81b3203b3493f9a0ea64c0dfb8ee60a81748f4ee97b2524d0d4d2975c67b */
#if BIND_git_config_next_FUNCTION
#define git_config_next_REQUIRED_ARGC 1
#define git_config_next_OPTIONAL_ARGC 0
/* git_config_next
 *
 * Parameters:
 * - iter: git_config_iterator *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_next(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_config_entry * native_entry = NULL;
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, ConfigIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ConfigIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iter */
  git_config_iterator * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox_git_config_iterator(iter));

  /* Invocation */
  int native_return_value = git_config_next(&native_entry, native_iter);

  /* Box out param: entry */
  mrb_value entry = native_entry == NULL ? mrb_nil_value() : mruby_giftwrap_git_config_entry(mrb, native_entry);

  RAISE_GIT_ERROR(native_return_value);

  return entry;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_open_default */
/* sha: 60bd07f6f7e2dc5a9e4147002cc166063e3ea385040e9efd941bff753cb298f1 */
#if BIND_git_config_open_default_FUNCTION
#define git_config_open_default_REQUIRED_ARGC 0
#define git_config_open_default_OPTIONAL_ARGC 0
/* git_config_open_default
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_open_default(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_config * native_out = NULL;


  /* Invocation */
  int native_return_value = git_config_open_default(&native_out);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_open_global */
/* sha: 83ceb42c5b2babc178deaa75702ce817319cef3f403046bea07091fa2b89f3fe */
#if BIND_git_config_open_global_FUNCTION
#define git_config_open_global_REQUIRED_ARGC 1
#define git_config_open_global_OPTIONAL_ARGC 0
/* git_config_open_global
 *
 * Parameters:
 * - config: git_config *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_open_global(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_config * native_out = NULL;
  mrb_value config;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &config);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, config, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: config */
  git_config * native_config = (mrb_nil_p(config) ? NULL : mruby_unbox_git_config(config));

  /* Invocation */
  int native_return_value = git_config_open_global(&native_out, native_config);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_open_level */
/* sha: 053d931a542c8ccaaf5095ebaec2be1215fae2545408230099f1909ba6fa16cb */
#if BIND_git_config_open_level_FUNCTION
#define git_config_open_level_REQUIRED_ARGC 2
#define git_config_open_level_OPTIONAL_ARGC 0
/* git_config_open_level
 *
 * Parameters:
 * - parent: const git_config *
 * - level: git_config_level_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_open_level(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_config * native_out = NULL;
  mrb_value parent;
  mrb_int native_level;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &parent, &native_level);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, parent, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: parent */
  const git_config * native_parent = (mrb_nil_p(parent) ? NULL : mruby_unbox_git_config(parent));

  /* Invocation */
  int native_return_value = git_config_open_level(&native_out, native_parent, native_level);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_open_ondisk */
/* sha: f3a54bf6240ee717a70d2af11fce862439f1bdaa977b1011ecc49ce9f00d5074 */
#if BIND_git_config_open_ondisk_FUNCTION
#define git_config_open_ondisk_REQUIRED_ARGC 1
#define git_config_open_ondisk_OPTIONAL_ARGC 0
/* git_config_open_ondisk
 *
 * Parameters:
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_open_ondisk(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_config * native_out = NULL;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_path);

  /* Invocation */
  int native_return_value = git_config_open_ondisk(&native_out, native_path);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_parse_bool */
/* sha: 2a8a0a0a8a76ec91183b9e180325230d2c2fed93e9685eed8b827ea3dd16123d */
#if BIND_git_config_parse_bool_FUNCTION
#define git_config_parse_bool_REQUIRED_ARGC 1
#define git_config_parse_bool_OPTIONAL_ARGC 0
/* git_config_parse_bool
 *
 * Parameters:
 * - value: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_parse_bool(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  int native_out;
  char * native_value = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_value);

  /* Invocation */
  int native_return_value = git_config_parse_bool(&native_out, native_value);

  /* Box out param: out */
  mrb_value out = native_out == 0 ? mrb_false_value() : mrb_true_value();

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_parse_int32 */
/* sha: 878403c75b6590890360d4a60671a90bcfae8417ccd67bab05ec7d9017404f3a */
#if BIND_git_config_parse_int32_FUNCTION
#define git_config_parse_int32_REQUIRED_ARGC 1
#define git_config_parse_int32_OPTIONAL_ARGC 0
/* git_config_parse_int32
 *
 * Parameters:
 * - value: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_parse_int32(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  int native_out;
  char * native_value = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_value);

  /* Invocation */
  int native_return_value = git_config_parse_int32(&native_out, native_value);

  /* Box out param: out */
  mrb_value out = mrb_fixnum_value(native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_parse_int64 */
/* sha: 7466576feb4e1446a3e10b6313a190d79e7619848edd9d01dbfc41cc84b7e99c */
#if BIND_git_config_parse_int64_FUNCTION
#define git_config_parse_int64_REQUIRED_ARGC 1
#define git_config_parse_int64_OPTIONAL_ARGC 0
/* git_config_parse_int64
 *
 * Parameters:
 * - value: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_parse_int64(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  int native_out;
  char * native_value = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_value);

  /* Invocation */
  int native_return_value = git_config_parse_int64(&native_out, native_value);

  /* Box out param: out */
  mrb_value out = mrb_fixnum_value(native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_parse_path */
/* sha: 3b722f0d251eacf0d569c2c34f2dee2a15b414e3b672ee669be7a5d16b5dc7ba */
#if BIND_git_config_parse_path_FUNCTION
#define git_config_parse_path_REQUIRED_ARGC 1
#define git_config_parse_path_OPTIONAL_ARGC 0
/* git_config_parse_path
 *
 * Parameters:
 * - value: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_parse_path(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  char * native_value = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_value);

  /* Invocation */
  int native_return_value = git_config_parse_path(native_out, native_value);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_set_bool */
/* sha: c1c8a11da7ebae7f498f278480679a3c82783d3da1e5020f47cf715137443fd1 */
#if BIND_git_config_set_bool_FUNCTION
#define git_config_set_bool_REQUIRED_ARGC 3
#define git_config_set_bool_OPTIONAL_ARGC 0
/* git_config_set_bool
 *
 * Parameters:
 * - cfg: git_config *
 * - name: const char *
 * - value: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_set_bool(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value cfg;
  char * native_name = NULL;
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &cfg, &native_name, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_set_bool(native_cfg, native_name, native_value);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_set_int32 */
/* sha: f448dec1a3bcd95aa421641ee70836f6d76d596ac9e6f861aa6ff902fc90a5a4 */
#if BIND_git_config_set_int32_FUNCTION
#define git_config_set_int32_REQUIRED_ARGC 3
#define git_config_set_int32_OPTIONAL_ARGC 0
/* git_config_set_int32
 *
 * Parameters:
 * - cfg: git_config *
 * - name: const char *
 * - value: int32_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_set_int32(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value cfg;
  char * native_name = NULL;
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &cfg, &native_name, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_set_int32(native_cfg, native_name, native_value);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_set_int64 */
/* sha: e0637b2bb130389a89f30eb91ee455ff51c9d9a87ea352e3514b890e86ae531a */
#if BIND_git_config_set_int64_FUNCTION
#define git_config_set_int64_REQUIRED_ARGC 3
#define git_config_set_int64_OPTIONAL_ARGC 0
/* git_config_set_int64
 *
 * Parameters:
 * - cfg: git_config *
 * - name: const char *
 * - value: int64_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_set_int64(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value cfg;
  char * native_name = NULL;
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &cfg, &native_name, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_set_int64(native_cfg, native_name, native_value);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_set_multivar */
/* sha: fd1405640d27f75791390ce690cfd5f6322864ac03d49479619da0f5b2ebb8e0 */
#if BIND_git_config_set_multivar_FUNCTION
#define git_config_set_multivar_REQUIRED_ARGC 4
#define git_config_set_multivar_OPTIONAL_ARGC 0
/* git_config_set_multivar
 *
 * Parameters:
 * - cfg: git_config *
 * - name: const char *
 * - regexp: const char *
 * - value: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_set_multivar(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value cfg;
  char * native_name = NULL;
  char * native_regexp = NULL;
  char * native_value = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzz", &cfg, &native_name, &native_regexp, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_set_multivar(native_cfg, native_name, native_regexp, native_value);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_set_string */
/* sha: 4da92b1f385fcd134dc1881d28fbf998096746d39cc72abbcf35905ba2266780 */
#if BIND_git_config_set_string_FUNCTION
#define git_config_set_string_REQUIRED_ARGC 3
#define git_config_set_string_OPTIONAL_ARGC 0
/* git_config_set_string
 *
 * Parameters:
 * - cfg: git_config *
 * - name: const char *
 * - value: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_set_string(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value cfg;
  char * native_name = NULL;
  char * native_value = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &cfg, &native_name, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cfg, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: cfg */
  git_config * native_cfg = (mrb_nil_p(cfg) ? NULL : mruby_unbox_git_config(cfg));

  /* Invocation */
  int native_return_value = git_config_set_string(native_cfg, native_name, native_value);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_config_snapshot */
/* sha: 49d405bc829ddcc9939be46b521e66788dbdb6391ec625cefc0ca4df24612f0c */
#if BIND_git_config_snapshot_FUNCTION
#define git_config_snapshot_REQUIRED_ARGC 1
#define git_config_snapshot_OPTIONAL_ARGC 0
/* git_config_snapshot
 *
 * Parameters:
 * - config: git_config *
 * Return Type: int
 */
mrb_value
mrb_Git_git_config_snapshot(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_config * native_out = NULL;
  mrb_value config;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &config);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, config, Config_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Config expected");
    return mrb_nil_value();
  }

  /* Unbox param: config */
  git_config * native_config = (mrb_nil_p(config) ? NULL : mruby_unbox_git_config(config));

  /* Invocation */
  int native_return_value = git_config_snapshot(&native_out, native_config);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_default_new */
/* sha: 44a5e0ac57261fa03adc2765f5fad1f782a4178e8f9f1f27fdd484e948577dc2 */
#if BIND_git_cred_default_new_FUNCTION
#define git_cred_default_new_REQUIRED_ARGC 0
#define git_cred_default_new_OPTIONAL_ARGC 0
/* git_cred_default_new
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_default_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_cred * native_out = NULL;


  /* Invocation */
  int native_return_value = git_cred_default_new(&native_out);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_free */
/* sha: e34b48b43361ce39ec0319d29373ab57cddcfaa31abf5d19522fc1533e1d7251 */
#if BIND_git_cred_free_FUNCTION
#define git_cred_free_REQUIRED_ARGC 1
#define git_cred_free_OPTIONAL_ARGC 0
/* git_cred_free
 *
 * Parameters:
 * - cred: git_cred *
 * Return Type: void
 */
mrb_value
mrb_Git_git_cred_free(mrb_state* mrb, mrb_value self) {
  mrb_value cred;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &cred);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cred, Cred_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Cred expected");
    return mrb_nil_value();
  }

  /* Unbox param: cred */
  git_cred * native_cred = (mrb_nil_p(cred) ? NULL : mruby_unbox_git_cred(cred));

  /* Invocation */
  git_cred_free(native_cred);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_has_username */
/* sha: 7e63b1bd9858d4674d1e39bf8d3526c350cf5550bc47c992055a25625e2cd01c */
#if BIND_git_cred_has_username_FUNCTION
#define git_cred_has_username_REQUIRED_ARGC 1
#define git_cred_has_username_OPTIONAL_ARGC 0
/* git_cred_has_username
 *
 * Parameters:
 * - cred: git_cred *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_has_username(mrb_state* mrb, mrb_value self) {
  mrb_value cred;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &cred);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cred, Cred_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Cred expected");
    return mrb_nil_value();
  }

  /* Unbox param: cred */
  git_cred * native_cred = (mrb_nil_p(cred) ? NULL : mruby_unbox_git_cred(cred));

  /* Invocation */
  int native_return_value = git_cred_has_username(native_cred);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_ssh_custom_new */
/* sha: c4e822956f313e1eaad01039d6f9d809a917f61dff3682b3bd4645a16e7dabed */
#if BIND_git_cred_ssh_custom_new_FUNCTION
#define git_cred_ssh_custom_new_REQUIRED_ARGC 5
#define git_cred_ssh_custom_new_OPTIONAL_ARGC 0
/* git_cred_ssh_custom_new
 *
 * Parameters:
 * - username: const char *
 * - publickey: const char *
 * - publickey_len: size_t
 * - sign_callback: git_cred_sign_callback
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_ssh_custom_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_cred * native_out = NULL;
  char * native_username = NULL;
  char * native_publickey = NULL;
  mrb_int native_publickey_len;
  mrb_value sign_callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "zzioo", &native_username, &native_publickey, &native_publickey_len, &sign_callback, &payload);

  /* Type checking */
  TODO_type_check_git_cred_sign_callback(sign_callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: sign_callback */
  git_cred_sign_callback native_sign_callback = TODO_mruby_unbox_git_cred_sign_callback(sign_callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_cred_ssh_custom_new(&native_out, native_username, native_publickey, native_publickey_len, native_sign_callback, native_payload);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_ssh_interactive_new */
/* sha: aa095c5da8628f0893850f2137e4a905b45b1b121fbae3480812a4ab546ae678 */
#if BIND_git_cred_ssh_interactive_new_FUNCTION
#define git_cred_ssh_interactive_new_REQUIRED_ARGC 3
#define git_cred_ssh_interactive_new_OPTIONAL_ARGC 0
/* git_cred_ssh_interactive_new
 *
 * Parameters:
 * - username: const char *
 * - prompt_callback: git_cred_ssh_interactive_callback
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_ssh_interactive_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_cred * native_out = NULL;
  char * native_username = NULL;
  mrb_value prompt_callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "zoo", &native_username, &prompt_callback, &payload);

  /* Type checking */
  TODO_type_check_git_cred_ssh_interactive_callback(prompt_callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: prompt_callback */
  git_cred_ssh_interactive_callback native_prompt_callback = TODO_mruby_unbox_git_cred_ssh_interactive_callback(prompt_callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_cred_ssh_interactive_new(&native_out, native_username, native_prompt_callback, native_payload);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_ssh_key_from_agent */
/* sha: 1e9f705a6e5af157940b9a22909f1b4e2ceb13b6cc2ec3fdaa20ebd64ff47982 */
#if BIND_git_cred_ssh_key_from_agent_FUNCTION
#define git_cred_ssh_key_from_agent_REQUIRED_ARGC 1
#define git_cred_ssh_key_from_agent_OPTIONAL_ARGC 0
/* git_cred_ssh_key_from_agent
 *
 * Parameters:
 * - username: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_ssh_key_from_agent(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_cred * native_out = NULL;
  char * native_username = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_username);

  /* Invocation */
  int native_return_value = git_cred_ssh_key_from_agent(&native_out, native_username);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_ssh_key_memory_new */
/* sha: fc82b6966f57229b7686507cd5b1e8200972ef5d82c80f8a5674e8086ad2aafd */
#if BIND_git_cred_ssh_key_memory_new_FUNCTION
#define git_cred_ssh_key_memory_new_REQUIRED_ARGC 4
#define git_cred_ssh_key_memory_new_OPTIONAL_ARGC 0
/* git_cred_ssh_key_memory_new
 *
 * Parameters:
 * - username: const char *
 * - publickey: const char *
 * - privatekey: const char *
 * - passphrase: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_ssh_key_memory_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_cred * native_out = NULL;
  char * native_username = NULL;
  char * native_publickey = NULL;
  char * native_privatekey = NULL;
  char * native_passphrase = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "zzzz", &native_username, &native_publickey, &native_privatekey, &native_passphrase);

  /* Invocation */
  int native_return_value = git_cred_ssh_key_memory_new(&native_out, native_username, native_publickey, native_privatekey, native_passphrase);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_ssh_key_new */
/* sha: f5f7f973864f04ff566c83004354e94d7c403aa50faad0040c8160a425b31ae4 */
#if BIND_git_cred_ssh_key_new_FUNCTION
#define git_cred_ssh_key_new_REQUIRED_ARGC 4
#define git_cred_ssh_key_new_OPTIONAL_ARGC 0
/* git_cred_ssh_key_new
 *
 * Parameters:
 * - username: const char *
 * - publickey: const char *
 * - privatekey: const char *
 * - passphrase: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_ssh_key_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_cred * native_out = NULL;
  char * native_username = NULL;
  char * native_publickey = NULL;
  char * native_privatekey = NULL;
  char * native_passphrase = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "zzzz", &native_username, &native_publickey, &native_privatekey, &native_passphrase);

  /* Invocation */
  int native_return_value = git_cred_ssh_key_new(&native_out, native_username, native_publickey, native_privatekey, native_passphrase);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_username_new */
/* sha: 47ba04e4121c3ebe0f249a0f6a4b26df3fc90f4a43810789b62af2183662fd35 */
#if BIND_git_cred_username_new_FUNCTION
#define git_cred_username_new_REQUIRED_ARGC 1
#define git_cred_username_new_OPTIONAL_ARGC 0
/* git_cred_username_new
 *
 * Parameters:
 * - username: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_username_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_cred * native_cred = NULL;
  char * native_username = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_username);

  /* Invocation */
  int native_return_value = git_cred_username_new(&native_cred, native_username);

  /* Box out param: cred */
  mrb_value cred = native_cred == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_cred);

  RAISE_GIT_ERROR(native_return_value);

  return cred;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_userpass */
/* sha: 01be6496a74eae2070e571418e4dd2e92d31b404351aaf7a2ad3388fc3c93ebd */
#if BIND_git_cred_userpass_FUNCTION
#define git_cred_userpass_REQUIRED_ARGC 4
#define git_cred_userpass_OPTIONAL_ARGC 0
/* git_cred_userpass
 *
 * Parameters:
 * - url: const char *
 * - user_from_url: const char *
 * - allowed_types: unsigned int
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_userpass(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_cred * native_cred = NULL;
  char * native_url = NULL;
  char * native_user_from_url = NULL;
  mrb_int native_allowed_types;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "zzio", &native_url, &native_user_from_url, &native_allowed_types, &payload);

  /* Type checking */
  TODO_type_check_void_PTR(payload);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_cred_userpass(&native_cred, native_url, native_user_from_url, native_allowed_types, native_payload);

  /* Box out param: cred */
  mrb_value cred = native_cred == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_cred);

  RAISE_GIT_ERROR(native_return_value);

  return cred;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_cred_userpass_plaintext_new */
/* sha: d255cf9e0d53da471825e440efdc3d32ebfe437c4e867f54d210cd6cb72cc823 */
#if BIND_git_cred_userpass_plaintext_new_FUNCTION
#define git_cred_userpass_plaintext_new_REQUIRED_ARGC 2
#define git_cred_userpass_plaintext_new_OPTIONAL_ARGC 0
/* git_cred_userpass_plaintext_new
 *
 * Parameters:
 * - username: const char *
 * - password: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_cred_userpass_plaintext_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_cred * native_out = NULL;
  char * native_username = NULL;
  char * native_password = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "zz", &native_username, &native_password);

  /* Invocation */
  int native_return_value = git_cred_userpass_plaintext_new(&native_out, native_username, native_password);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_cred(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_describe_commit */
/* sha: b5e7db0ab1296820e91556d4dc187d6d951399f5ff2edfe2eaacccbd6216085b */
#if BIND_git_describe_commit_FUNCTION
#define git_describe_commit_REQUIRED_ARGC 2
#define git_describe_commit_OPTIONAL_ARGC 0
/* git_describe_commit
 *
 * Parameters:
 * - committish: git_object *
 * - opts: git_describe_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_describe_commit(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_describe_result * native_result = NULL;
  mrb_value committish;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &committish, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, committish, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DescribeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DescribeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: committish */
  git_object * native_committish = (mrb_nil_p(committish) ? NULL : mruby_unbox_git_object(committish));

  /* Unbox param: opts */
  git_describe_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_describe_options(opts));

  /* Invocation */
  int native_return_value = git_describe_commit(&native_result, native_committish, native_opts);

  /* Box out param: result */
  mrb_value result = native_result == NULL ? mrb_nil_value() : mruby_giftwrap_git_describe_result(mrb, native_result);

  RAISE_GIT_ERROR(native_return_value);

  return result;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_describe_format */
/* sha: d288ad6071ce0c9cca33ff0d94467ec1689ca5db749025cbe06f9be983178e62 */
#if BIND_git_describe_format_FUNCTION
#define git_describe_format_REQUIRED_ARGC 2
#define git_describe_format_OPTIONAL_ARGC 0
/* git_describe_format
 *
 * Parameters:
 * - result: const git_describe_result *
 * - opts: const git_describe_format_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_describe_format(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value result;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &result, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, result, DescribeResult_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DescribeResult expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DescribeFormatOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DescribeFormatOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: result */
  const git_describe_result * native_result = (mrb_nil_p(result) ? NULL : mruby_unbox_git_describe_result(result));

  /* Unbox param: opts */
  const git_describe_format_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_describe_format_options(opts));

  /* Invocation */
  int native_return_value = git_describe_format(native_out, native_result, native_opts);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_describe_init_format_options */
/* sha: 47523dca514027a47bceea4a97ed26a4b5d6d53a992af9b58b4b18551917ef99 */
#if BIND_git_describe_init_format_options_FUNCTION
#define git_describe_init_format_options_REQUIRED_ARGC 2
#define git_describe_init_format_options_OPTIONAL_ARGC 0
/* git_describe_init_format_options
 *
 * Parameters:
 * - opts: git_describe_format_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_describe_init_format_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, DescribeFormatOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DescribeFormatOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_describe_format_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_describe_format_options(opts));

  /* Invocation */
  int native_return_value = git_describe_init_format_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_describe_init_options */
/* sha: 8de2f1383754ca813d94a21bd2f65fe7328a26d351d52da0627efa33aba20630 */
#if BIND_git_describe_init_options_FUNCTION
#define git_describe_init_options_REQUIRED_ARGC 2
#define git_describe_init_options_OPTIONAL_ARGC 0
/* git_describe_init_options
 *
 * Parameters:
 * - opts: git_describe_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_describe_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, DescribeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DescribeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_describe_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_describe_options(opts));

  /* Invocation */
  int native_return_value = git_describe_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_describe_result_free */
/* sha: 6a751bc73bbed1e228c1253634886342ffb4be397c4846a9c80717b06bc846a4 */
#if BIND_git_describe_result_free_FUNCTION
#define git_describe_result_free_REQUIRED_ARGC 1
#define git_describe_result_free_OPTIONAL_ARGC 0
/* git_describe_result_free
 *
 * Parameters:
 * - result: git_describe_result *
 * Return Type: void
 */
mrb_value
mrb_Git_git_describe_result_free(mrb_state* mrb, mrb_value self) {
  mrb_value result;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &result);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, result, DescribeResult_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DescribeResult expected");
    return mrb_nil_value();
  }

  /* Unbox param: result */
  git_describe_result * native_result = (mrb_nil_p(result) ? NULL : mruby_unbox_git_describe_result(result));

  /* Invocation */
  git_describe_result_free(native_result);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_describe_workdir */
/* sha: 47df993a611b9921146b03ef81c56a2c105510f67e71752daa9f42603e4a5c82 */
#if BIND_git_describe_workdir_FUNCTION
#define git_describe_workdir_REQUIRED_ARGC 2
#define git_describe_workdir_OPTIONAL_ARGC 0
/* git_describe_workdir
 *
 * Parameters:
 * - repo: git_repository *
 * - opts: git_describe_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_describe_workdir(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_describe_result * native_out = NULL;
  mrb_value repo;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DescribeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DescribeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: opts */
  git_describe_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_describe_options(opts));

  /* Invocation */
  int native_return_value = git_describe_workdir(&native_out, native_repo, native_opts);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_describe_result(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_blob_to_buffer */
/* sha: 5c7e2ab5b17945827d184cdf344ef3728c84397d740f51160b35e27e3caecf38 */
#if BIND_git_diff_blob_to_buffer_FUNCTION
#define git_diff_blob_to_buffer_REQUIRED_ARGC 11
#define git_diff_blob_to_buffer_OPTIONAL_ARGC 0
/* git_diff_blob_to_buffer
 *
 * Parameters:
 * - old_blob: const git_blob *
 * - old_as_path: const char *
 * - buffer: const char *
 * - buffer_len: size_t
 * - buffer_as_path: const char *
 * - options: const git_diff_options *
 * - file_cb: git_diff_file_cb
 * - binary_cb: git_diff_binary_cb
 * - hunk_cb: git_diff_hunk_cb
 * - line_cb: git_diff_line_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_blob_to_buffer(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value old_blob;
  char * native_old_as_path = NULL;
  char * native_buffer = NULL;
  mrb_int native_buffer_len;
  char * native_buffer_as_path = NULL;
  mrb_value options;
  mrb_value file_cb;
  mrb_value binary_cb;
  mrb_value hunk_cb;
  mrb_value line_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzizoooooo", &old_blob, &native_old_as_path, &native_buffer, &native_buffer_len, &native_buffer_as_path, &options, &file_cb, &binary_cb, &hunk_cb, &line_cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, old_blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, options, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_diff_file_cb(file_cb);
  TODO_type_check_git_diff_binary_cb(binary_cb);
  TODO_type_check_git_diff_hunk_cb(hunk_cb);
  TODO_type_check_git_diff_line_cb(line_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: old_blob */
  const git_blob * native_old_blob = (mrb_nil_p(old_blob) ? NULL : mruby_unbox_git_blob(old_blob));

  /* Unbox param: options */
  const git_diff_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_diff_options(options));

  /* Unbox param: file_cb */
  git_diff_file_cb native_file_cb = TODO_mruby_unbox_git_diff_file_cb(file_cb);

  /* Unbox param: binary_cb */
  git_diff_binary_cb native_binary_cb = TODO_mruby_unbox_git_diff_binary_cb(binary_cb);

  /* Unbox param: hunk_cb */
  git_diff_hunk_cb native_hunk_cb = TODO_mruby_unbox_git_diff_hunk_cb(hunk_cb);

  /* Unbox param: line_cb */
  git_diff_line_cb native_line_cb = TODO_mruby_unbox_git_diff_line_cb(line_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_diff_blob_to_buffer(native_old_blob, native_old_as_path, native_buffer, native_buffer_len, native_buffer_as_path, native_options, native_file_cb, native_binary_cb, native_hunk_cb, native_line_cb, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_blobs */
/* sha: c2ba54b7aa47420e0f693ad81276138f176cf056ee7f9e24ec95158e4deef657 */
#if BIND_git_diff_blobs_FUNCTION
#define git_diff_blobs_REQUIRED_ARGC 10
#define git_diff_blobs_OPTIONAL_ARGC 0
/* git_diff_blobs
 *
 * Parameters:
 * - old_blob: const git_blob *
 * - old_as_path: const char *
 * - new_blob: const git_blob *
 * - new_as_path: const char *
 * - options: const git_diff_options *
 * - file_cb: git_diff_file_cb
 * - binary_cb: git_diff_binary_cb
 * - hunk_cb: git_diff_hunk_cb
 * - line_cb: git_diff_line_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_blobs(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value old_blob;
  char * native_old_as_path = NULL;
  mrb_value new_blob;
  char * native_new_as_path = NULL;
  mrb_value options;
  mrb_value file_cb;
  mrb_value binary_cb;
  mrb_value hunk_cb;
  mrb_value line_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozozoooooo", &old_blob, &native_old_as_path, &new_blob, &native_new_as_path, &options, &file_cb, &binary_cb, &hunk_cb, &line_cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, old_blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, new_blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, options, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_diff_file_cb(file_cb);
  TODO_type_check_git_diff_binary_cb(binary_cb);
  TODO_type_check_git_diff_hunk_cb(hunk_cb);
  TODO_type_check_git_diff_line_cb(line_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: old_blob */
  const git_blob * native_old_blob = (mrb_nil_p(old_blob) ? NULL : mruby_unbox_git_blob(old_blob));

  /* Unbox param: new_blob */
  const git_blob * native_new_blob = (mrb_nil_p(new_blob) ? NULL : mruby_unbox_git_blob(new_blob));

  /* Unbox param: options */
  const git_diff_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_diff_options(options));

  /* Unbox param: file_cb */
  git_diff_file_cb native_file_cb = TODO_mruby_unbox_git_diff_file_cb(file_cb);

  /* Unbox param: binary_cb */
  git_diff_binary_cb native_binary_cb = TODO_mruby_unbox_git_diff_binary_cb(binary_cb);

  /* Unbox param: hunk_cb */
  git_diff_hunk_cb native_hunk_cb = TODO_mruby_unbox_git_diff_hunk_cb(hunk_cb);

  /* Unbox param: line_cb */
  git_diff_line_cb native_line_cb = TODO_mruby_unbox_git_diff_line_cb(line_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_diff_blobs(native_old_blob, native_old_as_path, native_new_blob, native_new_as_path, native_options, native_file_cb, native_binary_cb, native_hunk_cb, native_line_cb, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_buffers */
/* sha: 50fc7ea4752faee6dfab0db1a6751dccaf6e0674fd13ec14b4123eb038185da8 */
#if BIND_git_diff_buffers_FUNCTION
#define git_diff_buffers_REQUIRED_ARGC 12
#define git_diff_buffers_OPTIONAL_ARGC 0
/* git_diff_buffers
 *
 * Parameters:
 * - old_buffer: const void *
 * - old_len: size_t
 * - old_as_path: const char *
 * - new_buffer: const void *
 * - new_len: size_t
 * - new_as_path: const char *
 * - options: const git_diff_options *
 * - file_cb: git_diff_file_cb
 * - binary_cb: git_diff_binary_cb
 * - hunk_cb: git_diff_hunk_cb
 * - line_cb: git_diff_line_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_buffers(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value old_buffer;
  mrb_int native_old_len;
  char * native_old_as_path = NULL;
  mrb_value new_buffer;
  mrb_int native_new_len;
  char * native_new_as_path = NULL;
  mrb_value options;
  mrb_value file_cb;
  mrb_value binary_cb;
  mrb_value hunk_cb;
  mrb_value line_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oizoizoooooo", &old_buffer, &native_old_len, &native_old_as_path, &new_buffer, &native_new_len, &native_new_as_path, &options, &file_cb, &binary_cb, &hunk_cb, &line_cb, &payload);

  /* Type checking */
  TODO_type_check_void_PTR(old_buffer);
  TODO_type_check_void_PTR(new_buffer);
  if (!mrb_obj_is_kind_of(mrb, options, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_diff_file_cb(file_cb);
  TODO_type_check_git_diff_binary_cb(binary_cb);
  TODO_type_check_git_diff_hunk_cb(hunk_cb);
  TODO_type_check_git_diff_line_cb(line_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: old_buffer */
  const void * native_old_buffer = TODO_mruby_unbox_void_PTR(old_buffer);

  /* Unbox param: new_buffer */
  const void * native_new_buffer = TODO_mruby_unbox_void_PTR(new_buffer);

  /* Unbox param: options */
  const git_diff_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_diff_options(options));

  /* Unbox param: file_cb */
  git_diff_file_cb native_file_cb = TODO_mruby_unbox_git_diff_file_cb(file_cb);

  /* Unbox param: binary_cb */
  git_diff_binary_cb native_binary_cb = TODO_mruby_unbox_git_diff_binary_cb(binary_cb);

  /* Unbox param: hunk_cb */
  git_diff_hunk_cb native_hunk_cb = TODO_mruby_unbox_git_diff_hunk_cb(hunk_cb);

  /* Unbox param: line_cb */
  git_diff_line_cb native_line_cb = TODO_mruby_unbox_git_diff_line_cb(line_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_diff_buffers(native_old_buffer, native_old_len, native_old_as_path, native_new_buffer, native_new_len, native_new_as_path, native_options, native_file_cb, native_binary_cb, native_hunk_cb, native_line_cb, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_commit_as_email */
/* sha: 5ed6398f285ad074a2b880711ddca2fa673cc899ee539a5637256cbbe460052b */
#if BIND_git_diff_commit_as_email_FUNCTION
#define git_diff_commit_as_email_REQUIRED_ARGC 6
#define git_diff_commit_as_email_OPTIONAL_ARGC 0
/* git_diff_commit_as_email
 *
 * Parameters:
 * - repo: git_repository *
 * - commit: git_commit *
 * - patch_no: size_t
 * - total_patches: size_t
 * - flags: git_diff_format_email_flags_t
 * - diff_opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_commit_as_email(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value repo;
  mrb_value commit;
  mrb_int native_patch_no;
  mrb_int native_total_patches;
  mrb_int native_flags;
  mrb_value diff_opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooiiio", &repo, &commit, &native_patch_no, &native_total_patches, &native_flags, &diff_opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, diff_opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: commit */
  git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Unbox param: diff_opts */
  const git_diff_options * native_diff_opts = (mrb_nil_p(diff_opts) ? NULL : mruby_unbox_git_diff_options(diff_opts));

  /* Invocation */
  int native_return_value = git_diff_commit_as_email(native_out, native_repo, native_commit, native_patch_no, native_total_patches, native_flags, native_diff_opts);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_find_init_options */
/* sha: 8a5d3b79f44fb04f7eb854705b791cc901f958cd00ed4dccbc69658583fe066e */
#if BIND_git_diff_find_init_options_FUNCTION
#define git_diff_find_init_options_REQUIRED_ARGC 2
#define git_diff_find_init_options_OPTIONAL_ARGC 0
/* git_diff_find_init_options
 *
 * Parameters:
 * - opts: git_diff_find_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_find_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, DiffFindOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffFindOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_diff_find_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_find_options(opts));

  /* Invocation */
  int native_return_value = git_diff_find_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_find_similar */
/* sha: e558735f3fea173f3f791cc590dad9120b94349f7f73b6ffa4c09ae1cad9a61c */
#if BIND_git_diff_find_similar_FUNCTION
#define git_diff_find_similar_REQUIRED_ARGC 2
#define git_diff_find_similar_OPTIONAL_ARGC 0
/* git_diff_find_similar
 *
 * Parameters:
 * - diff: git_diff *
 * - options: const git_diff_find_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_find_similar(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value diff;
  mrb_value options;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &diff, &options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, options, DiffFindOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffFindOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Unbox param: options */
  const git_diff_find_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_diff_find_options(options));

  /* Invocation */
  int native_return_value = git_diff_find_similar(native_diff, native_options);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_foreach */
/* sha: 37deb4f8cc77c1ad7a21f7fdfa90b784a8861e7b94351c5fcfa44df5f445ca10 */
#if BIND_git_diff_foreach_FUNCTION
#define git_diff_foreach_REQUIRED_ARGC 6
#define git_diff_foreach_OPTIONAL_ARGC 0
/* git_diff_foreach
 *
 * Parameters:
 * - diff: git_diff *
 * - file_cb: git_diff_file_cb
 * - binary_cb: git_diff_binary_cb
 * - hunk_cb: git_diff_hunk_cb
 * - line_cb: git_diff_line_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_foreach(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value diff;
  mrb_value file_cb;
  mrb_value binary_cb;
  mrb_value hunk_cb;
  mrb_value line_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oooooo", &diff, &file_cb, &binary_cb, &hunk_cb, &line_cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_diff_file_cb(file_cb);
  TODO_type_check_git_diff_binary_cb(binary_cb);
  TODO_type_check_git_diff_hunk_cb(hunk_cb);
  TODO_type_check_git_diff_line_cb(line_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Unbox param: file_cb */
  git_diff_file_cb native_file_cb = TODO_mruby_unbox_git_diff_file_cb(file_cb);

  /* Unbox param: binary_cb */
  git_diff_binary_cb native_binary_cb = TODO_mruby_unbox_git_diff_binary_cb(binary_cb);

  /* Unbox param: hunk_cb */
  git_diff_hunk_cb native_hunk_cb = TODO_mruby_unbox_git_diff_hunk_cb(hunk_cb);

  /* Unbox param: line_cb */
  git_diff_line_cb native_line_cb = TODO_mruby_unbox_git_diff_line_cb(line_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_diff_foreach(native_diff, native_file_cb, native_binary_cb, native_hunk_cb, native_line_cb, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_format_email */
/* sha: 79a742d51fabe5ec5862ee7d91bf6631d859589701e0a02ff8f51154030ddabd */
#if BIND_git_diff_format_email_FUNCTION
#define git_diff_format_email_REQUIRED_ARGC 2
#define git_diff_format_email_OPTIONAL_ARGC 0
/* git_diff_format_email
 *
 * Parameters:
 * - diff: git_diff *
 * - opts: const git_diff_format_email_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_format_email(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value diff;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &diff, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffFormatEmailOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffFormatEmailOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Unbox param: opts */
  const git_diff_format_email_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_format_email_options(opts));

  /* Invocation */
  int native_return_value = git_diff_format_email(native_out, native_diff, native_opts);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_format_email_init_options */
/* sha: 421b9b2f536692655f16998cead30f348f3002006bcb4554c97375c9dc28d636 */
#if BIND_git_diff_format_email_init_options_FUNCTION
#define git_diff_format_email_init_options_REQUIRED_ARGC 2
#define git_diff_format_email_init_options_OPTIONAL_ARGC 0
/* git_diff_format_email_init_options
 *
 * Parameters:
 * - opts: git_diff_format_email_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_format_email_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, DiffFormatEmailOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffFormatEmailOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_diff_format_email_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_format_email_options(opts));

  /* Invocation */
  int native_return_value = git_diff_format_email_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_free */
/* sha: f6f815e87023d5045c47584d10bb5f8e350a07e56e79fbff577f71bf763c62b3 */
#if BIND_git_diff_free_FUNCTION
#define git_diff_free_REQUIRED_ARGC 1
#define git_diff_free_OPTIONAL_ARGC 0
/* git_diff_free
 *
 * Parameters:
 * - diff: git_diff *
 * Return Type: void
 */
mrb_value
mrb_Git_git_diff_free(mrb_state* mrb, mrb_value self) {
  mrb_value diff;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &diff);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Invocation */
  git_diff_free(native_diff);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_get_delta */
/* sha: 255195e3f819c120797d923c670cfe25563181792797585cd535dd5bfdeb8bb9 */
#if BIND_git_diff_get_delta_FUNCTION
#define git_diff_get_delta_REQUIRED_ARGC 2
#define git_diff_get_delta_OPTIONAL_ARGC 0
/* git_diff_get_delta
 *
 * Parameters:
 * - diff: const git_diff *
 * - idx: size_t
 * Return Type: const git_diff_delta *
 */
mrb_value
mrb_Git_git_diff_get_delta(mrb_state* mrb, mrb_value self) {
  mrb_value diff;
  mrb_int native_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &diff, &native_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  const git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Invocation */
  const git_diff_delta * native_return_value = git_diff_get_delta(native_diff, native_idx);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_diff_delta(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_get_stats */
/* sha: 026b9d1fd565fdf92f60121b0ce123ecf7f080c111d5e24bfdd283487a7fc2e4 */
#if BIND_git_diff_get_stats_FUNCTION
#define git_diff_get_stats_REQUIRED_ARGC 1
#define git_diff_get_stats_OPTIONAL_ARGC 0
/* git_diff_get_stats
 *
 * Parameters:
 * - diff: git_diff *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_get_stats(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_diff_stats * native_out = NULL;
  mrb_value diff;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &diff);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Invocation */
  int native_return_value = git_diff_get_stats(&native_out, native_diff);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_diff_stats(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_index_to_index */
/* sha: fa6e8ab33418801d3be9d2a0e430ff6a0ddc49cabe4a4dbe0d1a7c5d8bf60aa8 */
#if BIND_git_diff_index_to_index_FUNCTION
#define git_diff_index_to_index_REQUIRED_ARGC 4
#define git_diff_index_to_index_OPTIONAL_ARGC 0
/* git_diff_index_to_index
 *
 * Parameters:
 * - repo: git_repository *
 * - old_index: git_index *
 * - new_index: git_index *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_index_to_index(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_diff * native_diff = NULL;
  mrb_value repo;
  mrb_value old_index;
  mrb_value new_index;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &repo, &old_index, &new_index, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, old_index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, new_index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: old_index */
  git_index * native_old_index = (mrb_nil_p(old_index) ? NULL : mruby_unbox_git_index(old_index));

  /* Unbox param: new_index */
  git_index * native_new_index = (mrb_nil_p(new_index) ? NULL : mruby_unbox_git_index(new_index));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_diff_index_to_index(&native_diff, native_repo, native_old_index, native_new_index, native_opts);

  /* Box out param: diff */
  mrb_value diff = native_diff == NULL ? mrb_nil_value() : mruby_giftwrap_git_diff(mrb, native_diff);

  RAISE_GIT_ERROR(native_return_value);

  return diff;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_index_to_workdir */
/* sha: 77b6851a7defa5eb65f3be8082f5ca1ce3db0002e71a59981d878af1ee32cca3 */
#if BIND_git_diff_index_to_workdir_FUNCTION
#define git_diff_index_to_workdir_REQUIRED_ARGC 3
#define git_diff_index_to_workdir_OPTIONAL_ARGC 0
/* git_diff_index_to_workdir
 *
 * Parameters:
 * - repo: git_repository *
 * - index: git_index *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_index_to_workdir(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_diff * native_diff = NULL;
  mrb_value repo;
  mrb_value index;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &index, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_diff_index_to_workdir(&native_diff, native_repo, native_index, native_opts);

  /* Box out param: diff */
  mrb_value diff = native_diff == NULL ? mrb_nil_value() : mruby_giftwrap_git_diff(mrb, native_diff);

  RAISE_GIT_ERROR(native_return_value);

  return diff;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_init_options */
/* sha: 3e57c83ad11828646cde44f638013d8c6d238ab67c1287b509f497b4a07a7a47 */
#if BIND_git_diff_init_options_FUNCTION
#define git_diff_init_options_REQUIRED_ARGC 2
#define git_diff_init_options_OPTIONAL_ARGC 0
/* git_diff_init_options
 *
 * Parameters:
 * - opts: git_diff_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_diff_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_is_sorted_icase */
/* sha: 4a115e31f28304972488de9df56263a34a13507231a645153897a7e15efdcd96 */
#if BIND_git_diff_is_sorted_icase_FUNCTION
#define git_diff_is_sorted_icase_REQUIRED_ARGC 1
#define git_diff_is_sorted_icase_OPTIONAL_ARGC 0
/* git_diff_is_sorted_icase
 *
 * Parameters:
 * - diff: const git_diff *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_is_sorted_icase(mrb_state* mrb, mrb_value self) {
  mrb_value diff;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &diff);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  const git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Invocation */
  int native_return_value = git_diff_is_sorted_icase(native_diff);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_merge */
/* sha: 2f8757f401381c80b09e02d8620c356b482cda1f0e9dc74b4bafeb82b867416d */
#if BIND_git_diff_merge_FUNCTION
#define git_diff_merge_REQUIRED_ARGC 2
#define git_diff_merge_OPTIONAL_ARGC 0
/* git_diff_merge
 *
 * Parameters:
 * - onto: git_diff *
 * - from: const git_diff *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_merge(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value onto;
  mrb_value from;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &onto, &from);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, onto, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, from, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: onto */
  git_diff * native_onto = (mrb_nil_p(onto) ? NULL : mruby_unbox_git_diff(onto));

  /* Unbox param: from */
  const git_diff * native_from = (mrb_nil_p(from) ? NULL : mruby_unbox_git_diff(from));

  /* Invocation */
  int native_return_value = git_diff_merge(native_onto, native_from);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_num_deltas */
/* sha: db2c239b77d134d473a5d0790203d710782060c0efe455ec61e3defa47d0cbbc */
#if BIND_git_diff_num_deltas_FUNCTION
#define git_diff_num_deltas_REQUIRED_ARGC 1
#define git_diff_num_deltas_OPTIONAL_ARGC 0
/* git_diff_num_deltas
 *
 * Parameters:
 * - diff: const git_diff *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_diff_num_deltas(mrb_state* mrb, mrb_value self) {
  mrb_value diff;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &diff);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  const git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Invocation */
  size_t native_return_value = git_diff_num_deltas(native_diff);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_num_deltas_of_type */
/* sha: c96fa9701c14d76bc8605d01bb2c1ef96de6d1b7c20cfffe4c56832c69192077 */
#if BIND_git_diff_num_deltas_of_type_FUNCTION
#define git_diff_num_deltas_of_type_REQUIRED_ARGC 2
#define git_diff_num_deltas_of_type_OPTIONAL_ARGC 0
/* git_diff_num_deltas_of_type
 *
 * Parameters:
 * - diff: const git_diff *
 * - type: git_delta_t
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_diff_num_deltas_of_type(mrb_state* mrb, mrb_value self) {
  mrb_value diff;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &diff, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  const git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Invocation */
  size_t native_return_value = git_diff_num_deltas_of_type(native_diff, native_type);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_print */
/* sha: 46e3e55d78dda00def56d359e83d8dca828b22823852b94adec564c2f9c68f24 */
#if BIND_git_diff_print_FUNCTION
#define git_diff_print_REQUIRED_ARGC 4
#define git_diff_print_OPTIONAL_ARGC 0
/* git_diff_print
 *
 * Parameters:
 * - diff: git_diff *
 * - format: git_diff_format_t
 * - print_cb: git_diff_line_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_print(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value diff;
  mrb_int native_format;
  mrb_value print_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &diff, &native_format, &print_cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_diff_line_cb(print_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Unbox param: print_cb */
  git_diff_line_cb native_print_cb = TODO_mruby_unbox_git_diff_line_cb(print_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_diff_print(native_diff, native_format, native_print_cb, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_stats_deletions */
/* sha: 42017efb31f26c77a09c7ddb857975ceccf22ee2f53db875f55ae0313b44c8da */
#if BIND_git_diff_stats_deletions_FUNCTION
#define git_diff_stats_deletions_REQUIRED_ARGC 1
#define git_diff_stats_deletions_OPTIONAL_ARGC 0
/* git_diff_stats_deletions
 *
 * Parameters:
 * - stats: const git_diff_stats *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_diff_stats_deletions(mrb_state* mrb, mrb_value self) {
  mrb_value stats;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &stats);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, stats, DiffStats_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffStats expected");
    return mrb_nil_value();
  }

  /* Unbox param: stats */
  const git_diff_stats * native_stats = (mrb_nil_p(stats) ? NULL : mruby_unbox_git_diff_stats(stats));

  /* Invocation */
  size_t native_return_value = git_diff_stats_deletions(native_stats);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_stats_files_changed */
/* sha: 7865699faa2836a35302f73089f5511cc5d22e103714a01a5dc5666ce9016c09 */
#if BIND_git_diff_stats_files_changed_FUNCTION
#define git_diff_stats_files_changed_REQUIRED_ARGC 1
#define git_diff_stats_files_changed_OPTIONAL_ARGC 0
/* git_diff_stats_files_changed
 *
 * Parameters:
 * - stats: const git_diff_stats *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_diff_stats_files_changed(mrb_state* mrb, mrb_value self) {
  mrb_value stats;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &stats);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, stats, DiffStats_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffStats expected");
    return mrb_nil_value();
  }

  /* Unbox param: stats */
  const git_diff_stats * native_stats = (mrb_nil_p(stats) ? NULL : mruby_unbox_git_diff_stats(stats));

  /* Invocation */
  size_t native_return_value = git_diff_stats_files_changed(native_stats);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_stats_free */
/* sha: 6390bba07f449701ebacdf6f9a4cd204cb0c7b2a72cddf77d39426b39bc8f3bc */
#if BIND_git_diff_stats_free_FUNCTION
#define git_diff_stats_free_REQUIRED_ARGC 1
#define git_diff_stats_free_OPTIONAL_ARGC 0
/* git_diff_stats_free
 *
 * Parameters:
 * - stats: git_diff_stats *
 * Return Type: void
 */
mrb_value
mrb_Git_git_diff_stats_free(mrb_state* mrb, mrb_value self) {
  mrb_value stats;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &stats);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, stats, DiffStats_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffStats expected");
    return mrb_nil_value();
  }

  /* Unbox param: stats */
  git_diff_stats * native_stats = (mrb_nil_p(stats) ? NULL : mruby_unbox_git_diff_stats(stats));

  /* Invocation */
  git_diff_stats_free(native_stats);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_stats_insertions */
/* sha: 0ccdefb5bd24b438163dedc04f62939d573d5ffc8e7dda8a7ce78292b6329409 */
#if BIND_git_diff_stats_insertions_FUNCTION
#define git_diff_stats_insertions_REQUIRED_ARGC 1
#define git_diff_stats_insertions_OPTIONAL_ARGC 0
/* git_diff_stats_insertions
 *
 * Parameters:
 * - stats: const git_diff_stats *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_diff_stats_insertions(mrb_state* mrb, mrb_value self) {
  mrb_value stats;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &stats);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, stats, DiffStats_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffStats expected");
    return mrb_nil_value();
  }

  /* Unbox param: stats */
  const git_diff_stats * native_stats = (mrb_nil_p(stats) ? NULL : mruby_unbox_git_diff_stats(stats));

  /* Invocation */
  size_t native_return_value = git_diff_stats_insertions(native_stats);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_stats_to_buf */
/* sha: e15862d455f011a3b08967fd8cb7baff873784004f0e01fc04670a9581e6244f */
#if BIND_git_diff_stats_to_buf_FUNCTION
#define git_diff_stats_to_buf_REQUIRED_ARGC 3
#define git_diff_stats_to_buf_OPTIONAL_ARGC 0
/* git_diff_stats_to_buf
 *
 * Parameters:
 * - stats: const git_diff_stats *
 * - format: git_diff_stats_format_t
 * - width: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_stats_to_buf(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value stats;
  mrb_int native_format;
  mrb_int native_width;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &stats, &native_format, &native_width);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, stats, DiffStats_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffStats expected");
    return mrb_nil_value();
  }

  /* Unbox param: stats */
  const git_diff_stats * native_stats = (mrb_nil_p(stats) ? NULL : mruby_unbox_git_diff_stats(stats));

  /* Invocation */
  int native_return_value = git_diff_stats_to_buf(native_out, native_stats, native_format, native_width);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_status_char */
/* sha: 978e6fe5505548057a593db4b367cf58c06055874f7fc6358698eeceab1e4c84 */
#if BIND_git_diff_status_char_FUNCTION
#define git_diff_status_char_REQUIRED_ARGC 1
#define git_diff_status_char_OPTIONAL_ARGC 0
/* git_diff_status_char
 *
 * Parameters:
 * - status: git_delta_t
 * Return Type: char
 */
mrb_value
mrb_Git_git_diff_status_char(mrb_state* mrb, mrb_value self) {
  mrb_int native_status;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_status);

  /* Invocation */
  char native_return_value = git_diff_status_char(native_status);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_tree_to_index */
/* sha: 752d02e1fa737ca2fc39a4831ea9d3095f5b5da30128c57ab4acb68beb3353eb */
#if BIND_git_diff_tree_to_index_FUNCTION
#define git_diff_tree_to_index_REQUIRED_ARGC 4
#define git_diff_tree_to_index_OPTIONAL_ARGC 0
/* git_diff_tree_to_index
 *
 * Parameters:
 * - repo: git_repository *
 * - old_tree: git_tree *
 * - index: git_index *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_tree_to_index(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_diff * native_diff = NULL;
  mrb_value repo;
  mrb_value old_tree;
  mrb_value index;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &repo, &old_tree, &index, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, old_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: old_tree */
  git_tree * native_old_tree = (mrb_nil_p(old_tree) ? NULL : mruby_unbox_git_tree(old_tree));

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_diff_tree_to_index(&native_diff, native_repo, native_old_tree, native_index, native_opts);

  /* Box out param: diff */
  mrb_value diff = native_diff == NULL ? mrb_nil_value() : mruby_giftwrap_git_diff(mrb, native_diff);

  RAISE_GIT_ERROR(native_return_value);

  return diff;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_tree_to_tree */
/* sha: ce05ac29efc8dc9f7561e753c2686cfaa334f2e9fb4f7c83d880927fb2c4b0dc */
#if BIND_git_diff_tree_to_tree_FUNCTION
#define git_diff_tree_to_tree_REQUIRED_ARGC 4
#define git_diff_tree_to_tree_OPTIONAL_ARGC 0
/* git_diff_tree_to_tree
 *
 * Parameters:
 * - repo: git_repository *
 * - old_tree: git_tree *
 * - new_tree: git_tree *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_tree_to_tree(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_diff * native_diff = NULL;
  mrb_value repo;
  mrb_value old_tree;
  mrb_value new_tree;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &repo, &old_tree, &new_tree, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, old_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, new_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: old_tree */
  git_tree * native_old_tree = (mrb_nil_p(old_tree) ? NULL : mruby_unbox_git_tree(old_tree));

  /* Unbox param: new_tree */
  git_tree * native_new_tree = (mrb_nil_p(new_tree) ? NULL : mruby_unbox_git_tree(new_tree));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_diff_tree_to_tree(&native_diff, native_repo, native_old_tree, native_new_tree, native_opts);

  /* Box out param: diff */
  mrb_value diff = native_diff == NULL ? mrb_nil_value() : mruby_giftwrap_git_diff(mrb, native_diff);

  RAISE_GIT_ERROR(native_return_value);

  return diff;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_tree_to_workdir */
/* sha: 7f80955c743808fd20345b6a689a3b9cceae1defa8b137fb51bed8fbb01cb900 */
#if BIND_git_diff_tree_to_workdir_FUNCTION
#define git_diff_tree_to_workdir_REQUIRED_ARGC 3
#define git_diff_tree_to_workdir_OPTIONAL_ARGC 0
/* git_diff_tree_to_workdir
 *
 * Parameters:
 * - repo: git_repository *
 * - old_tree: git_tree *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_tree_to_workdir(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_diff * native_diff = NULL;
  mrb_value repo;
  mrb_value old_tree;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &old_tree, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, old_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: old_tree */
  git_tree * native_old_tree = (mrb_nil_p(old_tree) ? NULL : mruby_unbox_git_tree(old_tree));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_diff_tree_to_workdir(&native_diff, native_repo, native_old_tree, native_opts);

  /* Box out param: diff */
  mrb_value diff = native_diff == NULL ? mrb_nil_value() : mruby_giftwrap_git_diff(mrb, native_diff);

  RAISE_GIT_ERROR(native_return_value);

  return diff;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_diff_tree_to_workdir_with_index */
/* sha: c53b91a579ba286ac2c5a87c525ea6b3f549800082aaf9309409ed3b885f1c1d */
#if BIND_git_diff_tree_to_workdir_with_index_FUNCTION
#define git_diff_tree_to_workdir_with_index_REQUIRED_ARGC 3
#define git_diff_tree_to_workdir_with_index_OPTIONAL_ARGC 0
/* git_diff_tree_to_workdir_with_index
 *
 * Parameters:
 * - repo: git_repository *
 * - old_tree: git_tree *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_diff_tree_to_workdir_with_index(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_diff * native_diff = NULL;
  mrb_value repo;
  mrb_value old_tree;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &old_tree, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, old_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: old_tree */
  git_tree * native_old_tree = (mrb_nil_p(old_tree) ? NULL : mruby_unbox_git_tree(old_tree));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_diff_tree_to_workdir_with_index(&native_diff, native_repo, native_old_tree, native_opts);

  /* Box out param: diff */
  mrb_value diff = native_diff == NULL ? mrb_nil_value() : mruby_giftwrap_git_diff(mrb, native_diff);

  RAISE_GIT_ERROR(native_return_value);

  return diff;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_fetch_init_options */
/* sha: d61b30970dbb616c6224d2a62be60c7cb0875d98f73f67f40e5890f4075ae606 */
#if BIND_git_fetch_init_options_FUNCTION
#define git_fetch_init_options_REQUIRED_ARGC 2
#define git_fetch_init_options_OPTIONAL_ARGC 0
/* git_fetch_init_options
 *
 * Parameters:
 * - opts: git_fetch_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_fetch_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, FetchOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FetchOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_fetch_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_fetch_options(opts));

  /* Invocation */
  int native_return_value = git_fetch_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_apply_to_blob */
/* sha: a061e6cac7d37202318df089597769511afb37820f2810121d63b84a759f7a6b */
#if BIND_git_filter_list_apply_to_blob_FUNCTION
#define git_filter_list_apply_to_blob_REQUIRED_ARGC 2
#define git_filter_list_apply_to_blob_OPTIONAL_ARGC 0
/* git_filter_list_apply_to_blob
 *
 * Parameters:
 * - filters: git_filter_list *
 * - blob: git_blob *
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_apply_to_blob(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value filters;
  mrb_value blob;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &filters, &blob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Unbox param: blob */
  git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  int native_return_value = git_filter_list_apply_to_blob(native_out, native_filters, native_blob);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_apply_to_data */
/* sha: 06f5e84bb3abcf83dc43940f1cb9393d13503539d4cb73fa893dbd88fe0b46f5 */
#if BIND_git_filter_list_apply_to_data_FUNCTION
#define git_filter_list_apply_to_data_REQUIRED_ARGC 2
#define git_filter_list_apply_to_data_OPTIONAL_ARGC 0
/* git_filter_list_apply_to_data
 *
 * Parameters:
 * - filters: git_filter_list *
 * - in: git_buf *
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_apply_to_data(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value filters;
  mrb_value in;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &filters, &in);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, in, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Unbox param: in */
  git_buf * native_in = mrb_nil_p(in) ? NULL : mruby_unbox_git_buf(in);

  /* Invocation */
  int native_return_value = git_filter_list_apply_to_data(native_out, native_filters, native_in);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_apply_to_file */
/* sha: 2972e2d829d8a65b81b28a52cff4d6a472204ab2005a531a3bfc0a53fad626b1 */
#if BIND_git_filter_list_apply_to_file_FUNCTION
#define git_filter_list_apply_to_file_REQUIRED_ARGC 3
#define git_filter_list_apply_to_file_OPTIONAL_ARGC 0
/* git_filter_list_apply_to_file
 *
 * Parameters:
 * - filters: git_filter_list *
 * - repo: git_repository *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_apply_to_file(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value filters;
  mrb_value repo;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &filters, &repo, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_filter_list_apply_to_file(native_out, native_filters, native_repo, native_path);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_contains */
/* sha: e898f98a0c0af9a6507bc2170647649aa402ceaf67335431bf2d7a1d13b969c4 */
#if BIND_git_filter_list_contains_FUNCTION
#define git_filter_list_contains_REQUIRED_ARGC 2
#define git_filter_list_contains_OPTIONAL_ARGC 0
/* git_filter_list_contains
 *
 * Parameters:
 * - filters: git_filter_list *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_contains(mrb_state* mrb, mrb_value self) {
  mrb_value filters;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &filters, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Invocation */
  int native_return_value = git_filter_list_contains(native_filters, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_free */
/* sha: a0adc786d30126a9c5a887f00d0de7418320066a1ba3cb81890cf157f73c4071 */
#if BIND_git_filter_list_free_FUNCTION
#define git_filter_list_free_REQUIRED_ARGC 1
#define git_filter_list_free_OPTIONAL_ARGC 0
/* git_filter_list_free
 *
 * Parameters:
 * - filters: git_filter_list *
 * Return Type: void
 */
mrb_value
mrb_Git_git_filter_list_free(mrb_state* mrb, mrb_value self) {
  mrb_value filters;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &filters);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Invocation */
  git_filter_list_free(native_filters);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_load */
/* sha: ff5c0e2af4eaf9190f5049e07b1a0c7dcba16e1b9796d0520a456938fb8bf189 */
#if BIND_git_filter_list_load_FUNCTION
#define git_filter_list_load_REQUIRED_ARGC 5
#define git_filter_list_load_OPTIONAL_ARGC 0
/* git_filter_list_load
 *
 * Parameters:
 * - repo: git_repository *
 * - blob: git_blob *
 * - path: const char *
 * - mode: git_filter_mode_t
 * - flags: uint32_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_load(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_filter_list * native_filters = NULL;
  mrb_value repo;
  mrb_value blob;
  char * native_path = NULL;
  mrb_int native_mode;
  mrb_int native_flags;

  /* Fetch the args */
  mrb_get_args(mrb, "oozii", &repo, &blob, &native_path, &native_mode, &native_flags);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: blob */
  git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Invocation */
  int native_return_value = git_filter_list_load(&native_filters, native_repo, native_blob, native_path, native_mode, native_flags);

  /* Box out param: filters */
  mrb_value filters = native_filters == NULL ? mrb_nil_value() : mruby_giftwrap_git_filter_list(mrb, native_filters);

  RAISE_GIT_ERROR(native_return_value);

  return filters;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_stream_blob */
/* sha: ab572c30ae36ac0cafa8bcaf1ca4484d909840a9a2f2c3f277d3cf0c26a8dca4 */
#if BIND_git_filter_list_stream_blob_FUNCTION
#define git_filter_list_stream_blob_REQUIRED_ARGC 3
#define git_filter_list_stream_blob_OPTIONAL_ARGC 0
/* git_filter_list_stream_blob
 *
 * Parameters:
 * - filters: git_filter_list *
 * - blob: git_blob *
 * - target: git_writestream *
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_stream_blob(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value filters;
  mrb_value blob;
  mrb_value target;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &filters, &blob, &target);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Writestream_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Writestream expected");
    return mrb_nil_value();
  }

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Unbox param: blob */
  git_blob * native_blob = (mrb_nil_p(blob) ? NULL : mruby_unbox_git_blob(blob));

  /* Unbox param: target */
  git_writestream * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_writestream(target));

  /* Invocation */
  int native_return_value = git_filter_list_stream_blob(native_filters, native_blob, native_target);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_stream_data */
/* sha: 853dcf31c1d95c646c1a4840f5e50a91b524f0de7964f0b9b31240de996306e6 */
#if BIND_git_filter_list_stream_data_FUNCTION
#define git_filter_list_stream_data_REQUIRED_ARGC 3
#define git_filter_list_stream_data_OPTIONAL_ARGC 0
/* git_filter_list_stream_data
 *
 * Parameters:
 * - filters: git_filter_list *
 * - data: git_buf *
 * - target: git_writestream *
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_stream_data(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value filters;
  mrb_value data;
  mrb_value target;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &filters, &data, &target);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, data, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Writestream_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Writestream expected");
    return mrb_nil_value();
  }

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Unbox param: data */
  git_buf * native_data = mrb_nil_p(data) ? NULL : mruby_unbox_git_buf(data);

  /* Unbox param: target */
  git_writestream * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_writestream(target));

  /* Invocation */
  int native_return_value = git_filter_list_stream_data(native_filters, native_data, native_target);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_filter_list_stream_file */
/* sha: e6506b19e9e23941a2c50e1192efe988acfc2ff6562ab5bf1e9392a0cfcd522e */
#if BIND_git_filter_list_stream_file_FUNCTION
#define git_filter_list_stream_file_REQUIRED_ARGC 4
#define git_filter_list_stream_file_OPTIONAL_ARGC 0
/* git_filter_list_stream_file
 *
 * Parameters:
 * - filters: git_filter_list *
 * - repo: git_repository *
 * - path: const char *
 * - target: git_writestream *
 * Return Type: int
 */
mrb_value
mrb_Git_git_filter_list_stream_file(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value filters;
  mrb_value repo;
  char * native_path = NULL;
  mrb_value target;

  /* Fetch the args */
  mrb_get_args(mrb, "oozo", &filters, &repo, &native_path, &target);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, filters, FilterList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FilterList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Writestream_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Writestream expected");
    return mrb_nil_value();
  }

  /* Unbox param: filters */
  git_filter_list * native_filters = (mrb_nil_p(filters) ? NULL : mruby_unbox_git_filter_list(filters));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: target */
  git_writestream * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_writestream(target));

  /* Invocation */
  int native_return_value = git_filter_list_stream_file(native_filters, native_repo, native_path, native_target);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_graph_ahead_behind */
/* sha: 74b02a31d0f698dbad9c71d4159ebe3a88f431721647cd43a5df1c810917c0d4 */
#if BIND_git_graph_ahead_behind_FUNCTION
#define git_graph_ahead_behind_REQUIRED_ARGC 3
#define git_graph_ahead_behind_OPTIONAL_ARGC 0
/* git_graph_ahead_behind
 *
 * Parameters:
 * - repo: git_repository *
 * - local: const git_oid *
 * - upstream: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_graph_ahead_behind(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value results = mrb_ary_new(mrb);
  int native_ahead;
  int native_behind;
  mrb_value repo;
  mrb_value local;
  mrb_value upstream;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &local, &upstream);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, local, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, upstream, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: local */
  const git_oid * native_local = (mrb_nil_p(local) ? NULL : mruby_unbox_git_oid(local));

  /* Unbox param: upstream */
  const git_oid * native_upstream = (mrb_nil_p(upstream) ? NULL : mruby_unbox_git_oid(upstream));

  /* Invocation */
  int native_return_value = git_graph_ahead_behind(&native_ahead, &native_behind, native_repo, native_local, native_upstream);

  /* Box out param: ahead */
  mrb_value ahead = mrb_fixnum_value(native_ahead);
  /* Box out param: behind */
  mrb_value behind = mrb_fixnum_value(native_behind);

  /* Add out params to results */
  mrb_ary_push(mrb, results, ahead);
  mrb_ary_push(mrb, results, behind);

  RAISE_GIT_ERROR(native_return_value);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_graph_descendant_of */
/* sha: ebeaaaee82411aba0c167212bb54220cebbf7516462342e036eff8ba25c62b77 */
#if BIND_git_graph_descendant_of_FUNCTION
#define git_graph_descendant_of_REQUIRED_ARGC 3
#define git_graph_descendant_of_OPTIONAL_ARGC 0
/* git_graph_descendant_of
 *
 * Parameters:
 * - repo: git_repository *
 * - commit: const git_oid *
 * - ancestor: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_graph_descendant_of(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value commit;
  mrb_value ancestor;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &commit, &ancestor);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ancestor, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: commit */
  const git_oid * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_oid(commit));

  /* Unbox param: ancestor */
  const git_oid * native_ancestor = (mrb_nil_p(ancestor) ? NULL : mruby_unbox_git_oid(ancestor));

  /* Invocation */
  int native_return_value = git_graph_descendant_of(native_repo, native_commit, native_ancestor);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_ignore_add_rule */
/* sha: 0bcd8ecddfd0bc1d7c3bdd3eb510e98481dc10f8d4dd40cf630886fd50788b1d */
#if BIND_git_ignore_add_rule_FUNCTION
#define git_ignore_add_rule_REQUIRED_ARGC 2
#define git_ignore_add_rule_OPTIONAL_ARGC 0
/* git_ignore_add_rule
 *
 * Parameters:
 * - repo: git_repository *
 * - rules: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_ignore_add_rule(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_rules = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_rules);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_ignore_add_rule(native_repo, native_rules);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_ignore_clear_internal_rules */
/* sha: bfd957572d379cffbdc9926c97c25332899dfadce37e8ab7b7c6f138a509cedd */
#if BIND_git_ignore_clear_internal_rules_FUNCTION
#define git_ignore_clear_internal_rules_REQUIRED_ARGC 1
#define git_ignore_clear_internal_rules_OPTIONAL_ARGC 0
/* git_ignore_clear_internal_rules
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_ignore_clear_internal_rules(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_ignore_clear_internal_rules(native_repo);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_ignore_path_is_ignored */
/* sha: e223f8012391602003bf7f18e3132205480486777a73ca4a49bc9398d423261a */
#if BIND_git_ignore_path_is_ignored_FUNCTION
#define git_ignore_path_is_ignored_REQUIRED_ARGC 2
#define git_ignore_path_is_ignored_OPTIONAL_ARGC 0
/* git_ignore_path_is_ignored
 *
 * Parameters:
 * - repo: git_repository *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_ignore_path_is_ignored(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  int native_ignored;
  mrb_value repo;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_ignore_path_is_ignored(&native_ignored, native_repo, native_path);

  /* Box out param: ignored */
  mrb_value ignored = native_ignored == 0 ? mrb_false_value() : mrb_true_value();

  RAISE_GIT_ERROR(native_return_value);

  return ignored;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_add */
/* sha: 252bbd22b2f625a04025092ca58491871671c2aa008fc1bb80ca9cf692875143 */
#if BIND_git_index_add_FUNCTION
#define git_index_add_REQUIRED_ARGC 2
#define git_index_add_OPTIONAL_ARGC 0
/* git_index_add
 *
 * Parameters:
 * - index: git_index *
 * - source_entry: const git_index_entry *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_add(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;
  mrb_value source_entry;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &index, &source_entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, source_entry, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: source_entry */
  const git_index_entry * native_source_entry = (mrb_nil_p(source_entry) ? NULL : mruby_unbox_git_index_entry(source_entry));

  /* Invocation */
  int native_return_value = git_index_add(native_index, native_source_entry);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_add_all */
/* sha: c67fab7eef3b6a0aa707af1525d1a3e278a70f9eb8b9a20f8b633ce5d0abac6e */
#if BIND_git_index_add_all_FUNCTION
#define git_index_add_all_REQUIRED_ARGC 5
#define git_index_add_all_OPTIONAL_ARGC 0
/* git_index_add_all
 *
 * Parameters:
 * - index: git_index *
 * - pathspec: const git_strarray *
 * - flags: unsigned int
 * - callback: git_index_matched_path_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_add_all(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;
  mrb_value pathspec;
  mrb_int native_flags;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooioo", &index, &pathspec, &native_flags, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, pathspec, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: pathspec */
  const git_strarray * native_pathspec = (mrb_nil_p(pathspec) ? NULL : mruby_unbox_git_strarray(pathspec));

  /* Unbox param: callback */
  int (*native_callback)(const char *, const char *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_index_add_all(native_index, native_pathspec, native_flags, native_callback, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_add_bypath */
/* sha: 7f30ced008e6ada286f6d27f6d21fea7e975718a0ba49465e3eb26c11e5b6a32 */
#if BIND_git_index_add_bypath_FUNCTION
#define git_index_add_bypath_REQUIRED_ARGC 2
#define git_index_add_bypath_OPTIONAL_ARGC 0
/* git_index_add_bypath
 *
 * Parameters:
 * - index: git_index *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_add_bypath(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &index, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_add_bypath(native_index, native_path);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_add_frombuffer */
/* sha: 40668f5d00e4e0bc113e301c667e974f82afb1f81286ce7827b48aa3a179abe2 */
#if BIND_git_index_add_frombuffer_FUNCTION
#define git_index_add_frombuffer_REQUIRED_ARGC 4
#define git_index_add_frombuffer_OPTIONAL_ARGC 0
/* git_index_add_frombuffer
 *
 * Parameters:
 * - index: git_index *
 * - entry: const git_index_entry *
 * - buffer: const void *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_add_frombuffer(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;
  mrb_value entry;
  mrb_value buffer;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oooi", &index, &entry, &buffer, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, entry, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(buffer);

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: entry */
  const git_index_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_index_entry(entry));

  /* Unbox param: buffer */
  const void * native_buffer = TODO_mruby_unbox_void_PTR(buffer);

  /* Invocation */
  int native_return_value = git_index_add_frombuffer(native_index, native_entry, native_buffer, native_len);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_caps */
/* sha: ce3ef212e6e5dde299d070354f6e549b1b81e19fdb33d13a53bae9fbf95a0b4a */
#if BIND_git_index_caps_FUNCTION
#define git_index_caps_REQUIRED_ARGC 1
#define git_index_caps_OPTIONAL_ARGC 0
/* git_index_caps
 *
 * Parameters:
 * - index: const git_index *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_caps(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  const git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_caps(native_index);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_checksum */
/* sha: 355ede8d7103249710bf77ce90a6fd20d3aba270cae62bfddf86b1befecda868 */
#if BIND_git_index_checksum_FUNCTION
#define git_index_checksum_REQUIRED_ARGC 1
#define git_index_checksum_OPTIONAL_ARGC 0
/* git_index_checksum
 *
 * Parameters:
 * - index: git_index *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_index_checksum(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  const git_oid * native_return_value = git_index_checksum(native_index);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_clear */
/* sha: 624fd6118a7c665edc03fb30a3c425ac11f0f2b45ac3c14b45b2e5a0ae45d5f1 */
#if BIND_git_index_clear_FUNCTION
#define git_index_clear_REQUIRED_ARGC 1
#define git_index_clear_OPTIONAL_ARGC 0
/* git_index_clear
 *
 * Parameters:
 * - index: git_index *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_clear(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_clear(native_index);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_conflict_add */
/* sha: 8f01efa4d581af2144ae49e400782096d4fa1cc32da8c0f67909e272d63aac42 */
#if BIND_git_index_conflict_add_FUNCTION
#define git_index_conflict_add_REQUIRED_ARGC 4
#define git_index_conflict_add_OPTIONAL_ARGC 0
/* git_index_conflict_add
 *
 * Parameters:
 * - index: git_index *
 * - ancestor_entry: const git_index_entry *
 * - our_entry: const git_index_entry *
 * - their_entry: const git_index_entry *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_conflict_add(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;
  mrb_value ancestor_entry;
  mrb_value our_entry;
  mrb_value their_entry;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &index, &ancestor_entry, &our_entry, &their_entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ancestor_entry, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, our_entry, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, their_entry, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: ancestor_entry */
  const git_index_entry * native_ancestor_entry = (mrb_nil_p(ancestor_entry) ? NULL : mruby_unbox_git_index_entry(ancestor_entry));

  /* Unbox param: our_entry */
  const git_index_entry * native_our_entry = (mrb_nil_p(our_entry) ? NULL : mruby_unbox_git_index_entry(our_entry));

  /* Unbox param: their_entry */
  const git_index_entry * native_their_entry = (mrb_nil_p(their_entry) ? NULL : mruby_unbox_git_index_entry(their_entry));

  /* Invocation */
  int native_return_value = git_index_conflict_add(native_index, native_ancestor_entry, native_our_entry, native_their_entry);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_conflict_cleanup */
/* sha: 927f32891df4557c91e6944715658e56574a7e9e0799c7e0567b63d7ba861afb */
#if BIND_git_index_conflict_cleanup_FUNCTION
#define git_index_conflict_cleanup_REQUIRED_ARGC 1
#define git_index_conflict_cleanup_OPTIONAL_ARGC 0
/* git_index_conflict_cleanup
 *
 * Parameters:
 * - index: git_index *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_conflict_cleanup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_conflict_cleanup(native_index);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_conflict_get */
/* sha: b7239a4c153e5d57cbea37ea02fd69ecce4b85dbd0031670bb2cac0fbb2b9ffb */
#if BIND_git_index_conflict_get_FUNCTION
#define git_index_conflict_get_REQUIRED_ARGC 2
#define git_index_conflict_get_OPTIONAL_ARGC 0
/* git_index_conflict_get
 *
 * Parameters:
 * - index: git_index *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_conflict_get(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value results = mrb_ary_new(mrb);
  git_index_entry * native_ancestor_out = NULL;
  git_index_entry * native_our_out = NULL;
  git_index_entry * native_their_out = NULL;
  mrb_value index;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &index, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_conflict_get(&native_ancestor_out, &native_our_out, &native_their_out, native_index, native_path);

  /* Box out param: ancestor_out */
  mrb_value ancestor_out = mruby_box_git_index_entry(mrb, native_ancestor_out);
  /* Box out param: our_out */
  mrb_value our_out = mruby_box_git_index_entry(mrb, native_our_out);
  /* Box out param: their_out */
  mrb_value their_out = mruby_box_git_index_entry(mrb, native_their_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, ancestor_out);
  mrb_ary_push(mrb, results, our_out);
  mrb_ary_push(mrb, results, their_out);

  RAISE_GIT_ERROR(native_return_value);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_conflict_iterator_free */
/* sha: bd37efaba553213fd9b7d8fb3fa7901f241998a968fba0c7827a925c9fcaa1a0 */
#if BIND_git_index_conflict_iterator_free_FUNCTION
#define git_index_conflict_iterator_free_REQUIRED_ARGC 1
#define git_index_conflict_iterator_free_OPTIONAL_ARGC 0
/* git_index_conflict_iterator_free
 *
 * Parameters:
 * - iterator: git_index_conflict_iterator *
 * Return Type: void
 */
mrb_value
mrb_Git_git_index_conflict_iterator_free(mrb_state* mrb, mrb_value self) {
  mrb_value iterator;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iterator);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iterator, IndexConflictIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexConflictIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iterator */
  git_index_conflict_iterator * native_iterator = (mrb_nil_p(iterator) ? NULL : mruby_unbox_git_index_conflict_iterator(iterator));

  /* Invocation */
  git_index_conflict_iterator_free(native_iterator);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_conflict_iterator_new */
/* sha: 98a456885ba3da58355eb5903f47b424c57ac77bdf990af97901aa785654cec6 */
#if BIND_git_index_conflict_iterator_new_FUNCTION
#define git_index_conflict_iterator_new_REQUIRED_ARGC 1
#define git_index_conflict_iterator_new_OPTIONAL_ARGC 0
/* git_index_conflict_iterator_new
 *
 * Parameters:
 * - index: git_index *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_conflict_iterator_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_index_conflict_iterator * native_iterator_out = NULL;
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_conflict_iterator_new(&native_iterator_out, native_index);

  /* Box out param: iterator_out */
  mrb_value iterator_out = native_iterator_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index_conflict_iterator(mrb, native_iterator_out);

  RAISE_GIT_ERROR(native_return_value);

  return iterator_out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_conflict_next */
/* sha: e485d5a8f4874f4753abc07f0d74bb8aed38db1e7b43f166a8321c11bb467917 */
#if BIND_git_index_conflict_next_FUNCTION
#define git_index_conflict_next_REQUIRED_ARGC 1
#define git_index_conflict_next_OPTIONAL_ARGC 0
/* git_index_conflict_next
 *
 * Parameters:
 * - iterator: git_index_conflict_iterator *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_conflict_next(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_index_entry * native_ancestor_out = NULL;
  git_index_entry * native_our_out = NULL;
  git_index_entry * native_their_out = NULL;
  mrb_value iterator;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iterator);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iterator, IndexConflictIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexConflictIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iterator */
  git_index_conflict_iterator * native_iterator = (mrb_nil_p(iterator) ? NULL : mruby_unbox_git_index_conflict_iterator(iterator));

  /* Invocation */
  int native_return_value = git_index_conflict_next(&native_ancestor_out, &native_our_out, &native_their_out, native_iterator);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: ancestor_out */
  mrb_value ancestor_out = mruby_box_git_index_entry(mrb, native_ancestor_out);
  /* Box out param: our_out */
  mrb_value our_out = mruby_box_git_index_entry(mrb, native_our_out);
  /* Box out param: their_out */
  mrb_value their_out = mruby_box_git_index_entry(mrb, native_their_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, ancestor_out);
  mrb_ary_push(mrb, results, our_out);
  mrb_ary_push(mrb, results, their_out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_conflict_remove */
/* sha: 21d5ed553d2369708c99ed4271061844d15e2bc53d9f40aa877bf09b51ce0a07 */
#if BIND_git_index_conflict_remove_FUNCTION
#define git_index_conflict_remove_REQUIRED_ARGC 2
#define git_index_conflict_remove_OPTIONAL_ARGC 0
/* git_index_conflict_remove
 *
 * Parameters:
 * - index: git_index *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_conflict_remove(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &index, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_conflict_remove(native_index, native_path);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_entry_is_conflict */
/* sha: bbc2c57bbb3372fe04564e079e24414de673550fff345c3a07f6ece40c366819 */
#if BIND_git_index_entry_is_conflict_FUNCTION
#define git_index_entry_is_conflict_REQUIRED_ARGC 1
#define git_index_entry_is_conflict_OPTIONAL_ARGC 0
/* git_index_entry_is_conflict
 *
 * Parameters:
 * - entry: const git_index_entry *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_entry_is_conflict(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_index_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_index_entry(entry));

  /* Invocation */
  int native_return_value = git_index_entry_is_conflict(native_entry);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_entry_stage */
/* sha: 51fc2508afae3484aa504b7f9d54c978008b88956395cc1c2f925b2297412bdb */
#if BIND_git_index_entry_stage_FUNCTION
#define git_index_entry_stage_REQUIRED_ARGC 1
#define git_index_entry_stage_OPTIONAL_ARGC 0
/* git_index_entry_stage
 *
 * Parameters:
 * - entry: const git_index_entry *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_entry_stage(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_index_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_index_entry(entry));

  /* Invocation */
  int native_return_value = git_index_entry_stage(native_entry);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_entrycount */
/* sha: 77829fa183ee2edcce60da8f0e297776d83f428ff5b16a0b701adbbcd6e2d349 */
#if BIND_git_index_entrycount_FUNCTION
#define git_index_entrycount_REQUIRED_ARGC 1
#define git_index_entrycount_OPTIONAL_ARGC 0
/* git_index_entrycount
 *
 * Parameters:
 * - index: const git_index *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_index_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  const git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  size_t native_return_value = git_index_entrycount(native_index);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_find */
/* sha: f1e9594599c5f2d6dd6c1507cd3a559e30c28cc15c8233d221a1587927f27a2f */
#if BIND_git_index_find_FUNCTION
#define git_index_find_REQUIRED_ARGC 2
#define git_index_find_OPTIONAL_ARGC 0
/* git_index_find
 *
 * Parameters:
 * - index: git_index *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_find(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_at_pos;
  mrb_value index;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &index, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_find(&native_at_pos, native_index, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: at_pos */
  mrb_value at_pos = mrb_fixnum_value(native_at_pos);

  /* Add out params to results */
  mrb_ary_push(mrb, results, at_pos);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_find_prefix */
/* sha: 345b6826164e46d2445d92b52818aef6b215e2a160df4cd334af87ebc9c0bd98 */
#if BIND_git_index_find_prefix_FUNCTION
#define git_index_find_prefix_REQUIRED_ARGC 2
#define git_index_find_prefix_OPTIONAL_ARGC 0
/* git_index_find_prefix
 *
 * Parameters:
 * - index: git_index *
 * - prefix: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_find_prefix(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  int native_at_pos;
  mrb_value index;
  char * native_prefix = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &index, &native_prefix);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_find_prefix(&native_at_pos, native_index, native_prefix);

  /* Box out param: at_pos */
  mrb_value at_pos = mrb_fixnum_value(native_at_pos);

  RAISE_GIT_ERROR(native_return_value);

  return at_pos;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_free */
/* sha: 31cebb3d311bef4107f73ffe5836e7078aeb5b820d3f538cd3e2f4d752c3516e */
#if BIND_git_index_free_FUNCTION
#define git_index_free_REQUIRED_ARGC 1
#define git_index_free_OPTIONAL_ARGC 0
/* git_index_free
 *
 * Parameters:
 * - index: git_index *
 * Return Type: void
 */
mrb_value
mrb_Git_git_index_free(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  git_index_free(native_index);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_get_byindex */
/* sha: d5baec111cd0ee8f2b698c969ec075747c38274110b35d6d285076e102679bc4 */
#if BIND_git_index_get_byindex_FUNCTION
#define git_index_get_byindex_REQUIRED_ARGC 2
#define git_index_get_byindex_OPTIONAL_ARGC 0
/* git_index_get_byindex
 *
 * Parameters:
 * - index: git_index *
 * - n: size_t
 * Return Type: const git_index_entry *
 */
mrb_value
mrb_Git_git_index_get_byindex(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &index, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  const git_index_entry * native_return_value = git_index_get_byindex(native_index, native_n);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_index_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_get_bypath */
/* sha: 475633439a55e1fd01c9e8d3480af513d564f39cf355737560669651e451e45b */
#if BIND_git_index_get_bypath_FUNCTION
#define git_index_get_bypath_REQUIRED_ARGC 3
#define git_index_get_bypath_OPTIONAL_ARGC 0
/* git_index_get_bypath
 *
 * Parameters:
 * - index: git_index *
 * - path: const char *
 * - stage: int
 * Return Type: const git_index_entry *
 */
mrb_value
mrb_Git_git_index_get_bypath(mrb_state* mrb, mrb_value self) {
  mrb_value index;
  char * native_path = NULL;
  mrb_int native_stage;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &index, &native_path, &native_stage);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  const git_index_entry * native_return_value = git_index_get_bypath(native_index, native_path, native_stage);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_index_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_has_conflicts */
/* sha: 181a191235ea22f7acb0106c9074c5efdd07038cdce2cdf106a0e79e15cc1d09 */
#if BIND_git_index_has_conflicts_FUNCTION
#define git_index_has_conflicts_REQUIRED_ARGC 1
#define git_index_has_conflicts_OPTIONAL_ARGC 0
/* git_index_has_conflicts
 *
 * Parameters:
 * - index: const git_index *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_has_conflicts(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  const git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_has_conflicts(native_index);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_new */
/* sha: 30bedea07ca862f326b5f411cf885a600e834492820e72629821dc74f1e81b80 */
#if BIND_git_index_new_FUNCTION
#define git_index_new_REQUIRED_ARGC 0
#define git_index_new_OPTIONAL_ARGC 0
/* git_index_new
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_index * native_out = NULL;


  /* Invocation */
  int native_return_value = git_index_new(&native_out);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_open */
/* sha: 918cb08a10f99c3b931e71a59cfeb431251713cd0f6f10b0c35aefaf9c6ed384 */
#if BIND_git_index_open_FUNCTION
#define git_index_open_REQUIRED_ARGC 1
#define git_index_open_OPTIONAL_ARGC 0
/* git_index_open
 *
 * Parameters:
 * - index_path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_open(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_index * native_out = NULL;
  char * native_index_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_index_path);

  /* Invocation */
  int native_return_value = git_index_open(&native_out, native_index_path);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_owner */
/* sha: e1e82253a6ede8bc4e007f7e31fea73449a4d3f8d29b822f7eb02c86e368aeee */
#if BIND_git_index_owner_FUNCTION
#define git_index_owner_REQUIRED_ARGC 1
#define git_index_owner_OPTIONAL_ARGC 0
/* git_index_owner
 *
 * Parameters:
 * - index: const git_index *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_index_owner(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  const git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  git_repository * native_return_value = git_index_owner(native_index);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_path */
/* sha: bfcad89b749dc1552d379a58033b736908f6c660eb423407c2f5124266c656b5 */
#if BIND_git_index_path_FUNCTION
#define git_index_path_REQUIRED_ARGC 1
#define git_index_path_OPTIONAL_ARGC 0
/* git_index_path
 *
 * Parameters:
 * - index: const git_index *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_index_path(mrb_state* mrb, mrb_value self) {
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  const git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  const char * native_return_value = git_index_path(native_index);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_read */
/* sha: e85bcb950e56720e6807bb3d64dc847adb23e8f371dae433a79e9b37d4ce9bfe */
#if BIND_git_index_read_FUNCTION
#define git_index_read_REQUIRED_ARGC 2
#define git_index_read_OPTIONAL_ARGC 0
/* git_index_read
 *
 * Parameters:
 * - index: git_index *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_read(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;
  mrb_bool native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "ob", &index, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_read(native_index, native_force);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_read_tree */
/* sha: e849c38f73d954508f3fee0baba8d6bd4205598a3be65992b60c9e7b79c01a23 */
#if BIND_git_index_read_tree_FUNCTION
#define git_index_read_tree_REQUIRED_ARGC 2
#define git_index_read_tree_OPTIONAL_ARGC 0
/* git_index_read_tree
 *
 * Parameters:
 * - index: git_index *
 * - tree: const git_tree *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_read_tree(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &index, &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  int native_return_value = git_index_read_tree(native_index, native_tree);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_remove */
/* sha: 913e3d8d9ca0178f0bf18d62473dc79003e070c8410643536d05762c768bb5f0 */
#if BIND_git_index_remove_FUNCTION
#define git_index_remove_REQUIRED_ARGC 3
#define git_index_remove_OPTIONAL_ARGC 0
/* git_index_remove
 *
 * Parameters:
 * - index: git_index *
 * - path: const char *
 * - stage: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_remove(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;
  char * native_path = NULL;
  mrb_int native_stage;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &index, &native_path, &native_stage);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_remove(native_index, native_path, native_stage);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_remove_all */
/* sha: d0a8ecb4b5d2152fc8ff5772decd0f395d43a4c69f18773d054321dfe36cba19 */
#if BIND_git_index_remove_all_FUNCTION
#define git_index_remove_all_REQUIRED_ARGC 4
#define git_index_remove_all_OPTIONAL_ARGC 0
/* git_index_remove_all
 *
 * Parameters:
 * - index: git_index *
 * - pathspec: const git_strarray *
 * - callback: git_index_matched_path_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_remove_all(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;
  mrb_value pathspec;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &index, &pathspec, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, pathspec, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: pathspec */
  const git_strarray * native_pathspec = (mrb_nil_p(pathspec) ? NULL : mruby_unbox_git_strarray(pathspec));

  /* Unbox param: callback */
  int (*native_callback)(const char *, const char *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_index_remove_all(native_index, native_pathspec, native_callback, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_remove_bypath */
/* sha: bbcbd9d8a2677e11f6bc5d15a11a5f8ffa0280bd6a9c5dbe80f104643b18f257 */
#if BIND_git_index_remove_bypath_FUNCTION
#define git_index_remove_bypath_REQUIRED_ARGC 2
#define git_index_remove_bypath_OPTIONAL_ARGC 0
/* git_index_remove_bypath
 *
 * Parameters:
 * - index: git_index *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_remove_bypath(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &index, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_remove_bypath(native_index, native_path);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_remove_directory */
/* sha: 1c15c833d42049e22f683c8ea04d30e34afe105a790ffad2c4317b3c89f8d616 */
#if BIND_git_index_remove_directory_FUNCTION
#define git_index_remove_directory_REQUIRED_ARGC 3
#define git_index_remove_directory_OPTIONAL_ARGC 0
/* git_index_remove_directory
 *
 * Parameters:
 * - index: git_index *
 * - dir: const char *
 * - stage: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_remove_directory(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;
  char * native_dir = NULL;
  mrb_int native_stage;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &index, &native_dir, &native_stage);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_remove_directory(native_index, native_dir, native_stage);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_set_caps */
/* sha: 0a087392ee119237519239bef6e2bc4e7dc78ccb66045578f0ce2260620dfa8c */
#if BIND_git_index_set_caps_FUNCTION
#define git_index_set_caps_REQUIRED_ARGC 2
#define git_index_set_caps_OPTIONAL_ARGC 0
/* git_index_set_caps
 *
 * Parameters:
 * - index: git_index *
 * - caps: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_set_caps(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;
  mrb_int native_caps;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &index, &native_caps);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_set_caps(native_index, native_caps);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_update_all */
/* sha: bdd04485439f4a314c21ff4770f853bc2f6192da65440a9f2312533481c5d2d9 */
#if BIND_git_index_update_all_FUNCTION
#define git_index_update_all_REQUIRED_ARGC 4
#define git_index_update_all_OPTIONAL_ARGC 0
/* git_index_update_all
 *
 * Parameters:
 * - index: git_index *
 * - pathspec: const git_strarray *
 * - callback: git_index_matched_path_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_update_all(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;
  mrb_value pathspec;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &index, &pathspec, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, pathspec, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: pathspec */
  const git_strarray * native_pathspec = (mrb_nil_p(pathspec) ? NULL : mruby_unbox_git_strarray(pathspec));

  /* Unbox param: callback */
  int (*native_callback)(const char *, const char *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_const_char_PTR_COMMA_void_PTR_RPAREN(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_index_update_all(native_index, native_pathspec, native_callback, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_write */
/* sha: 70d0eefa711fe2639441a93d5f11efe0aab4c3e479ff9a84ac752a45e31165c3 */
#if BIND_git_index_write_FUNCTION
#define git_index_write_REQUIRED_ARGC 1
#define git_index_write_OPTIONAL_ARGC 0
/* git_index_write
 *
 * Parameters:
 * - index: git_index *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_write(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_write(native_index);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_write_tree */
/* sha: da894ac3193d4dfb1bc68268b327d4651b73767127ecb5b10091efffba4c8e99 */
#if BIND_git_index_write_tree_FUNCTION
#define git_index_write_tree_REQUIRED_ARGC 1
#define git_index_write_tree_OPTIONAL_ARGC 0
/* git_index_write_tree
 *
 * Parameters:
 * - index: git_index *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_write_tree(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_oid * native_out = (git_oid*)calloc(1, sizeof(git_oid));
  mrb_value index;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Invocation */
  int native_return_value = git_index_write_tree(native_out, native_index);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_oid(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_index_write_tree_to */
/* sha: acfd7beb0e09543526414a147b5829f1b558196cccd11c2ed29ecbf2ebfe743c */
#if BIND_git_index_write_tree_to_FUNCTION
#define git_index_write_tree_to_REQUIRED_ARGC 2
#define git_index_write_tree_to_OPTIONAL_ARGC 0
/* git_index_write_tree_to
 *
 * Parameters:
 * - index: git_index *
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_index_write_tree_to(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_oid * native_out = (git_oid*)calloc(1, sizeof(git_oid));
  mrb_value index;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &index, &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_index_write_tree_to(native_out, native_index, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_oid(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_indexer_append */
/* sha: 714c4e587f25a2c3b76e8b2b7475813f71aacfc6617a71cac70e6e6ed85f6405 */
#if BIND_git_indexer_append_FUNCTION
#define git_indexer_append_REQUIRED_ARGC 4
#define git_indexer_append_OPTIONAL_ARGC 0
/* git_indexer_append
 *
 * Parameters:
 * - idx: git_indexer *
 * - data: const void *
 * - size: size_t
 * - stats: git_transfer_progress *
 * Return Type: int
 */
mrb_value
mrb_Git_git_indexer_append(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value idx;
  mrb_value data;
  mrb_int native_size;
  mrb_value stats;

  /* Fetch the args */
  mrb_get_args(mrb, "ooio", &idx, &data, &native_size, &stats);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, idx, Indexer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Indexer expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  if (!mrb_obj_is_kind_of(mrb, stats, TransferProgress_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TransferProgress expected");
    return mrb_nil_value();
  }

  /* Unbox param: idx */
  git_indexer * native_idx = (mrb_nil_p(idx) ? NULL : mruby_unbox_git_indexer(idx));

  /* Unbox param: data */
  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Unbox param: stats */
  git_transfer_progress * native_stats = (mrb_nil_p(stats) ? NULL : mruby_unbox_git_transfer_progress(stats));

  /* Invocation */
  int native_return_value = git_indexer_append(native_idx, native_data, native_size, native_stats);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_indexer_commit */
/* sha: 6147842566f18dc4fe2438a94b1a7bdab0baaeb7ea72a14a31fe9eb56e20f416 */
#if BIND_git_indexer_commit_FUNCTION
#define git_indexer_commit_REQUIRED_ARGC 2
#define git_indexer_commit_OPTIONAL_ARGC 0
/* git_indexer_commit
 *
 * Parameters:
 * - idx: git_indexer *
 * - stats: git_transfer_progress *
 * Return Type: int
 */
mrb_value
mrb_Git_git_indexer_commit(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value idx;
  mrb_value stats;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &idx, &stats);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, idx, Indexer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Indexer expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, stats, TransferProgress_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TransferProgress expected");
    return mrb_nil_value();
  }

  /* Unbox param: idx */
  git_indexer * native_idx = (mrb_nil_p(idx) ? NULL : mruby_unbox_git_indexer(idx));

  /* Unbox param: stats */
  git_transfer_progress * native_stats = (mrb_nil_p(stats) ? NULL : mruby_unbox_git_transfer_progress(stats));

  /* Invocation */
  int native_return_value = git_indexer_commit(native_idx, native_stats);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_indexer_free */
/* sha: 45e7ad4538dc1c0c58d79af54e6adc841d009d62467005317ea048a241a05712 */
#if BIND_git_indexer_free_FUNCTION
#define git_indexer_free_REQUIRED_ARGC 1
#define git_indexer_free_OPTIONAL_ARGC 0
/* git_indexer_free
 *
 * Parameters:
 * - idx: git_indexer *
 * Return Type: void
 */
mrb_value
mrb_Git_git_indexer_free(mrb_state* mrb, mrb_value self) {
  mrb_value idx;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, idx, Indexer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Indexer expected");
    return mrb_nil_value();
  }

  /* Unbox param: idx */
  git_indexer * native_idx = (mrb_nil_p(idx) ? NULL : mruby_unbox_git_indexer(idx));

  /* Invocation */
  git_indexer_free(native_idx);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_indexer_hash */
/* sha: 2b862ef1346219eddab419adebeba2e6d02dbdf5641ce8a72153a8812fd940fb */
#if BIND_git_indexer_hash_FUNCTION
#define git_indexer_hash_REQUIRED_ARGC 1
#define git_indexer_hash_OPTIONAL_ARGC 0
/* git_indexer_hash
 *
 * Parameters:
 * - idx: const git_indexer *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_indexer_hash(mrb_state* mrb, mrb_value self) {
  mrb_value idx;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, idx, Indexer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Indexer expected");
    return mrb_nil_value();
  }

  /* Unbox param: idx */
  const git_indexer * native_idx = (mrb_nil_p(idx) ? NULL : mruby_unbox_git_indexer(idx));

  /* Invocation */
  const git_oid * native_return_value = git_indexer_hash(native_idx);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_indexer_new */
/* sha: 621e247fbbd13600e68249cf8bf81f43ea94a2c46c9b3a07105f6e849a450c74 */
#if BIND_git_indexer_new_FUNCTION
#define git_indexer_new_REQUIRED_ARGC 5
#define git_indexer_new_OPTIONAL_ARGC 0
/* git_indexer_new
 *
 * Parameters:
 * - path: const char *
 * - mode: unsigned int
 * - odb: git_odb *
 * - progress_cb: git_transfer_progress_cb
 * - progress_cb_payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_indexer_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_indexer * native_out = NULL;
  char * native_path = NULL;
  mrb_int native_mode;
  mrb_value odb;
  mrb_value progress_cb;
  mrb_value progress_cb_payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ziooo", &native_path, &native_mode, &odb, &progress_cb, &progress_cb_payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_transfer_progress_cb(progress_cb);
  TODO_type_check_void_PTR(progress_cb_payload);

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Unbox param: progress_cb */
  git_transfer_progress_cb native_progress_cb = TODO_mruby_unbox_git_transfer_progress_cb(progress_cb);

  /* Unbox param: progress_cb_payload */
  void * native_progress_cb_payload = TODO_mruby_unbox_void_PTR(progress_cb_payload);

  /* Invocation */
  int native_return_value = git_indexer_new(&native_out, native_path, native_mode, native_odb, native_progress_cb, native_progress_cb_payload);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_indexer(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_libgit2_features */
/* sha: 1cc5838dc0128c4d9a089635132b498141d47d6857aec4d0901a025dc843dab7 */
#if BIND_git_libgit2_features_FUNCTION
#define git_libgit2_features_REQUIRED_ARGC 0
#define git_libgit2_features_OPTIONAL_ARGC 0
/* git_libgit2_features
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_libgit2_features(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  int native_return_value = git_libgit2_features();

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_libgit2_init */
/* sha: fbbc2d6d3cc7da411af396e2453186f6a78255b67f82f96a3daa0192a399c06d */
#if BIND_git_libgit2_init_FUNCTION
#define git_libgit2_init_REQUIRED_ARGC 0
#define git_libgit2_init_OPTIONAL_ARGC 0
/* git_libgit2_init
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_libgit2_init(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  int native_return_value = git_libgit2_init();

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_libgit2_opts */
/* sha: bd1499b9fcd3f92b42fe6f4c16c2b5bb5e895625754c1283b76f0d53207744e4 */
#if BIND_git_libgit2_opts_FUNCTION
#define git_libgit2_opts_REQUIRED_ARGC 1
#define git_libgit2_opts_OPTIONAL_ARGC 0
/* git_libgit2_opts
 *
 * Parameters:
 * - option: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_libgit2_opts(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_int native_option;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_option);

  /* Invocation */
  int native_return_value = git_libgit2_opts(native_option);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_libgit2_shutdown */
/* sha: d3a64c1e1cc286120f83e77f69c910398eccc812155522cf664d14fc4b714ae7 */
#if BIND_git_libgit2_shutdown_FUNCTION
#define git_libgit2_shutdown_REQUIRED_ARGC 0
#define git_libgit2_shutdown_OPTIONAL_ARGC 0
/* git_libgit2_shutdown
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_libgit2_shutdown(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  int native_return_value = git_libgit2_shutdown();

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_libgit2_version */
/* sha: 7ba7f67c94106c17beae372b35e858112d1403fc6ae715b849ae24e98feac8bd */
#if BIND_git_libgit2_version_FUNCTION
#define git_libgit2_version_REQUIRED_ARGC 0
#define git_libgit2_version_OPTIONAL_ARGC 0
/* git_libgit2_version
 *
 * Parameters: None
 * Return Type: void
 */
mrb_value
mrb_Git_git_libgit2_version(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  int native_major;
  int native_minor;
  int native_rev;


  /* Invocation */
  git_libgit2_version(&native_major, &native_minor, &native_rev);

  /* Box out param: major */
  mrb_value major = mrb_fixnum_value(native_major);
  /* Box out param: minor */
  mrb_value minor = mrb_fixnum_value(native_minor);
  /* Box out param: rev */
  mrb_value rev = mrb_fixnum_value(native_rev);

  /* Add out params to results */
  mrb_ary_push(mrb, results, major);
  mrb_ary_push(mrb, results, minor);
  mrb_ary_push(mrb, results, rev);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge */
/* sha: f60c508b069ee36f2abacbaf994bd15b75416050dc50dc8b443793b7118a7f4e */
#if BIND_git_merge_FUNCTION
#define git_merge_REQUIRED_ARGC 4
#define git_merge_OPTIONAL_ARGC 0
/* git_merge
 *
 * Parameters:
 * - repo: git_repository *
 * - their_heads_len: size_t
 * - merge_opts: const git_merge_options *
 * - checkout_opts: const git_checkout_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  git_annotated_commit * native_their_heads = NULL;
  mrb_int native_their_heads_len;
  mrb_value merge_opts;
  mrb_value checkout_opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &repo, &native_their_heads_len, &merge_opts, &checkout_opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, merge_opts, MergeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeOptions expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, checkout_opts, CheckoutOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CheckoutOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: merge_opts */
  const git_merge_options * native_merge_opts = (mrb_nil_p(merge_opts) ? NULL : mruby_unbox_git_merge_options(merge_opts));

  /* Unbox param: checkout_opts */
  const git_checkout_options * native_checkout_opts = (mrb_nil_p(checkout_opts) ? NULL : mruby_unbox_git_checkout_options(checkout_opts));

  /* Invocation */
  int native_return_value = git_merge(native_repo, &native_their_heads, native_their_heads_len, native_merge_opts, native_checkout_opts);

  /* Box out param: their_heads */
  mrb_value their_heads = mruby_box_git_annotated_commit(mrb, native_their_heads);

  RAISE_GIT_ERROR(native_return_value);

  return their_heads;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_analysis */
/* sha: 65bc270b796772389c4d1b5afed273dc4a98ef2bbc7f24dac5efbb4b582a2af9 */
#if BIND_git_merge_analysis_FUNCTION
#define git_merge_analysis_REQUIRED_ARGC 2
#define git_merge_analysis_OPTIONAL_ARGC 0
/* git_merge_analysis
 *
 * Parameters:
 * - repo: git_repository *
 * - their_heads_len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_analysis(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value results = mrb_ary_new(mrb);
  int native_analysis_out;
  int native_preference_out;
  mrb_value repo;
  git_annotated_commit * native_their_heads = NULL;
  mrb_int native_their_heads_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &repo, &native_their_heads_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_merge_analysis(&native_analysis_out, &native_preference_out, native_repo, &native_their_heads, native_their_heads_len);

  /* Box out param: analysis_out */
  mrb_value analysis_out = mrb_fixnum_value(native_analysis_out);
  /* Box out param: preference_out */
  mrb_value preference_out = mrb_fixnum_value(native_preference_out);
  /* Box out param: their_heads */
  mrb_value their_heads = mruby_box_git_annotated_commit(mrb, native_their_heads);

  /* Add out params to results */
  mrb_ary_push(mrb, results, analysis_out);
  mrb_ary_push(mrb, results, preference_out);
  mrb_ary_push(mrb, results, their_heads);

  RAISE_GIT_ERROR(native_return_value);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_base */
/* sha: e9ac912ba92a319d33cda79ce8aeb0a71cf103cf57a16c32af47aa0c7a24d36c */
#if BIND_git_merge_base_FUNCTION
#define git_merge_base_REQUIRED_ARGC 4
#define git_merge_base_OPTIONAL_ARGC 0
/* git_merge_base
 *
 * Parameters:
 * - out: git_oid *
 * - repo: git_repository *
 * - one: const git_oid *
 * - two: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_base(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  mrb_value repo;
  mrb_value one;
  mrb_value two;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &out, &repo, &one, &two);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, one, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, two, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: one */
  const git_oid * native_one = (mrb_nil_p(one) ? NULL : mruby_unbox_git_oid(one));

  /* Unbox param: two */
  const git_oid * native_two = (mrb_nil_p(two) ? NULL : mruby_unbox_git_oid(two));

  /* Invocation */
  int native_return_value = git_merge_base(native_out, native_repo, native_one, native_two);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_base_many */
/* sha: 08d85ff5449afd3888fd98bbcfd65b883c6d7e02fcc6bf35ff2ace77bd251ad7 */
#if BIND_git_merge_base_many_FUNCTION
#define git_merge_base_many_REQUIRED_ARGC 4
#define git_merge_base_many_OPTIONAL_ARGC 0
/* git_merge_base_many
 *
 * Parameters:
 * - out: git_oid *
 * - repo: git_repository *
 * - length: size_t
 * - input_array: const git_oid []
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_base_many(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  mrb_value repo;
  mrb_int native_length;
  mrb_value input_array;

  /* Fetch the args */
  mrb_get_args(mrb, "ooio", &out, &repo, &native_length, &input_array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_oid_[](input_array);

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: input_array */
  const git_oid [] native_input_array = TODO_mruby_unbox_git_oid_[](input_array);

  /* Invocation */
  int native_return_value = git_merge_base_many(native_out, native_repo, native_length, native_input_array);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_base_octopus */
/* sha: a9e5021cb776f32d9c89e695235f9e131eb6d6eff793f09529bd557d88e6b958 */
#if BIND_git_merge_base_octopus_FUNCTION
#define git_merge_base_octopus_REQUIRED_ARGC 4
#define git_merge_base_octopus_OPTIONAL_ARGC 0
/* git_merge_base_octopus
 *
 * Parameters:
 * - out: git_oid *
 * - repo: git_repository *
 * - length: size_t
 * - input_array: const git_oid []
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_base_octopus(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  mrb_value repo;
  mrb_int native_length;
  mrb_value input_array;

  /* Fetch the args */
  mrb_get_args(mrb, "ooio", &out, &repo, &native_length, &input_array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_oid_[](input_array);

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: input_array */
  const git_oid [] native_input_array = TODO_mruby_unbox_git_oid_[](input_array);

  /* Invocation */
  int native_return_value = git_merge_base_octopus(native_out, native_repo, native_length, native_input_array);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_bases */
/* sha: 73c600300c0eb685aae0000808883e57297f3e738a5a48f181af627664b79b51 */
#if BIND_git_merge_bases_FUNCTION
#define git_merge_bases_REQUIRED_ARGC 4
#define git_merge_bases_OPTIONAL_ARGC 0
/* git_merge_bases
 *
 * Parameters:
 * - out: git_oidarray *
 * - repo: git_repository *
 * - one: const git_oid *
 * - two: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_bases(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  mrb_value repo;
  mrb_value one;
  mrb_value two;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &out, &repo, &one, &two);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oidarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oidarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, one, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, two, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oidarray * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oidarray(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: one */
  const git_oid * native_one = (mrb_nil_p(one) ? NULL : mruby_unbox_git_oid(one));

  /* Unbox param: two */
  const git_oid * native_two = (mrb_nil_p(two) ? NULL : mruby_unbox_git_oid(two));

  /* Invocation */
  int native_return_value = git_merge_bases(native_out, native_repo, native_one, native_two);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_bases_many */
/* sha: 1662a1a1b360b428f1275c569b921f8670c3c3b6ec96f855b5148446715d49f7 */
#if BIND_git_merge_bases_many_FUNCTION
#define git_merge_bases_many_REQUIRED_ARGC 4
#define git_merge_bases_many_OPTIONAL_ARGC 0
/* git_merge_bases_many
 *
 * Parameters:
 * - out: git_oidarray *
 * - repo: git_repository *
 * - length: size_t
 * - input_array: const git_oid []
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_bases_many(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  mrb_value repo;
  mrb_int native_length;
  mrb_value input_array;

  /* Fetch the args */
  mrb_get_args(mrb, "ooio", &out, &repo, &native_length, &input_array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oidarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oidarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_oid_[](input_array);

  /* Unbox param: out */
  git_oidarray * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oidarray(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: input_array */
  const git_oid [] native_input_array = TODO_mruby_unbox_git_oid_[](input_array);

  /* Invocation */
  int native_return_value = git_merge_bases_many(native_out, native_repo, native_length, native_input_array);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_commits */
/* sha: a6f75e70e0416d75f82dd836d8134d39e58a06168362446ba526dc7765e87a0d */
#if BIND_git_merge_commits_FUNCTION
#define git_merge_commits_REQUIRED_ARGC 4
#define git_merge_commits_OPTIONAL_ARGC 0
/* git_merge_commits
 *
 * Parameters:
 * - repo: git_repository *
 * - our_commit: const git_commit *
 * - their_commit: const git_commit *
 * - opts: const git_merge_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_commits(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_index * native_out = NULL;
  mrb_value repo;
  mrb_value our_commit;
  mrb_value their_commit;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &repo, &our_commit, &their_commit, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, our_commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, their_commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, MergeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: our_commit */
  const git_commit * native_our_commit = (mrb_nil_p(our_commit) ? NULL : mruby_unbox_git_commit(our_commit));

  /* Unbox param: their_commit */
  const git_commit * native_their_commit = (mrb_nil_p(their_commit) ? NULL : mruby_unbox_git_commit(their_commit));

  /* Unbox param: opts */
  const git_merge_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_merge_options(opts));

  /* Invocation */
  int native_return_value = git_merge_commits(&native_out, native_repo, native_our_commit, native_their_commit, native_opts);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_file */
/* sha: 9d82eb1856ab7c56b5c59480c0c0c7ea3ca0635e588b42e4be1ad195e3c3e1b8 */
#if BIND_git_merge_file_FUNCTION
#define git_merge_file_REQUIRED_ARGC 5
#define git_merge_file_OPTIONAL_ARGC 0
/* git_merge_file
 *
 * Parameters:
 * - out: git_merge_file_result *
 * - ancestor: const git_merge_file_input *
 * - ours: const git_merge_file_input *
 * - theirs: const git_merge_file_input *
 * - opts: const git_merge_file_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_file(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  mrb_value ancestor;
  mrb_value ours;
  mrb_value theirs;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooooo", &out, &ancestor, &ours, &theirs, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, MergeFileResult_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileResult expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ancestor, MergeFileInput_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileInput expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ours, MergeFileInput_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileInput expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, theirs, MergeFileInput_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileInput expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, MergeFileOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_merge_file_result * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_merge_file_result(out));

  /* Unbox param: ancestor */
  const git_merge_file_input * native_ancestor = (mrb_nil_p(ancestor) ? NULL : mruby_unbox_git_merge_file_input(ancestor));

  /* Unbox param: ours */
  const git_merge_file_input * native_ours = (mrb_nil_p(ours) ? NULL : mruby_unbox_git_merge_file_input(ours));

  /* Unbox param: theirs */
  const git_merge_file_input * native_theirs = (mrb_nil_p(theirs) ? NULL : mruby_unbox_git_merge_file_input(theirs));

  /* Unbox param: opts */
  const git_merge_file_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_merge_file_options(opts));

  /* Invocation */
  int native_return_value = git_merge_file(native_out, native_ancestor, native_ours, native_theirs, native_opts);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_file_from_index */
/* sha: 0803b15868dd7093248e507a3170423d3f97c020834983a2216a89c93b4df754 */
#if BIND_git_merge_file_from_index_FUNCTION
#define git_merge_file_from_index_REQUIRED_ARGC 6
#define git_merge_file_from_index_OPTIONAL_ARGC 0
/* git_merge_file_from_index
 *
 * Parameters:
 * - out: git_merge_file_result *
 * - repo: git_repository *
 * - ancestor: const git_index_entry *
 * - ours: const git_index_entry *
 * - theirs: const git_index_entry *
 * - opts: const git_merge_file_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_file_from_index(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  mrb_value repo;
  mrb_value ancestor;
  mrb_value ours;
  mrb_value theirs;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oooooo", &out, &repo, &ancestor, &ours, &theirs, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, MergeFileResult_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileResult expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ancestor, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ours, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, theirs, IndexEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "IndexEntry expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, MergeFileOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_merge_file_result * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_merge_file_result(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: ancestor */
  const git_index_entry * native_ancestor = (mrb_nil_p(ancestor) ? NULL : mruby_unbox_git_index_entry(ancestor));

  /* Unbox param: ours */
  const git_index_entry * native_ours = (mrb_nil_p(ours) ? NULL : mruby_unbox_git_index_entry(ours));

  /* Unbox param: theirs */
  const git_index_entry * native_theirs = (mrb_nil_p(theirs) ? NULL : mruby_unbox_git_index_entry(theirs));

  /* Unbox param: opts */
  const git_merge_file_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_merge_file_options(opts));

  /* Invocation */
  int native_return_value = git_merge_file_from_index(native_out, native_repo, native_ancestor, native_ours, native_theirs, native_opts);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_file_init_input */
/* sha: 3124df03c505008fa3111fb0aa5b86baec8c303ed7f2a14c5d41f5fb876ed57d */
#if BIND_git_merge_file_init_input_FUNCTION
#define git_merge_file_init_input_REQUIRED_ARGC 2
#define git_merge_file_init_input_OPTIONAL_ARGC 0
/* git_merge_file_init_input
 *
 * Parameters:
 * - opts: git_merge_file_input *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_file_init_input(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, MergeFileInput_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileInput expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_merge_file_input * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_merge_file_input(opts));

  /* Invocation */
  int native_return_value = git_merge_file_init_input(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_file_init_options */
/* sha: 715c3537c3c885cd8b1cb3527a00052c65fc0f0cb3b9b24eb02191c45541fb36 */
#if BIND_git_merge_file_init_options_FUNCTION
#define git_merge_file_init_options_REQUIRED_ARGC 2
#define git_merge_file_init_options_OPTIONAL_ARGC 0
/* git_merge_file_init_options
 *
 * Parameters:
 * - opts: git_merge_file_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_file_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, MergeFileOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_merge_file_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_merge_file_options(opts));

  /* Invocation */
  int native_return_value = git_merge_file_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_file_result_free */
/* sha: 53eb515fbbfbb06bd11d3397e82d5b0587d0ee5942b5612eeb0c8ab63343ac53 */
#if BIND_git_merge_file_result_free_FUNCTION
#define git_merge_file_result_free_REQUIRED_ARGC 1
#define git_merge_file_result_free_OPTIONAL_ARGC 0
/* git_merge_file_result_free
 *
 * Parameters:
 * - result: git_merge_file_result *
 * Return Type: void
 */
mrb_value
mrb_Git_git_merge_file_result_free(mrb_state* mrb, mrb_value self) {
  mrb_value result;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &result);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, result, MergeFileResult_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeFileResult expected");
    return mrb_nil_value();
  }

  /* Unbox param: result */
  git_merge_file_result * native_result = (mrb_nil_p(result) ? NULL : mruby_unbox_git_merge_file_result(result));

  /* Invocation */
  git_merge_file_result_free(native_result);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_init_options */
/* sha: 9a39184bfb65eaadc4a972c5489f7b5e2979a6986d347015c5318e398a8ca3d7 */
#if BIND_git_merge_init_options_FUNCTION
#define git_merge_init_options_REQUIRED_ARGC 2
#define git_merge_init_options_OPTIONAL_ARGC 0
/* git_merge_init_options
 *
 * Parameters:
 * - opts: git_merge_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, MergeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_merge_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_merge_options(opts));

  /* Invocation */
  int native_return_value = git_merge_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_merge_trees */
/* sha: d87b2a6364491ba2e55830a345a40e85545ef17096c0bc419444f98427406a78 */
#if BIND_git_merge_trees_FUNCTION
#define git_merge_trees_REQUIRED_ARGC 5
#define git_merge_trees_OPTIONAL_ARGC 0
/* git_merge_trees
 *
 * Parameters:
 * - repo: git_repository *
 * - ancestor_tree: const git_tree *
 * - our_tree: const git_tree *
 * - their_tree: const git_tree *
 * - opts: const git_merge_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_merge_trees(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_index * native_out = NULL;
  mrb_value repo;
  mrb_value ancestor_tree;
  mrb_value our_tree;
  mrb_value their_tree;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooooo", &repo, &ancestor_tree, &our_tree, &their_tree, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ancestor_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, our_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, their_tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, MergeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: ancestor_tree */
  const git_tree * native_ancestor_tree = (mrb_nil_p(ancestor_tree) ? NULL : mruby_unbox_git_tree(ancestor_tree));

  /* Unbox param: our_tree */
  const git_tree * native_our_tree = (mrb_nil_p(our_tree) ? NULL : mruby_unbox_git_tree(our_tree));

  /* Unbox param: their_tree */
  const git_tree * native_their_tree = (mrb_nil_p(their_tree) ? NULL : mruby_unbox_git_tree(their_tree));

  /* Unbox param: opts */
  const git_merge_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_merge_options(opts));

  /* Invocation */
  int native_return_value = git_merge_trees(&native_out, native_repo, native_ancestor_tree, native_our_tree, native_their_tree, native_opts);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_message_prettify */
/* sha: ef082c2fb5d3409cd8643df69337424392fe8f26c0f9f54cbd7588a651e650a2 */
#if BIND_git_message_prettify_FUNCTION
#define git_message_prettify_REQUIRED_ARGC 3
#define git_message_prettify_OPTIONAL_ARGC 0
/* git_message_prettify
 *
 * Parameters:
 * - message: const char *
 * - strip_comments: int
 * - comment_char: char
 * Return Type: int
 */
mrb_value
mrb_Git_git_message_prettify(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  char * native_message = NULL;
  mrb_int native_strip_comments;
  mrb_int native_comment_char;

  /* Fetch the args */
  mrb_get_args(mrb, "zii", &native_message, &native_strip_comments, &native_comment_char);

  /* Invocation */
  int native_return_value = git_message_prettify(native_out, native_message, native_strip_comments, native_comment_char);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_author */
/* sha: 0daa74ce2fec286427cf02ff770be760d6d8122c44a4be1a6bc0b99dd1ec9f94 */
#if BIND_git_note_author_FUNCTION
#define git_note_author_REQUIRED_ARGC 1
#define git_note_author_OPTIONAL_ARGC 0
/* git_note_author
 *
 * Parameters:
 * - note: const git_note *
 * Return Type: const git_signature *
 */
mrb_value
mrb_Git_git_note_author(mrb_state* mrb, mrb_value self) {
  mrb_value note;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &note);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, note, Note_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Note expected");
    return mrb_nil_value();
  }

  /* Unbox param: note */
  const git_note * native_note = (mrb_nil_p(note) ? NULL : mruby_unbox_git_note(note));

  /* Invocation */
  const git_signature * native_return_value = git_note_author(native_note);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_signature(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_committer */
/* sha: 1a33fd5e73c06e604603d3509cd53682645df50a7aa14e477ecbed69c78ec410 */
#if BIND_git_note_committer_FUNCTION
#define git_note_committer_REQUIRED_ARGC 1
#define git_note_committer_OPTIONAL_ARGC 0
/* git_note_committer
 *
 * Parameters:
 * - note: const git_note *
 * Return Type: const git_signature *
 */
mrb_value
mrb_Git_git_note_committer(mrb_state* mrb, mrb_value self) {
  mrb_value note;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &note);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, note, Note_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Note expected");
    return mrb_nil_value();
  }

  /* Unbox param: note */
  const git_note * native_note = (mrb_nil_p(note) ? NULL : mruby_unbox_git_note(note));

  /* Invocation */
  const git_signature * native_return_value = git_note_committer(native_note);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_signature(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_create */
/* sha: 7dfdea41b9816b20fda813e4532f91a75cc78711be3bab388cf2009399bb1418 */
#if BIND_git_note_create_FUNCTION
#define git_note_create_REQUIRED_ARGC 7
#define git_note_create_OPTIONAL_ARGC 0
/* git_note_create
 *
 * Parameters:
 * - repo: git_repository *
 * - notes_ref: const char *
 * - author: const git_signature *
 * - committer: const git_signature *
 * - oid: const git_oid *
 * - note: const char *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_note_create(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_oid * native_out = (git_oid*)calloc(1, sizeof(git_oid));
  mrb_value repo;
  char * native_notes_ref = NULL;
  mrb_value author;
  mrb_value committer;
  mrb_value oid;
  char * native_note = NULL;
  mrb_bool native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "ozooozb", &repo, &native_notes_ref, &author, &committer, &oid, &native_note, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, author, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, committer, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, oid, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: author */
  const git_signature * native_author = (mrb_nil_p(author) ? NULL : mruby_unbox_git_signature(author));

  /* Unbox param: committer */
  const git_signature * native_committer = (mrb_nil_p(committer) ? NULL : mruby_unbox_git_signature(committer));

  /* Unbox param: oid */
  const git_oid * native_oid = (mrb_nil_p(oid) ? NULL : mruby_unbox_git_oid(oid));

  /* Invocation */
  int native_return_value = git_note_create(native_out, native_repo, native_notes_ref, native_author, native_committer, native_oid, native_note, native_force);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_oid(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_default_ref */
/* sha: 7251740e1ffc121ee5efb8f301ea1824d9085526514cf8a2b1578d2b6bc46c2b */
#if BIND_git_note_default_ref_FUNCTION
#define git_note_default_ref_REQUIRED_ARGC 1
#define git_note_default_ref_OPTIONAL_ARGC 0
/* git_note_default_ref
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_note_default_ref(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  int native_out;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_note_default_ref(&native_out, native_repo);

  /* Box out param: out */
  mrb_value out = mrb_fixnum_value(native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_foreach */
/* sha: 06a462fed8328e64909f1a5ca59a2d5052589a5c561215d4ef288277dc15100f */
#if BIND_git_note_foreach_FUNCTION
#define git_note_foreach_REQUIRED_ARGC 4
#define git_note_foreach_OPTIONAL_ARGC 0
/* git_note_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - notes_ref: const char *
 * - note_cb: git_note_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_note_foreach(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_notes_ref = NULL;
  mrb_value note_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoo", &repo, &native_notes_ref, &note_cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_note_foreach_cb(note_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: note_cb */
  git_note_foreach_cb native_note_cb = TODO_mruby_unbox_git_note_foreach_cb(note_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_note_foreach(native_repo, native_notes_ref, native_note_cb, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_free */
/* sha: 372f3718f09a818cee2d91438719ed30f2a52300c08dbdfcc3a6d360fc24755b */
#if BIND_git_note_free_FUNCTION
#define git_note_free_REQUIRED_ARGC 1
#define git_note_free_OPTIONAL_ARGC 0
/* git_note_free
 *
 * Parameters:
 * - note: git_note *
 * Return Type: void
 */
mrb_value
mrb_Git_git_note_free(mrb_state* mrb, mrb_value self) {
  mrb_value note;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &note);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, note, Note_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Note expected");
    return mrb_nil_value();
  }

  /* Unbox param: note */
  git_note * native_note = (mrb_nil_p(note) ? NULL : mruby_unbox_git_note(note));

  /* Invocation */
  git_note_free(native_note);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_id */
/* sha: e5a07b7c2fc7e529b657f88bcc53d63cd065d68d8f7653bf5ea0534abd745099 */
#if BIND_git_note_id_FUNCTION
#define git_note_id_REQUIRED_ARGC 1
#define git_note_id_OPTIONAL_ARGC 0
/* git_note_id
 *
 * Parameters:
 * - note: const git_note *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_note_id(mrb_state* mrb, mrb_value self) {
  mrb_value note;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &note);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, note, Note_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Note expected");
    return mrb_nil_value();
  }

  /* Unbox param: note */
  const git_note * native_note = (mrb_nil_p(note) ? NULL : mruby_unbox_git_note(note));

  /* Invocation */
  const git_oid * native_return_value = git_note_id(native_note);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_iterator_free */
/* sha: ac53ef9fb28bf6d75e6710468a588faa92dbc374baf08fe58518598ef1c732f1 */
#if BIND_git_note_iterator_free_FUNCTION
#define git_note_iterator_free_REQUIRED_ARGC 1
#define git_note_iterator_free_OPTIONAL_ARGC 0
/* git_note_iterator_free
 *
 * Parameters:
 * - it: git_note_iterator *
 * Return Type: void
 */
mrb_value
mrb_Git_git_note_iterator_free(mrb_state* mrb, mrb_value self) {
  mrb_value it;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &it);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, it, NoteIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "NoteIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: it */
  git_note_iterator * native_it = (mrb_nil_p(it) ? NULL : mruby_unbox_git_note_iterator(it));

  /* Invocation */
  git_note_iterator_free(native_it);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_iterator_new */
/* sha: 8146e7a5ab9a0dae29540047fb2e96f4cc1fe0b1bfb06131f83e669018972973 */
#if BIND_git_note_iterator_new_FUNCTION
#define git_note_iterator_new_REQUIRED_ARGC 2
#define git_note_iterator_new_OPTIONAL_ARGC 0
/* git_note_iterator_new
 *
 * Parameters:
 * - repo: git_repository *
 * - notes_ref: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_note_iterator_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_note_iterator * native_out = NULL;
  mrb_value repo;
  char * native_notes_ref = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_notes_ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_note_iterator_new(&native_out, native_repo, native_notes_ref);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_note_iterator(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_message */
/* sha: eca8d6bc3d6625be150ba0da2e6ef0b6a3141f4006165696e27827764906f769 */
#if BIND_git_note_message_FUNCTION
#define git_note_message_REQUIRED_ARGC 1
#define git_note_message_OPTIONAL_ARGC 0
/* git_note_message
 *
 * Parameters:
 * - note: const git_note *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_note_message(mrb_state* mrb, mrb_value self) {
  mrb_value note;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &note);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, note, Note_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Note expected");
    return mrb_nil_value();
  }

  /* Unbox param: note */
  const git_note * native_note = (mrb_nil_p(note) ? NULL : mruby_unbox_git_note(note));

  /* Invocation */
  const char * native_return_value = git_note_message(native_note);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_next */
/* sha: 8913b5f5726286aaa2a08704a2f3418c14dd068d2943305a8393b8b35300cb6f */
#if BIND_git_note_next_FUNCTION
#define git_note_next_REQUIRED_ARGC 3
#define git_note_next_OPTIONAL_ARGC 0
/* git_note_next
 *
 * Parameters:
 * - note_id: git_oid *
 * - annotated_id: git_oid *
 * - it: git_note_iterator *
 * Return Type: int
 */
mrb_value
mrb_Git_git_note_next(mrb_state* mrb, mrb_value self) {
  mrb_value note_id;
  mrb_value annotated_id;
  mrb_value it;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &note_id, &annotated_id, &it);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, note_id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, annotated_id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, it, NoteIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "NoteIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: note_id */
  git_oid * native_note_id = (mrb_nil_p(note_id) ? NULL : mruby_unbox_git_oid(note_id));

  /* Unbox param: annotated_id */
  git_oid * native_annotated_id = (mrb_nil_p(annotated_id) ? NULL : mruby_unbox_git_oid(annotated_id));

  /* Unbox param: it */
  git_note_iterator * native_it = (mrb_nil_p(it) ? NULL : mruby_unbox_git_note_iterator(it));

  /* Invocation */
  int native_return_value = git_note_next(native_note_id, native_annotated_id, native_it);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_read */
/* sha: bbedbe738eae4f9a04d491f5edef6ad7af91764d6fafbada6b8c06f0acaf46c9 */
#if BIND_git_note_read_FUNCTION
#define git_note_read_REQUIRED_ARGC 3
#define git_note_read_OPTIONAL_ARGC 0
/* git_note_read
 *
 * Parameters:
 * - repo: git_repository *
 * - notes_ref: const char *
 * - oid: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_note_read(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_note * native_out = NULL;
  mrb_value repo;
  char * native_notes_ref = NULL;
  mrb_value oid;

  /* Fetch the args */
  mrb_get_args(mrb, "ozo", &repo, &native_notes_ref, &oid);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, oid, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: oid */
  const git_oid * native_oid = (mrb_nil_p(oid) ? NULL : mruby_unbox_git_oid(oid));

  /* Invocation */
  int native_return_value = git_note_read(&native_out, native_repo, native_notes_ref, native_oid);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_note(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_note_remove */
/* sha: 846e89355d7a766be937767a22793fe16853c11ffdea356ebe7631c53d481675 */
#if BIND_git_note_remove_FUNCTION
#define git_note_remove_REQUIRED_ARGC 5
#define git_note_remove_OPTIONAL_ARGC 0
/* git_note_remove
 *
 * Parameters:
 * - repo: git_repository *
 * - notes_ref: const char *
 * - author: const git_signature *
 * - committer: const git_signature *
 * - oid: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_note_remove(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_notes_ref = NULL;
  mrb_value author;
  mrb_value committer;
  mrb_value oid;

  /* Fetch the args */
  mrb_get_args(mrb, "ozooo", &repo, &native_notes_ref, &author, &committer, &oid);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, author, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, committer, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, oid, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: author */
  const git_signature * native_author = (mrb_nil_p(author) ? NULL : mruby_unbox_git_signature(author));

  /* Unbox param: committer */
  const git_signature * native_committer = (mrb_nil_p(committer) ? NULL : mruby_unbox_git_signature(committer));

  /* Unbox param: oid */
  const git_oid * native_oid = (mrb_nil_p(oid) ? NULL : mruby_unbox_git_oid(oid));

  /* Invocation */
  int native_return_value = git_note_remove(native_repo, native_notes_ref, native_author, native_committer, native_oid);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object__size */
/* sha: 2f337ddd02ed2e1fb96336113391589002c5291be9a14cd904059eab3a2bdccf */
#if BIND_git_object__size_FUNCTION
#define git_object__size_REQUIRED_ARGC 1
#define git_object__size_OPTIONAL_ARGC 0
/* git_object__size
 *
 * Parameters:
 * - type: git_otype
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_object__size(mrb_state* mrb, mrb_value self) {
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_type);

  /* Invocation */
  size_t native_return_value = git_object__size(native_type);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_dup */
/* sha: 1001c557f6653f77d16a89a1507698cebfe0271013a241158434ab7205b90d3e */
#if BIND_git_object_dup_FUNCTION
#define git_object_dup_REQUIRED_ARGC 1
#define git_object_dup_OPTIONAL_ARGC 0
/* git_object_dup
 *
 * Parameters:
 * - source: git_object *
 * Return Type: int
 */
mrb_value
mrb_Git_git_object_dup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_object * native_dest = NULL;
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: source */
  git_object * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox_git_object(source));

  /* Invocation */
  int native_return_value = git_object_dup(&native_dest, native_source);

  /* Box out param: dest */
  mrb_value dest = native_dest == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_dest);

  RAISE_GIT_ERROR(native_return_value);

  return dest;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_free */
/* sha: 5427c3742242bf38f560b51a7eea80e525e35bbaaf793e8231140d7d11ff5085 */
#if BIND_git_object_free_FUNCTION
#define git_object_free_REQUIRED_ARGC 1
#define git_object_free_OPTIONAL_ARGC 0
/* git_object_free
 *
 * Parameters:
 * - object: git_object *
 * Return Type: void
 */
mrb_value
mrb_Git_git_object_free(mrb_state* mrb, mrb_value self) {
  mrb_value object;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &object);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, object, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: object */
  git_object * native_object = (mrb_nil_p(object) ? NULL : mruby_unbox_git_object(object));

  /* Invocation */
  git_object_free(native_object);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_id */
/* sha: 58c787dab123f0a7caa6fe804adfe0f6a63dcfae5449bdb1c49a8268d6e635e0 */
#if BIND_git_object_id_FUNCTION
#define git_object_id_REQUIRED_ARGC 1
#define git_object_id_OPTIONAL_ARGC 0
/* git_object_id
 *
 * Parameters:
 * - obj: const git_object *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_object_id(mrb_state* mrb, mrb_value self) {
  mrb_value obj;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &obj);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, obj, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: obj */
  const git_object * native_obj = (mrb_nil_p(obj) ? NULL : mruby_unbox_git_object(obj));

  /* Invocation */
  const git_oid * native_return_value = git_object_id(native_obj);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_lookup */
/* sha: d5e6c6198d9626a9a3c5e4e1c9569f4910821ec9023c64c52e074256e6df2010 */
#if BIND_git_object_lookup_FUNCTION
#define git_object_lookup_REQUIRED_ARGC 2
#define git_object_lookup_OPTIONAL_ARGC 1
/* git_object_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_object_lookup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_object * native_object = NULL;
  mrb_value repo;
  mrb_value id;
  mrb_int native_type = GIT_OBJ_ANY;

  /* Fetch the args */
  mrb_get_args(mrb, "oo|i", &repo, &id, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_object_lookup(&native_object, native_repo, native_id, native_type);
  
  mrb_value object = mrb_nil_value();
  if (native_return_value == 0) {
    object = mruby_git_giftwrap_object_virtual(mrb, native_object);
  }

  RAISE_GIT_ERROR(native_return_value);

  return object;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_lookup_bypath */
/* sha: 582bd324bf06b07c43c1b9926c7d29f5461e682603dec749dbc18dacda278e9c */
#if BIND_git_object_lookup_bypath_FUNCTION
#define git_object_lookup_bypath_REQUIRED_ARGC 3
#define git_object_lookup_bypath_OPTIONAL_ARGC 0
/* git_object_lookup_bypath
 *
 * Parameters:
 * - treeish: const git_object *
 * - path: const char *
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_object_lookup_bypath(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_object * native_out = NULL;
  mrb_value treeish;
  char * native_path = NULL;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &treeish, &native_path, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, treeish, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: treeish */
  const git_object * native_treeish = (mrb_nil_p(treeish) ? NULL : mruby_unbox_git_object(treeish));

  /* Invocation */
  int native_return_value = git_object_lookup_bypath(&native_out, native_treeish, native_path, native_type);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_lookup_prefix */
/* sha: c21845602f2c905b153d8554306f1b1f5e650bdf069cb05d2c447b56b0426224 */
#if BIND_git_object_lookup_prefix_FUNCTION
#define git_object_lookup_prefix_REQUIRED_ARGC 4
#define git_object_lookup_prefix_OPTIONAL_ARGC 0
/* git_object_lookup_prefix
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * - len: size_t
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_object_lookup_prefix(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_object * native_object_out = NULL;
  mrb_value repo;
  mrb_value id;
  mrb_int native_len;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "ooii", &repo, &id, &native_len, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_object_lookup_prefix(&native_object_out, native_repo, native_id, native_len, native_type);

  /* Box out param: object_out */
  mrb_value object_out = native_object_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_object_out);

  RAISE_GIT_ERROR(native_return_value);

  return object_out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_owner */
/* sha: 67db950c07461afdeca7e1a77ffa22c5b531a0bc7e70e5f667067054ee417873 */
#if BIND_git_object_owner_FUNCTION
#define git_object_owner_REQUIRED_ARGC 1
#define git_object_owner_OPTIONAL_ARGC 0
/* git_object_owner
 *
 * Parameters:
 * - obj: const git_object *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_object_owner(mrb_state* mrb, mrb_value self) {
  mrb_value obj;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &obj);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, obj, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: obj */
  const git_object * native_obj = (mrb_nil_p(obj) ? NULL : mruby_unbox_git_object(obj));

  /* Invocation */
  git_repository * native_return_value = git_object_owner(native_obj);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_peel */
/* sha: 21b6291ca5b067931d958ee68ab78e6261665b078a35d9667e980febe9f81e6d */
#if BIND_git_object_peel_FUNCTION
#define git_object_peel_REQUIRED_ARGC 2
#define git_object_peel_OPTIONAL_ARGC 0
/* git_object_peel
 *
 * Parameters:
 * - object: const git_object *
 * - target_type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_object_peel(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_object * native_peeled = NULL;
  mrb_value object;
  mrb_int native_target_type;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &object, &native_target_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, object, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: object */
  const git_object * native_object = (mrb_nil_p(object) ? NULL : mruby_unbox_git_object(object));

  /* Invocation */
  int native_return_value = git_object_peel(&native_peeled, native_object, native_target_type);

  /* Box out param: peeled */
  mrb_value peeled = native_peeled == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_peeled);

  RAISE_GIT_ERROR(native_return_value);

  return peeled;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_short_id */
/* sha: ed38a635cfcb0aee2dea87a5ac261ef4729f4d4b73c4fc9a34bdfb306f8f9654 */
#if BIND_git_object_short_id_FUNCTION
#define git_object_short_id_REQUIRED_ARGC 1
#define git_object_short_id_OPTIONAL_ARGC 0
/* git_object_short_id
 *
 * Parameters:
 * - obj: const git_object *
 * Return Type: int
 */
mrb_value
mrb_Git_git_object_short_id(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value obj;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &obj);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, obj, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: obj */
  const git_object * native_obj = (mrb_nil_p(obj) ? NULL : mruby_unbox_git_object(obj));

  /* Invocation */
  int native_return_value = git_object_short_id(native_out, native_obj);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_string2type */
/* sha: ea1788320dbcf63fbe0cd299c2176e50d6a14b6a20ef6e35c9b63a403c308926 */
#if BIND_git_object_string2type_FUNCTION
#define git_object_string2type_REQUIRED_ARGC 1
#define git_object_string2type_OPTIONAL_ARGC 0
/* git_object_string2type
 *
 * Parameters:
 * - str: const char *
 * Return Type: git_otype
 */
mrb_value
mrb_Git_git_object_string2type(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_str);

  /* Invocation */
  git_otype native_return_value = git_object_string2type(native_str);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_type */
/* sha: e43f56870b7b5acec49c27fb19d8b7f961150672be71e0a79139c753e189f008 */
#if BIND_git_object_type_FUNCTION
#define git_object_type_REQUIRED_ARGC 1
#define git_object_type_OPTIONAL_ARGC 0
/* git_object_type
 *
 * Parameters:
 * - obj: const git_object *
 * Return Type: git_otype
 */
mrb_value
mrb_Git_git_object_type(mrb_state* mrb, mrb_value self) {
  mrb_value obj;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &obj);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, obj, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: obj */
  const git_object * native_obj = (mrb_nil_p(obj) ? NULL : mruby_unbox_git_object(obj));

  /* Invocation */
  git_otype native_return_value = git_object_type(native_obj);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_type2string */
/* sha: 59300ea76612f5a68e843726e2939d66c5715f6a14abffb16999969c3153921e */
#if BIND_git_object_type2string_FUNCTION
#define git_object_type2string_REQUIRED_ARGC 1
#define git_object_type2string_OPTIONAL_ARGC 0
/* git_object_type2string
 *
 * Parameters:
 * - type: git_otype
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_object_type2string(mrb_state* mrb, mrb_value self) {
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_type);

  /* Invocation */
  const char * native_return_value = git_object_type2string(native_type);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_object_typeisloose */
/* sha: 06f1b1ab0ee424d1e6eb4ee2f888f3f7024d191d03609059eed5b9196c7f0aef */
#if BIND_git_object_typeisloose_FUNCTION
#define git_object_typeisloose_REQUIRED_ARGC 1
#define git_object_typeisloose_OPTIONAL_ARGC 0
/* git_object_typeisloose
 *
 * Parameters:
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_object_typeisloose(mrb_state* mrb, mrb_value self) {
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_type);

  /* Invocation */
  int native_return_value = git_object_typeisloose(native_type);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_add_alternate */
/* sha: 326e639eb7a760566153ba120c6ba8918d775a202f355f506d7bb5fda70db9b4 */
#if BIND_git_odb_add_alternate_FUNCTION
#define git_odb_add_alternate_REQUIRED_ARGC 3
#define git_odb_add_alternate_OPTIONAL_ARGC 0
/* git_odb_add_alternate
 *
 * Parameters:
 * - odb: git_odb *
 * - backend: git_odb_backend *
 * - priority: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_add_alternate(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value odb;
  mrb_value backend;
  mrb_int native_priority;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &odb, &backend, &native_priority);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, backend, OdbBackend_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbBackend expected");
    return mrb_nil_value();
  }

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Unbox param: backend */
  git_odb_backend * native_backend = (mrb_nil_p(backend) ? NULL : mruby_unbox_git_odb_backend(backend));

  /* Invocation */
  int native_return_value = git_odb_add_alternate(native_odb, native_backend, native_priority);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_add_backend */
/* sha: b9575bad70d680aff36a02858514b6e4ffd6acfe70c3360ccd8a86aaf6e4d2f4 */
#if BIND_git_odb_add_backend_FUNCTION
#define git_odb_add_backend_REQUIRED_ARGC 3
#define git_odb_add_backend_OPTIONAL_ARGC 0
/* git_odb_add_backend
 *
 * Parameters:
 * - odb: git_odb *
 * - backend: git_odb_backend *
 * - priority: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_add_backend(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value odb;
  mrb_value backend;
  mrb_int native_priority;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &odb, &backend, &native_priority);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, backend, OdbBackend_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbBackend expected");
    return mrb_nil_value();
  }

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Unbox param: backend */
  git_odb_backend * native_backend = (mrb_nil_p(backend) ? NULL : mruby_unbox_git_odb_backend(backend));

  /* Invocation */
  int native_return_value = git_odb_add_backend(native_odb, native_backend, native_priority);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_add_disk_alternate */
/* sha: d9a51cbec61984fe4209dbb0fd3e82ed8097219a4d1a059f46709d95963a7a0d */
#if BIND_git_odb_add_disk_alternate_FUNCTION
#define git_odb_add_disk_alternate_REQUIRED_ARGC 2
#define git_odb_add_disk_alternate_OPTIONAL_ARGC 0
/* git_odb_add_disk_alternate
 *
 * Parameters:
 * - odb: git_odb *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_add_disk_alternate(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value odb;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &odb, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Invocation */
  int native_return_value = git_odb_add_disk_alternate(native_odb, native_path);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_backend_loose */
/* sha: d77c0805fde49d78d0ab26c1c5fa743ee7f1ba8581ceec93c50372e1132b26cd */
#if BIND_git_odb_backend_loose_FUNCTION
#define git_odb_backend_loose_REQUIRED_ARGC 5
#define git_odb_backend_loose_OPTIONAL_ARGC 0
/* git_odb_backend_loose
 *
 * Parameters:
 * - objects_dir: const char *
 * - compression_level: int
 * - do_fsync: int
 * - dir_mode: unsigned int
 * - file_mode: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_backend_loose(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_odb_backend * native_out = NULL;
  char * native_objects_dir = NULL;
  mrb_int native_compression_level;
  mrb_int native_do_fsync;
  mrb_int native_dir_mode;
  mrb_int native_file_mode;

  /* Fetch the args */
  mrb_get_args(mrb, "ziiii", &native_objects_dir, &native_compression_level, &native_do_fsync, &native_dir_mode, &native_file_mode);

  /* Invocation */
  int native_return_value = git_odb_backend_loose(&native_out, native_objects_dir, native_compression_level, native_do_fsync, native_dir_mode, native_file_mode);

  /* Box out param: out */
  mrb_value out = mruby_box_git_odb_backend(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_backend_one_pack */
/* sha: 50dea789bdfee9ecfc8c711dd6d87c3e1a773b34e3b6c370b337a579b77c634d */
#if BIND_git_odb_backend_one_pack_FUNCTION
#define git_odb_backend_one_pack_REQUIRED_ARGC 1
#define git_odb_backend_one_pack_OPTIONAL_ARGC 0
/* git_odb_backend_one_pack
 *
 * Parameters:
 * - index_file: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_backend_one_pack(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_odb_backend * native_out = NULL;
  char * native_index_file = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_index_file);

  /* Invocation */
  int native_return_value = git_odb_backend_one_pack(&native_out, native_index_file);

  /* Box out param: out */
  mrb_value out = mruby_box_git_odb_backend(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_backend_pack */
/* sha: 1f7232d98a6918356c5c8b2b357fe773e90ccb0934964f4c16590a845bfe3406 */
#if BIND_git_odb_backend_pack_FUNCTION
#define git_odb_backend_pack_REQUIRED_ARGC 1
#define git_odb_backend_pack_OPTIONAL_ARGC 0
/* git_odb_backend_pack
 *
 * Parameters:
 * - objects_dir: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_backend_pack(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_odb_backend * native_out = NULL;
  char * native_objects_dir = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_objects_dir);

  /* Invocation */
  int native_return_value = git_odb_backend_pack(&native_out, native_objects_dir);

  /* Box out param: out */
  mrb_value out = mruby_box_git_odb_backend(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_exists */
/* sha: aa6a9afefea4799d15dfa51e3f0b471bc963a923c5d16b1f935939eac4003f8f */
#if BIND_git_odb_exists_FUNCTION
#define git_odb_exists_REQUIRED_ARGC 2
#define git_odb_exists_OPTIONAL_ARGC 0
/* git_odb_exists
 *
 * Parameters:
 * - db: git_odb *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_exists(mrb_state* mrb, mrb_value self) {
  mrb_value db;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &db, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_odb_exists(native_db, native_id);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_exists_prefix */
/* sha: f8f1500b1261228891ca59024373a6f10ae8917ac930ed51cd6f5e7c5654fb08 */
#if BIND_git_odb_exists_prefix_FUNCTION
#define git_odb_exists_prefix_REQUIRED_ARGC 4
#define git_odb_exists_prefix_OPTIONAL_ARGC 0
/* git_odb_exists_prefix
 *
 * Parameters:
 * - out: git_oid *
 * - db: git_odb *
 * - short_id: const git_oid *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_exists_prefix(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value db;
  mrb_value short_id;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oooi", &out, &db, &short_id, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, short_id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: short_id */
  const git_oid * native_short_id = (mrb_nil_p(short_id) ? NULL : mruby_unbox_git_oid(short_id));

  /* Invocation */
  int native_return_value = git_odb_exists_prefix(native_out, native_db, native_short_id, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_foreach */
/* sha: 5b881e72645d8963e6139519b70e860dd7ca8345262b8c65e882631f2c13240c */
#if BIND_git_odb_foreach_FUNCTION
#define git_odb_foreach_REQUIRED_ARGC 3
#define git_odb_foreach_OPTIONAL_ARGC 0
/* git_odb_foreach
 *
 * Parameters:
 * - db: git_odb *
 * - cb: git_odb_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_foreach(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value db;
  mrb_value cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &db, &cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_odb_foreach_cb(cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: cb */
  git_odb_foreach_cb native_cb = TODO_mruby_unbox_git_odb_foreach_cb(cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_odb_foreach(native_db, native_cb, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_free */
/* sha: 40d7f2179d1aff990cd3034e21dbe07ece8927242ad3e356aa4ef4bbf7ac4ea9 */
#if BIND_git_odb_free_FUNCTION
#define git_odb_free_REQUIRED_ARGC 1
#define git_odb_free_OPTIONAL_ARGC 0
/* git_odb_free
 *
 * Parameters:
 * - db: git_odb *
 * Return Type: void
 */
mrb_value
mrb_Git_git_odb_free(mrb_state* mrb, mrb_value self) {
  mrb_value db;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &db);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Invocation */
  git_odb_free(native_db);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_get_backend */
/* sha: 5d8690f842018281a6926392eef20ae1685d2c6296d07886015075a857026a9f */
#if BIND_git_odb_get_backend_FUNCTION
#define git_odb_get_backend_REQUIRED_ARGC 2
#define git_odb_get_backend_OPTIONAL_ARGC 0
/* git_odb_get_backend
 *
 * Parameters:
 * - odb: git_odb *
 * - pos: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_get_backend(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_odb_backend * native_out = NULL;
  mrb_value odb;
  mrb_int native_pos;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &odb, &native_pos);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Invocation */
  int native_return_value = git_odb_get_backend(&native_out, native_odb, native_pos);

  /* Box out param: out */
  mrb_value out = mruby_box_git_odb_backend(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_hash */
/* sha: 2f7a0f8ccb845b497448a3893f368fe3fb6360d60cc050a6d3852be26aa4b392 */
#if BIND_git_odb_hash_FUNCTION
#define git_odb_hash_REQUIRED_ARGC 3
#define git_odb_hash_OPTIONAL_ARGC 0
/* git_odb_hash
 *
 * Parameters:
 * - out: git_oid *
 * - data: const void *
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_hash(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  mrb_value native_data;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "oSi", &out, &native_data, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Invocation */
  int native_return_value = git_odb_hash(native_out, RSTRING_PTR(native_data), RSTRING_LEN(native_data), native_type);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_hashfile */
/* sha: d3da9cd5b4a4f3c06236ad1ff0182ee85eee8295cd7f62c0bed4bf3640b958df */
#if BIND_git_odb_hashfile_FUNCTION
#define git_odb_hashfile_REQUIRED_ARGC 3
#define git_odb_hashfile_OPTIONAL_ARGC 0
/* git_odb_hashfile
 *
 * Parameters:
 * - out: git_oid *
 * - path: const char *
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_hashfile(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  char * native_path = NULL;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &out, &native_path, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Invocation */
  int native_return_value = git_odb_hashfile(native_out, native_path, native_type);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_new */
/* sha: fcfb30ee55e571afdfb87f9af90872e1776e49f2ae7871773c0c5a47bdbc5b3c */
#if BIND_git_odb_new_FUNCTION
#define git_odb_new_REQUIRED_ARGC 0
#define git_odb_new_OPTIONAL_ARGC 0
/* git_odb_new
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_odb * native_out = NULL;


  /* Invocation */
  int native_return_value = git_odb_new(&native_out);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_num_backends */
/* sha: baac9935e93e63e316c4f2c24b4c7fe671b26747e068859db23f09e89cd822bc */
#if BIND_git_odb_num_backends_FUNCTION
#define git_odb_num_backends_REQUIRED_ARGC 1
#define git_odb_num_backends_OPTIONAL_ARGC 0
/* git_odb_num_backends
 *
 * Parameters:
 * - odb: git_odb *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_odb_num_backends(mrb_state* mrb, mrb_value self) {
  mrb_value odb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &odb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Invocation */
  size_t native_return_value = git_odb_num_backends(native_odb);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_object_data */
/* sha: 442e046b905ea756a96b8b37c3045b21764e8612962eaceba6f0ba41dd34226d */
#if BIND_git_odb_object_data_FUNCTION
#define git_odb_object_data_REQUIRED_ARGC 1
#define git_odb_object_data_OPTIONAL_ARGC 0
/* git_odb_object_data
 *
 * Parameters:
 * - object: git_odb_object *
 * Return Type: const void *
 */
mrb_value
mrb_Git_git_odb_object_data(mrb_state* mrb, mrb_value self) {
  mrb_value object;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &object);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, object, OdbObject_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbObject expected");
    return mrb_nil_value();
  }

  /* Unbox param: object */
  git_odb_object * native_object = (mrb_nil_p(object) ? NULL : mruby_unbox_git_odb_object(object));

  /* Invocation */
  const void * native_return_value = git_odb_object_data(native_object);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_void_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_object_dup */
/* sha: f3476280a0bce289a859b98170a78653c2dece087142baa060080e877c4a61d1 */
#if BIND_git_odb_object_dup_FUNCTION
#define git_odb_object_dup_REQUIRED_ARGC 1
#define git_odb_object_dup_OPTIONAL_ARGC 0
/* git_odb_object_dup
 *
 * Parameters:
 * - source: git_odb_object *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_object_dup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_odb_object * native_dest = NULL;
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, OdbObject_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbObject expected");
    return mrb_nil_value();
  }

  /* Unbox param: source */
  git_odb_object * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox_git_odb_object(source));

  /* Invocation */
  int native_return_value = git_odb_object_dup(&native_dest, native_source);

  /* Box out param: dest */
  mrb_value dest = native_dest == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb_object(mrb, native_dest);

  RAISE_GIT_ERROR(native_return_value);

  return dest;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_object_free */
/* sha: ca0bf73da4f3bb67e279423da438f1bddb2ce2f4e137cde2ee23196542447bd5 */
#if BIND_git_odb_object_free_FUNCTION
#define git_odb_object_free_REQUIRED_ARGC 1
#define git_odb_object_free_OPTIONAL_ARGC 0
/* git_odb_object_free
 *
 * Parameters:
 * - object: git_odb_object *
 * Return Type: void
 */
mrb_value
mrb_Git_git_odb_object_free(mrb_state* mrb, mrb_value self) {
  mrb_value object;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &object);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, object, OdbObject_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbObject expected");
    return mrb_nil_value();
  }

  /* Unbox param: object */
  git_odb_object * native_object = (mrb_nil_p(object) ? NULL : mruby_unbox_git_odb_object(object));

  /* Invocation */
  git_odb_object_free(native_object);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_object_id */
/* sha: 64c653fede90ff3da70e49deb4d2247c0fccb32a3b78aec0ff609244af05fa8b */
#if BIND_git_odb_object_id_FUNCTION
#define git_odb_object_id_REQUIRED_ARGC 1
#define git_odb_object_id_OPTIONAL_ARGC 0
/* git_odb_object_id
 *
 * Parameters:
 * - object: git_odb_object *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_odb_object_id(mrb_state* mrb, mrb_value self) {
  mrb_value object;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &object);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, object, OdbObject_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbObject expected");
    return mrb_nil_value();
  }

  /* Unbox param: object */
  git_odb_object * native_object = (mrb_nil_p(object) ? NULL : mruby_unbox_git_odb_object(object));

  /* Invocation */
  const git_oid * native_return_value = git_odb_object_id(native_object);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_object_size */
/* sha: 95ab40d649d21de94a8201a96545c74f58f373f09b6a7dcaa92fb55d9afbcfb3 */
#if BIND_git_odb_object_size_FUNCTION
#define git_odb_object_size_REQUIRED_ARGC 1
#define git_odb_object_size_OPTIONAL_ARGC 0
/* git_odb_object_size
 *
 * Parameters:
 * - object: git_odb_object *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_odb_object_size(mrb_state* mrb, mrb_value self) {
  mrb_value object;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &object);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, object, OdbObject_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbObject expected");
    return mrb_nil_value();
  }

  /* Unbox param: object */
  git_odb_object * native_object = (mrb_nil_p(object) ? NULL : mruby_unbox_git_odb_object(object));

  /* Invocation */
  size_t native_return_value = git_odb_object_size(native_object);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_object_type */
/* sha: 4ccb87e9a3d8024e083157461dbf44167087476e3e97185c15f044d06c15b9c7 */
#if BIND_git_odb_object_type_FUNCTION
#define git_odb_object_type_REQUIRED_ARGC 1
#define git_odb_object_type_OPTIONAL_ARGC 0
/* git_odb_object_type
 *
 * Parameters:
 * - object: git_odb_object *
 * Return Type: git_otype
 */
mrb_value
mrb_Git_git_odb_object_type(mrb_state* mrb, mrb_value self) {
  mrb_value object;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &object);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, object, OdbObject_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbObject expected");
    return mrb_nil_value();
  }

  /* Unbox param: object */
  git_odb_object * native_object = (mrb_nil_p(object) ? NULL : mruby_unbox_git_odb_object(object));

  /* Invocation */
  git_otype native_return_value = git_odb_object_type(native_object);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_open */
/* sha: e005a68a2af0036e273148c0f94244d1dc5353ffdb74ef29013a673b2614aed0 */
#if BIND_git_odb_open_FUNCTION
#define git_odb_open_REQUIRED_ARGC 1
#define git_odb_open_OPTIONAL_ARGC 0
/* git_odb_open
 *
 * Parameters:
 * - objects_dir: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_open(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_odb * native_out = NULL;
  char * native_objects_dir = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_objects_dir);

  /* Invocation */
  int native_return_value = git_odb_open(&native_out, native_objects_dir);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_open_rstream */
/* sha: 91102457e2ffc5e11065dd9e11f5d4f05dc691b0c203efcd0d1ba7d2fc0067fb */
#if BIND_git_odb_open_rstream_FUNCTION
#define git_odb_open_rstream_REQUIRED_ARGC 2
#define git_odb_open_rstream_OPTIONAL_ARGC 0
/* git_odb_open_rstream
 *
 * Parameters:
 * - db: git_odb *
 * - oid: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_open_rstream(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_odb_stream * native_out = NULL;
  mrb_value db;
  mrb_value oid;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &db, &oid);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, oid, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: oid */
  const git_oid * native_oid = (mrb_nil_p(oid) ? NULL : mruby_unbox_git_oid(oid));

  /* Invocation */
  int native_return_value = git_odb_open_rstream(&native_out, native_db, native_oid);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb_stream(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_open_wstream */
/* sha: 8ec4700f9d1f1c74f8c3e6ee6f6e7c0f5d3be079a0614a254c9d4f3fc20cec4a */
#if BIND_git_odb_open_wstream_FUNCTION
#define git_odb_open_wstream_REQUIRED_ARGC 3
#define git_odb_open_wstream_OPTIONAL_ARGC 0
/* git_odb_open_wstream
 *
 * Parameters:
 * - db: git_odb *
 * - size: git_off_t
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_open_wstream(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_odb_stream * native_out = NULL;
  mrb_value db;
  mrb_int native_size;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &db, &native_size, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Invocation */
  int native_return_value = git_odb_open_wstream(&native_out, native_db, native_size, native_type);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb_stream(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_read */
/* sha: 1aeb1b24c179787ca0710537e7ef82e4f5c3ebd1514b31a9384abb6b5de36c6f */
#if BIND_git_odb_read_FUNCTION
#define git_odb_read_REQUIRED_ARGC 2
#define git_odb_read_OPTIONAL_ARGC 0
/* git_odb_read
 *
 * Parameters:
 * - db: git_odb *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_read(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_odb_object * native_out = NULL;
  mrb_value db;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &db, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_odb_read(&native_out, native_db, native_id);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb_object(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_read_header */
/* sha: b4bf8748b8d13773d2bbb4b1ecee9ebc7819eb38b6087d68d8629ef278d2e0ca */
#if BIND_git_odb_read_header_FUNCTION
#define git_odb_read_header_REQUIRED_ARGC 2
#define git_odb_read_header_OPTIONAL_ARGC 0
/* git_odb_read_header
 *
 * Parameters:
 * - db: git_odb *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_read_header(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value results = mrb_ary_new(mrb);
  int native_len_out;
  int native_type_out;
  mrb_value db;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &db, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_odb_read_header(&native_len_out, &native_type_out, native_db, native_id);

  /* Box out param: len_out */
  mrb_value len_out = mrb_fixnum_value(native_len_out);
  /* Box out param: type_out */
  mrb_value type_out = mrb_fixnum_value(native_type_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, len_out);
  mrb_ary_push(mrb, results, type_out);

  RAISE_GIT_ERROR(native_return_value);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_read_prefix */
/* sha: 47a6cda0197a5b8c7c3da2c423b89ed90599bee9e43b97447664b098c8d284b0 */
#if BIND_git_odb_read_prefix_FUNCTION
#define git_odb_read_prefix_REQUIRED_ARGC 3
#define git_odb_read_prefix_OPTIONAL_ARGC 0
/* git_odb_read_prefix
 *
 * Parameters:
 * - db: git_odb *
 * - short_id: const git_oid *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_read_prefix(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_odb_object * native_out = NULL;
  mrb_value db;
  mrb_value short_id;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &db, &short_id, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, short_id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: short_id */
  const git_oid * native_short_id = (mrb_nil_p(short_id) ? NULL : mruby_unbox_git_oid(short_id));

  /* Invocation */
  int native_return_value = git_odb_read_prefix(&native_out, native_db, native_short_id, native_len);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb_object(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_refresh */
/* sha: baab7cd34a69c280c7003ac61258129b3dac25bba21b6bc02560c117c7809d4a */
#if BIND_git_odb_refresh_FUNCTION
#define git_odb_refresh_REQUIRED_ARGC 1
#define git_odb_refresh_OPTIONAL_ARGC 0
/* git_odb_refresh
 *
 * Parameters:
 * - db: struct git_odb *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_refresh(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value db;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &db);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: db */
  struct git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Invocation */
  int native_return_value = git_odb_refresh(native_db);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_stream_finalize_write */
/* sha: ae7aa6bc49332d76a0d9db1ba776e457378a85eb9f0e2e5b2cc0193577f7cb88 */
#if BIND_git_odb_stream_finalize_write_FUNCTION
#define git_odb_stream_finalize_write_REQUIRED_ARGC 2
#define git_odb_stream_finalize_write_OPTIONAL_ARGC 0
/* git_odb_stream_finalize_write
 *
 * Parameters:
 * - out: git_oid *
 * - stream: git_odb_stream *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_stream_finalize_write(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  mrb_value stream;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &stream);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, stream, OdbStream_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbStream expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: stream */
  git_odb_stream * native_stream = (mrb_nil_p(stream) ? NULL : mruby_unbox_git_odb_stream(stream));

  /* Invocation */
  int native_return_value = git_odb_stream_finalize_write(native_out, native_stream);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_stream_free */
/* sha: e1570153dfc20f29b7fbc1f47d31a0bb51499a60cf30ae80ad65abbb83065b55 */
#if BIND_git_odb_stream_free_FUNCTION
#define git_odb_stream_free_REQUIRED_ARGC 1
#define git_odb_stream_free_OPTIONAL_ARGC 0
/* git_odb_stream_free
 *
 * Parameters:
 * - stream: git_odb_stream *
 * Return Type: void
 */
mrb_value
mrb_Git_git_odb_stream_free(mrb_state* mrb, mrb_value self) {
  mrb_value stream;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &stream);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, stream, OdbStream_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbStream expected");
    return mrb_nil_value();
  }

  /* Unbox param: stream */
  git_odb_stream * native_stream = (mrb_nil_p(stream) ? NULL : mruby_unbox_git_odb_stream(stream));

  /* Invocation */
  git_odb_stream_free(native_stream);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_stream_read */
/* sha: 4c927404bbf20050145d67ab208468046673352c1b369e6beee60674be88a8da */
#if BIND_git_odb_stream_read_FUNCTION
#define git_odb_stream_read_REQUIRED_ARGC 3
#define git_odb_stream_read_OPTIONAL_ARGC 0
/* git_odb_stream_read
 *
 * Parameters:
 * - stream: git_odb_stream *
 * - buffer: char *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_stream_read(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value stream;
  mrb_value buffer;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &stream, &buffer, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, stream, OdbStream_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbStream expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR(buffer);

  /* Unbox param: stream */
  git_odb_stream * native_stream = (mrb_nil_p(stream) ? NULL : mruby_unbox_git_odb_stream(stream));

  /* Unbox param: buffer */
  char * native_buffer = TODO_mruby_unbox_char_PTR(buffer);

  /* Invocation */
  int native_return_value = git_odb_stream_read(native_stream, native_buffer, native_len);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_stream_write */
/* sha: 9ba734dcf1723af3b916ba7359aefa56c0bd629294d015c090c285abdc861b74 */
#if BIND_git_odb_stream_write_FUNCTION
#define git_odb_stream_write_REQUIRED_ARGC 3
#define git_odb_stream_write_OPTIONAL_ARGC 0
/* git_odb_stream_write
 *
 * Parameters:
 * - stream: git_odb_stream *
 * - buffer: const char *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_stream_write(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value stream;
  char * native_buffer = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &stream, &native_buffer, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, stream, OdbStream_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OdbStream expected");
    return mrb_nil_value();
  }

  /* Unbox param: stream */
  git_odb_stream * native_stream = (mrb_nil_p(stream) ? NULL : mruby_unbox_git_odb_stream(stream));

  /* Invocation */
  int native_return_value = git_odb_stream_write(native_stream, native_buffer, native_len);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_write */
/* sha: 9f712dc1d7c79370830ea712316a10147dfb753e3f9ac3338a98d06c0de7aebd */
#if BIND_git_odb_write_FUNCTION
#define git_odb_write_REQUIRED_ARGC 4
#define git_odb_write_OPTIONAL_ARGC 0
/* git_odb_write
 *
 * Parameters:
 * - out: git_oid *
 * - odb: git_odb *
 * - data: const void *
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_write(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  mrb_value odb;
  mrb_value native_data;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "ooSi", &out, &odb, &native_data, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Invocation */
  int native_return_value = git_odb_write(native_out, native_odb, RSTRING_PTR(native_data), RSTRING_LEN(native_data), native_type);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_odb_write_pack */
/* sha: 29602b7fd86fb5cb545bce29c3e561a4e17f07c1927c682f0e3e256c2c38c97b */
#if BIND_git_odb_write_pack_FUNCTION
#define git_odb_write_pack_REQUIRED_ARGC 3
#define git_odb_write_pack_OPTIONAL_ARGC 0
/* git_odb_write_pack
 *
 * Parameters:
 * - db: git_odb *
 * - progress_cb: git_transfer_progress_cb
 * - progress_payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_odb_write_pack(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_odb_writepack * native_out = NULL;
  mrb_value db;
  mrb_value progress_cb;
  mrb_value progress_payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &db, &progress_cb, &progress_payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, db, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_transfer_progress_cb(progress_cb);
  TODO_type_check_void_PTR(progress_payload);

  /* Unbox param: db */
  git_odb * native_db = (mrb_nil_p(db) ? NULL : mruby_unbox_git_odb(db));

  /* Unbox param: progress_cb */
  git_transfer_progress_cb native_progress_cb = TODO_mruby_unbox_git_transfer_progress_cb(progress_cb);

  /* Unbox param: progress_payload */
  void * native_progress_payload = TODO_mruby_unbox_void_PTR(progress_payload);

  /* Invocation */
  int native_return_value = git_odb_write_pack(&native_out, native_db, native_progress_cb, native_progress_payload);

  /* Box out param: out */
  mrb_value out = mruby_box_git_odb_writepack(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_cmp */
/* sha: e6081f769634e15c10e47ac8b7957350df24b1ff41e652025935f82494119f43 */
#if BIND_git_oid_cmp_FUNCTION
#define git_oid_cmp_REQUIRED_ARGC 2
#define git_oid_cmp_OPTIONAL_ARGC 0
/* git_oid_cmp
 *
 * Parameters:
 * - a: const git_oid *
 * - b: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_cmp(mrb_state* mrb, mrb_value self) {
  mrb_value a;
  mrb_value b;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &a, &b);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, a, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, b, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: a */
  const git_oid * native_a = (mrb_nil_p(a) ? NULL : mruby_unbox_git_oid(a));

  /* Unbox param: b */
  const git_oid * native_b = (mrb_nil_p(b) ? NULL : mruby_unbox_git_oid(b));

  /* Invocation */
  int native_return_value = git_oid_cmp(native_a, native_b);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_cpy */
/* sha: a664a4ece1c45869005a235098cb3564ef59a0b0b4e5647070e027d79141eb19 */
#if BIND_git_oid_cpy_FUNCTION
#define git_oid_cpy_REQUIRED_ARGC 2
#define git_oid_cpy_OPTIONAL_ARGC 0
/* git_oid_cpy
 *
 * Parameters:
 * - out: git_oid *
 * - src: const git_oid *
 * Return Type: void
 */
mrb_value
mrb_Git_git_oid_cpy(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value src;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &src);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, src, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: src */
  const git_oid * native_src = (mrb_nil_p(src) ? NULL : mruby_unbox_git_oid(src));

  /* Invocation */
  git_oid_cpy(native_out, native_src);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_equal */
/* sha: 0861fb5a30578c99ebf6ad3cb3ff1067e138c5d34eeb61ee21448c11952140b2 */
#if BIND_git_oid_equal_FUNCTION
#define git_oid_equal_REQUIRED_ARGC 2
#define git_oid_equal_OPTIONAL_ARGC 0
/* git_oid_equal
 *
 * Parameters:
 * - a: const git_oid *
 * - b: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_equal(mrb_state* mrb, mrb_value self) {
  mrb_value a;
  mrb_value b;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &a, &b);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, a, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, b, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: a */
  const git_oid * native_a = (mrb_nil_p(a) ? NULL : mruby_unbox_git_oid(a));

  /* Unbox param: b */
  const git_oid * native_b = (mrb_nil_p(b) ? NULL : mruby_unbox_git_oid(b));

  /* Invocation */
  int native_return_value = git_oid_equal(native_a, native_b);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_fmt */
/* sha: e1c9e85e260eb86bbacffe6fe9777cd52c31a7963cb90e95babecaf568b570b6 */
#if BIND_git_oid_fmt_FUNCTION
#define git_oid_fmt_REQUIRED_ARGC 2
#define git_oid_fmt_OPTIONAL_ARGC 0
/* git_oid_fmt
 *
 * Parameters:
 * - out: char *
 * - id: const git_oid *
 * Return Type: void
 */
mrb_value
mrb_Git_git_oid_fmt(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &id);

  /* Type checking */
  TODO_type_check_char_PTR(out);
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  char * native_out = TODO_mruby_unbox_char_PTR(out);

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  git_oid_fmt(native_out, native_id);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_fromraw */
/* sha: 8bbd663e773875930750a622e55c12b21d7aa2db293fffe5890a83df76b056ac */
#if BIND_git_oid_fromraw_FUNCTION
#define git_oid_fromraw_REQUIRED_ARGC 2
#define git_oid_fromraw_OPTIONAL_ARGC 0
/* git_oid_fromraw
 *
 * Parameters:
 * - out: git_oid *
 * - raw: const unsigned char *
 * Return Type: void
 */
mrb_value
mrb_Git_git_oid_fromraw(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value raw;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &raw);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_char_PTR(raw);

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: raw */
  const unsigned char * native_raw = TODO_mruby_unbox_unsigned_char_PTR(raw);

  /* Invocation */
  git_oid_fromraw(native_out, native_raw);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_fromstr */
/* sha: 2bad8f4b514aa88fd95f491740122068d3e39ff99b22ccb865c37812dcf9f130 */
#if BIND_git_oid_fromstr_FUNCTION
#define git_oid_fromstr_REQUIRED_ARGC 1
#define git_oid_fromstr_OPTIONAL_ARGC 0
/* git_oid_fromstr
 *
 * Parameters:
 * - out: git_oid *
 * - str: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_fromstr(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  char * native_str = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_str);

  /* Invocation */
  git_oid * native_out = (git_oid*)calloc(1, sizeof(git_oid));
  int native_return_value = git_oid_fromstr(native_out, native_str);

  RAISE_GIT_ERROR(native_return_value);

  return mruby_giftwrap_git_oid(mrb, native_out);
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_fromstrn */
/* sha: 97be808d54095cc560ac56c1b06ad7e4568444b8bb0a0b4d9e7ef06399dda2ef */
#if BIND_git_oid_fromstrn_FUNCTION
#define git_oid_fromstrn_REQUIRED_ARGC 3
#define git_oid_fromstrn_OPTIONAL_ARGC 0
/* git_oid_fromstrn
 *
 * Parameters:
 * - out: git_oid *
 * - str: const char *
 * - length: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_fromstrn(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  char * native_str = NULL;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &out, &native_str, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Invocation */
  int native_return_value = git_oid_fromstrn(native_out, native_str, native_length);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_fromstrp */
/* sha: a279a120c7eaab5d17cc5d30b3d6737fdc4d9faa3e076cf20c20c1366a61922b */
#if BIND_git_oid_fromstrp_FUNCTION
#define git_oid_fromstrp_REQUIRED_ARGC 2
#define git_oid_fromstrp_OPTIONAL_ARGC 0
/* git_oid_fromstrp
 *
 * Parameters:
 * - out: git_oid *
 * - str: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_fromstrp(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  char * native_str = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &out, &native_str);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Invocation */
  int native_return_value = git_oid_fromstrp(native_out, native_str);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_iszero */
/* sha: edfe48fd763ce117f55fa995466714344d8707367cc5d1d89726aa49759dc687 */
#if BIND_git_oid_iszero_FUNCTION
#define git_oid_iszero_REQUIRED_ARGC 1
#define git_oid_iszero_OPTIONAL_ARGC 0
/* git_oid_iszero
 *
 * Parameters:
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_iszero(mrb_state* mrb, mrb_value self) {
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_oid_iszero(native_id);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_ncmp */
/* sha: 301d65bfccb5de90d155136f8b0d30370cc3b7788e0281b7b71fca5785df9740 */
#if BIND_git_oid_ncmp_FUNCTION
#define git_oid_ncmp_REQUIRED_ARGC 3
#define git_oid_ncmp_OPTIONAL_ARGC 0
/* git_oid_ncmp
 *
 * Parameters:
 * - a: const git_oid *
 * - b: const git_oid *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_ncmp(mrb_state* mrb, mrb_value self) {
  mrb_value a;
  mrb_value b;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &a, &b, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, a, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, b, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: a */
  const git_oid * native_a = (mrb_nil_p(a) ? NULL : mruby_unbox_git_oid(a));

  /* Unbox param: b */
  const git_oid * native_b = (mrb_nil_p(b) ? NULL : mruby_unbox_git_oid(b));

  /* Invocation */
  int native_return_value = git_oid_ncmp(native_a, native_b, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_nfmt */
/* sha: 8c1cd011c2e321db8a14844cbf90a4fa5c0cf20cf22de8081381e8d3a9b09a56 */
#if BIND_git_oid_nfmt_FUNCTION
#define git_oid_nfmt_REQUIRED_ARGC 3
#define git_oid_nfmt_OPTIONAL_ARGC 0
/* git_oid_nfmt
 *
 * Parameters:
 * - out: char *
 * - n: size_t
 * - id: const git_oid *
 * Return Type: void
 */
mrb_value
mrb_Git_git_oid_nfmt(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_int native_n;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &out, &native_n, &id);

  /* Type checking */
  TODO_type_check_char_PTR(out);
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  char * native_out = TODO_mruby_unbox_char_PTR(out);

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  git_oid_nfmt(native_out, native_n, native_id);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_pathfmt */
/* sha: c1567f6b284628de2b172834a45fa1a3fab665cef942808b3f386af909e12af4 */
#if BIND_git_oid_pathfmt_FUNCTION
#define git_oid_pathfmt_REQUIRED_ARGC 2
#define git_oid_pathfmt_OPTIONAL_ARGC 0
/* git_oid_pathfmt
 *
 * Parameters:
 * - out: char *
 * - id: const git_oid *
 * Return Type: void
 */
mrb_value
mrb_Git_git_oid_pathfmt(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &id);

  /* Type checking */
  TODO_type_check_char_PTR(out);
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  char * native_out = TODO_mruby_unbox_char_PTR(out);

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  git_oid_pathfmt(native_out, native_id);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_shorten_add */
/* sha: f3abfc9f10c0fcb45f1daacf5bee0e16aa4515c3814e9ec366e785fbe6ab4b82 */
#if BIND_git_oid_shorten_add_FUNCTION
#define git_oid_shorten_add_REQUIRED_ARGC 2
#define git_oid_shorten_add_OPTIONAL_ARGC 0
/* git_oid_shorten_add
 *
 * Parameters:
 * - os: git_oid_shorten *
 * - text_id: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_shorten_add(mrb_state* mrb, mrb_value self) {
  mrb_value os;
  char * native_text_id = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &os, &native_text_id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, os, OidShorten_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OidShorten expected");
    return mrb_nil_value();
  }

  /* Unbox param: os */
  git_oid_shorten * native_os = (mrb_nil_p(os) ? NULL : mruby_unbox_git_oid_shorten(os));

  /* Invocation */
  int native_return_value = git_oid_shorten_add(native_os, native_text_id);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_shorten_free */
/* sha: 6fb199cbe6c340b6c0f0b10a34ae19802e566992a86b75b8dce4beae1c1866c1 */
#if BIND_git_oid_shorten_free_FUNCTION
#define git_oid_shorten_free_REQUIRED_ARGC 1
#define git_oid_shorten_free_OPTIONAL_ARGC 0
/* git_oid_shorten_free
 *
 * Parameters:
 * - os: git_oid_shorten *
 * Return Type: void
 */
mrb_value
mrb_Git_git_oid_shorten_free(mrb_state* mrb, mrb_value self) {
  mrb_value os;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &os);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, os, OidShorten_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "OidShorten expected");
    return mrb_nil_value();
  }

  /* Unbox param: os */
  git_oid_shorten * native_os = (mrb_nil_p(os) ? NULL : mruby_unbox_git_oid_shorten(os));

  /* Invocation */
  git_oid_shorten_free(native_os);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_shorten_new */
/* sha: 853ecf5ce92a98333fede8de7f0f59c06bb46f58fce59fa0208fbf2717af09b8 */
#if BIND_git_oid_shorten_new_FUNCTION
#define git_oid_shorten_new_REQUIRED_ARGC 1
#define git_oid_shorten_new_OPTIONAL_ARGC 0
/* git_oid_shorten_new
 *
 * Parameters:
 * - min_length: size_t
 * Return Type: git_oid_shorten *
 */
mrb_value
mrb_Git_git_oid_shorten_new(mrb_state* mrb, mrb_value self) {
  mrb_int native_min_length;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_min_length);

  /* Invocation */
  git_oid_shorten * native_return_value = git_oid_shorten_new(native_min_length);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid_shorten(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_strcmp */
/* sha: b1908cd85711d18bcf772b71976ea194252b97376599f19ab6e1dee9b1b456fc */
#if BIND_git_oid_strcmp_FUNCTION
#define git_oid_strcmp_REQUIRED_ARGC 2
#define git_oid_strcmp_OPTIONAL_ARGC 0
/* git_oid_strcmp
 *
 * Parameters:
 * - id: const git_oid *
 * - str: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_strcmp(mrb_state* mrb, mrb_value self) {
  mrb_value id;
  char * native_str = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &id, &native_str);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_oid_strcmp(native_id, native_str);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_streq */
/* sha: 6de24b67ab7673ac7b8fe5da0c920bdaf8176528d14854f33d22aa6cf1815ea9 */
#if BIND_git_oid_streq_FUNCTION
#define git_oid_streq_REQUIRED_ARGC 2
#define git_oid_streq_OPTIONAL_ARGC 0
/* git_oid_streq
 *
 * Parameters:
 * - id: const git_oid *
 * - str: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_oid_streq(mrb_state* mrb, mrb_value self) {
  mrb_value id;
  char * native_str = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &id, &native_str);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_oid_streq(native_id, native_str);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_tostr */
/* sha: 9b3a40569b07978f1eca44a1cc77d88f304b0b43972d5b44dfe79658aa0b5cb1 */
#if BIND_git_oid_tostr_FUNCTION
#define git_oid_tostr_REQUIRED_ARGC 3
#define git_oid_tostr_OPTIONAL_ARGC 0
/* git_oid_tostr
 *
 * Parameters:
 * - out: char *
 * - n: size_t
 * - id: const git_oid *
 * Return Type: char *
 */
mrb_value
mrb_Git_git_oid_tostr(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_int native_n;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &out, &native_n, &id);

  /* Type checking */
  TODO_type_check_char_PTR(out);
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  char * native_out = TODO_mruby_unbox_char_PTR(out);

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  char * native_return_value = git_oid_tostr(native_out, native_n, native_id);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_char_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oid_tostr_s */
/* sha: 294f6daa9bd7f78340fdfe2e05d0eae804ca4be74ae1afc86149fcf56941d2bf */
#if BIND_git_oid_tostr_s_FUNCTION
#define git_oid_tostr_s_REQUIRED_ARGC 1
#define git_oid_tostr_s_OPTIONAL_ARGC 0
/* git_oid_tostr_s
 *
 * Parameters:
 * - oid: const git_oid *
 * Return Type: char *
 */
mrb_value
mrb_Git_git_oid_tostr_s(mrb_state* mrb, mrb_value self) {
  mrb_value oid;
  mrb_get_args(mrb, "o", &oid);

  if (!mrb_obj_is_kind_of(mrb, oid, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  const git_oid * native_oid = (mrb_nil_p(oid) ? NULL : mruby_unbox_git_oid(oid));

  char * native_return_value = git_oid_tostr_s(native_oid);

  mrb_value return_value = native_return_value ==  NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_oidarray_free */
/* sha: 35c7f747de2e2c384802374182b756b3d3ede52c21d5e69083288f1c3d64e113 */
#if BIND_git_oidarray_free_FUNCTION
#define git_oidarray_free_REQUIRED_ARGC 1
#define git_oidarray_free_OPTIONAL_ARGC 0
/* git_oidarray_free
 *
 * Parameters:
 * - array: git_oidarray *
 * Return Type: void
 */
mrb_value
mrb_Git_git_oidarray_free(mrb_state* mrb, mrb_value self) {
  mrb_value array;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, Oidarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oidarray expected");
    return mrb_nil_value();
  }

  /* Unbox param: array */
  git_oidarray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox_git_oidarray(array));

  /* Invocation */
  git_oidarray_free(native_array);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_foreach */
/* sha: f03213fc0d326cec2f6cd7d62beba7ac49fdc928ae3fd7014fd9343443f209d3 */
#if BIND_git_packbuilder_foreach_FUNCTION
#define git_packbuilder_foreach_REQUIRED_ARGC 3
#define git_packbuilder_foreach_OPTIONAL_ARGC 0
/* git_packbuilder_foreach
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - cb: git_packbuilder_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_foreach(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value pb;
  mrb_value cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &pb, &cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_packbuilder_foreach_cb(cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: cb */
  git_packbuilder_foreach_cb native_cb = TODO_mruby_unbox_git_packbuilder_foreach_cb(cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_packbuilder_foreach(native_pb, native_cb, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_free */
/* sha: 32a3cd8534f8c2d93ef23a7de451cb03cc291c74abd7f5f825aa537986fbd662 */
#if BIND_git_packbuilder_free_FUNCTION
#define git_packbuilder_free_REQUIRED_ARGC 1
#define git_packbuilder_free_OPTIONAL_ARGC 0
/* git_packbuilder_free
 *
 * Parameters:
 * - pb: git_packbuilder *
 * Return Type: void
 */
mrb_value
mrb_Git_git_packbuilder_free(mrb_state* mrb, mrb_value self) {
  mrb_value pb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &pb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Invocation */
  git_packbuilder_free(native_pb);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_hash */
/* sha: 6222b3b3c3dc6d0c75dcd68da5074b30dbcfc5b25d720e5dba15e2d122d52d30 */
#if BIND_git_packbuilder_hash_FUNCTION
#define git_packbuilder_hash_REQUIRED_ARGC 1
#define git_packbuilder_hash_OPTIONAL_ARGC 0
/* git_packbuilder_hash
 *
 * Parameters:
 * - pb: git_packbuilder *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_packbuilder_hash(mrb_state* mrb, mrb_value self) {
  mrb_value pb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &pb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Invocation */
  const git_oid * native_return_value = git_packbuilder_hash(native_pb);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_insert */
/* sha: a39053eca5356c908f2aec2a94bcd57825d0d99ab473214b021ab434a76aa184 */
#if BIND_git_packbuilder_insert_FUNCTION
#define git_packbuilder_insert_REQUIRED_ARGC 3
#define git_packbuilder_insert_OPTIONAL_ARGC 0
/* git_packbuilder_insert
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - id: const git_oid *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_insert(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value pb;
  mrb_value id;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &pb, &id, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_packbuilder_insert(native_pb, native_id, native_name);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_insert_commit */
/* sha: a927aa2d4761ac7db5ee11f9a0d926bd4b05b43f973c72c5bf3cc99da73f4648 */
#if BIND_git_packbuilder_insert_commit_FUNCTION
#define git_packbuilder_insert_commit_REQUIRED_ARGC 2
#define git_packbuilder_insert_commit_OPTIONAL_ARGC 0
/* git_packbuilder_insert_commit
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_insert_commit(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value pb;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &pb, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_packbuilder_insert_commit(native_pb, native_id);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_insert_recur */
/* sha: 2b90bee90fe7961271d661b2df5fbea41ab8531e6160c9dd8af22576eaf1e4cc */
#if BIND_git_packbuilder_insert_recur_FUNCTION
#define git_packbuilder_insert_recur_REQUIRED_ARGC 3
#define git_packbuilder_insert_recur_OPTIONAL_ARGC 0
/* git_packbuilder_insert_recur
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - id: const git_oid *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_insert_recur(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value pb;
  mrb_value id;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &pb, &id, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_packbuilder_insert_recur(native_pb, native_id, native_name);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_insert_tree */
/* sha: 353563d44b232229fe9481d273487db1a2a6758339393c13935a9b9c55d51bea */
#if BIND_git_packbuilder_insert_tree_FUNCTION
#define git_packbuilder_insert_tree_REQUIRED_ARGC 2
#define git_packbuilder_insert_tree_OPTIONAL_ARGC 0
/* git_packbuilder_insert_tree
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_insert_tree(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value pb;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &pb, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_packbuilder_insert_tree(native_pb, native_id);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_insert_walk */
/* sha: 6529e9e6ea797cb9d57a68429739fd78d6e8f93c2d89991e32a003d7940abd6f */
#if BIND_git_packbuilder_insert_walk_FUNCTION
#define git_packbuilder_insert_walk_REQUIRED_ARGC 2
#define git_packbuilder_insert_walk_OPTIONAL_ARGC 0
/* git_packbuilder_insert_walk
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - walk: git_revwalk *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_insert_walk(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value pb;
  mrb_value walk;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &pb, &walk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_packbuilder_insert_walk(native_pb, native_walk);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_new */
/* sha: 471b3f5035f0ac7fed10e3df9ddb8f696c54be65afd9e57ffc2a89fbf5d6e881 */
#if BIND_git_packbuilder_new_FUNCTION
#define git_packbuilder_new_REQUIRED_ARGC 1
#define git_packbuilder_new_OPTIONAL_ARGC 0
/* git_packbuilder_new
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_packbuilder * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_packbuilder_new(&native_out, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_packbuilder(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_object_count */
/* sha: 6fa512ffc813b674dbbf194486d284f6d89a604ff1aa603e244912060ff6566f */
#if BIND_git_packbuilder_object_count_FUNCTION
#define git_packbuilder_object_count_REQUIRED_ARGC 1
#define git_packbuilder_object_count_OPTIONAL_ARGC 0
/* git_packbuilder_object_count
 *
 * Parameters:
 * - pb: git_packbuilder *
 * Return Type: uint32_t
 */
mrb_value
mrb_Git_git_packbuilder_object_count(mrb_state* mrb, mrb_value self) {
  mrb_value pb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &pb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Invocation */
  uint32_t native_return_value = git_packbuilder_object_count(native_pb);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_set_callbacks */
/* sha: d70f8ba58b34152b3a7751bb9f00fe250b42dffc41c653b38fc6cf5752987212 */
#if BIND_git_packbuilder_set_callbacks_FUNCTION
#define git_packbuilder_set_callbacks_REQUIRED_ARGC 3
#define git_packbuilder_set_callbacks_OPTIONAL_ARGC 0
/* git_packbuilder_set_callbacks
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - progress_cb: git_packbuilder_progress
 * - progress_cb_payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_set_callbacks(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value pb;
  mrb_value progress_cb;
  mrb_value progress_cb_payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &pb, &progress_cb, &progress_cb_payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_packbuilder_progress(progress_cb);
  TODO_type_check_void_PTR(progress_cb_payload);

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: progress_cb */
  git_packbuilder_progress native_progress_cb = TODO_mruby_unbox_git_packbuilder_progress(progress_cb);

  /* Unbox param: progress_cb_payload */
  void * native_progress_cb_payload = TODO_mruby_unbox_void_PTR(progress_cb_payload);

  /* Invocation */
  int native_return_value = git_packbuilder_set_callbacks(native_pb, native_progress_cb, native_progress_cb_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_set_threads */
/* sha: ec57b8ddb9882fa7218ce80510133a558538565a45fc1bd814bdf5d59f6f135c */
#if BIND_git_packbuilder_set_threads_FUNCTION
#define git_packbuilder_set_threads_REQUIRED_ARGC 2
#define git_packbuilder_set_threads_OPTIONAL_ARGC 0
/* git_packbuilder_set_threads
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - n: unsigned int
 * Return Type: unsigned int
 */
mrb_value
mrb_Git_git_packbuilder_set_threads(mrb_state* mrb, mrb_value self) {
  mrb_value pb;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &pb, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Invocation */
  unsigned int native_return_value = git_packbuilder_set_threads(native_pb, native_n);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_write */
/* sha: b8c14b106a418eee49fddbc3c87aad027225a6a576bf4683b4c147b58ee70e9e */
#if BIND_git_packbuilder_write_FUNCTION
#define git_packbuilder_write_REQUIRED_ARGC 5
#define git_packbuilder_write_OPTIONAL_ARGC 0
/* git_packbuilder_write
 *
 * Parameters:
 * - pb: git_packbuilder *
 * - path: const char *
 * - mode: unsigned int
 * - progress_cb: git_transfer_progress_cb
 * - progress_cb_payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_write(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value pb;
  char * native_path = NULL;
  mrb_int native_mode;
  mrb_value progress_cb;
  mrb_value progress_cb_payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozioo", &pb, &native_path, &native_mode, &progress_cb, &progress_cb_payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_transfer_progress_cb(progress_cb);
  TODO_type_check_void_PTR(progress_cb_payload);

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Unbox param: progress_cb */
  git_transfer_progress_cb native_progress_cb = TODO_mruby_unbox_git_transfer_progress_cb(progress_cb);

  /* Unbox param: progress_cb_payload */
  void * native_progress_cb_payload = TODO_mruby_unbox_void_PTR(progress_cb_payload);

  /* Invocation */
  int native_return_value = git_packbuilder_write(native_pb, native_path, native_mode, native_progress_cb, native_progress_cb_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_write_buf */
/* sha: 42e6d08fbd4eca6d55b0c8c9969c99d0b7ecf478797c4efd09d6fde4d44b5b9e */
#if BIND_git_packbuilder_write_buf_FUNCTION
#define git_packbuilder_write_buf_REQUIRED_ARGC 2
#define git_packbuilder_write_buf_OPTIONAL_ARGC 0
/* git_packbuilder_write_buf
 *
 * Parameters:
 * - buf: git_buf *
 * - pb: git_packbuilder *
 * Return Type: int
 */
mrb_value
mrb_Git_git_packbuilder_write_buf(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value buf;
  mrb_value pb;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &buf, &pb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, buf, Buf_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Buf expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: buf */
  git_buf * native_buf = mrb_nil_p(buf) ? NULL : mruby_unbox_git_buf(buf);

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Invocation */
  int native_return_value = git_packbuilder_write_buf(native_buf, native_pb);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_packbuilder_written */
/* sha: a47e95eb7336dc43814006c9d5276e974e8d238ccbafa0614043121ceea8aa35 */
#if BIND_git_packbuilder_written_FUNCTION
#define git_packbuilder_written_REQUIRED_ARGC 1
#define git_packbuilder_written_OPTIONAL_ARGC 0
/* git_packbuilder_written
 *
 * Parameters:
 * - pb: git_packbuilder *
 * Return Type: uint32_t
 */
mrb_value
mrb_Git_git_packbuilder_written(mrb_state* mrb, mrb_value self) {
  mrb_value pb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &pb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pb, Packbuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Packbuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: pb */
  git_packbuilder * native_pb = (mrb_nil_p(pb) ? NULL : mruby_unbox_git_packbuilder(pb));

  /* Invocation */
  uint32_t native_return_value = git_packbuilder_written(native_pb);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_free */
/* sha: 76b331b62b1325fbc15c2eb271270dcc2783698d8e9a9181939866c60839592e */
#if BIND_git_patch_free_FUNCTION
#define git_patch_free_REQUIRED_ARGC 1
#define git_patch_free_OPTIONAL_ARGC 0
/* git_patch_free
 *
 * Parameters:
 * - patch: git_patch *
 * Return Type: void
 */
mrb_value
mrb_Git_git_patch_free(mrb_state* mrb, mrb_value self) {
  mrb_value patch;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &patch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  git_patch_free(native_patch);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_from_blob_and_buffer */
/* sha: 504570b459dbeb4ffe38da9879ea26f2a0bdcdca654eee61002a4a30a209e591 */
#if BIND_git_patch_from_blob_and_buffer_FUNCTION
#define git_patch_from_blob_and_buffer_REQUIRED_ARGC 6
#define git_patch_from_blob_and_buffer_OPTIONAL_ARGC 0
/* git_patch_from_blob_and_buffer
 *
 * Parameters:
 * - old_blob: const git_blob *
 * - old_as_path: const char *
 * - buffer: const char *
 * - buffer_len: size_t
 * - buffer_as_path: const char *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_from_blob_and_buffer(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_patch * native_out = NULL;
  mrb_value old_blob;
  char * native_old_as_path = NULL;
  char * native_buffer = NULL;
  mrb_int native_buffer_len;
  char * native_buffer_as_path = NULL;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzizo", &old_blob, &native_old_as_path, &native_buffer, &native_buffer_len, &native_buffer_as_path, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, old_blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: old_blob */
  const git_blob * native_old_blob = (mrb_nil_p(old_blob) ? NULL : mruby_unbox_git_blob(old_blob));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_patch_from_blob_and_buffer(&native_out, native_old_blob, native_old_as_path, native_buffer, native_buffer_len, native_buffer_as_path, native_opts);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_patch(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_from_blobs */
/* sha: fe051a7b18f9503ac7141680052140bc5175962bf96372253eda758beb9169f7 */
#if BIND_git_patch_from_blobs_FUNCTION
#define git_patch_from_blobs_REQUIRED_ARGC 5
#define git_patch_from_blobs_OPTIONAL_ARGC 0
/* git_patch_from_blobs
 *
 * Parameters:
 * - old_blob: const git_blob *
 * - old_as_path: const char *
 * - new_blob: const git_blob *
 * - new_as_path: const char *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_from_blobs(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_patch * native_out = NULL;
  mrb_value old_blob;
  char * native_old_as_path = NULL;
  mrb_value new_blob;
  char * native_new_as_path = NULL;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ozozo", &old_blob, &native_old_as_path, &new_blob, &native_new_as_path, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, old_blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, new_blob, Blob_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Blob expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: old_blob */
  const git_blob * native_old_blob = (mrb_nil_p(old_blob) ? NULL : mruby_unbox_git_blob(old_blob));

  /* Unbox param: new_blob */
  const git_blob * native_new_blob = (mrb_nil_p(new_blob) ? NULL : mruby_unbox_git_blob(new_blob));

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_patch_from_blobs(&native_out, native_old_blob, native_old_as_path, native_new_blob, native_new_as_path, native_opts);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_patch(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_from_buffers */
/* sha: a6d9abe0b868b111ac648003226a18da60caa2de6510c1b9f8c959c6dffdadde */
#if BIND_git_patch_from_buffers_FUNCTION
#define git_patch_from_buffers_REQUIRED_ARGC 7
#define git_patch_from_buffers_OPTIONAL_ARGC 0
/* git_patch_from_buffers
 *
 * Parameters:
 * - old_buffer: const void *
 * - old_len: size_t
 * - old_as_path: const char *
 * - new_buffer: const char *
 * - new_len: size_t
 * - new_as_path: const char *
 * - opts: const git_diff_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_from_buffers(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_patch * native_out = NULL;
  mrb_value old_buffer;
  mrb_int native_old_len;
  char * native_old_as_path = NULL;
  char * native_new_buffer = NULL;
  mrb_int native_new_len;
  char * native_new_as_path = NULL;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oizzizo", &old_buffer, &native_old_len, &native_old_as_path, &native_new_buffer, &native_new_len, &native_new_as_path, &opts);

  /* Type checking */
  TODO_type_check_void_PTR(old_buffer);
  if (!mrb_obj_is_kind_of(mrb, opts, DiffOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "DiffOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: old_buffer */
  const void * native_old_buffer = TODO_mruby_unbox_void_PTR(old_buffer);

  /* Unbox param: opts */
  const git_diff_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_diff_options(opts));

  /* Invocation */
  int native_return_value = git_patch_from_buffers(&native_out, native_old_buffer, native_old_len, native_old_as_path, native_new_buffer, native_new_len, native_new_as_path, native_opts);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_patch(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_from_diff */
/* sha: dde1c69413e3d5ce4649c381afdc5f99a15a79ed34e4e1f9a92cf641acef4047 */
#if BIND_git_patch_from_diff_FUNCTION
#define git_patch_from_diff_REQUIRED_ARGC 2
#define git_patch_from_diff_OPTIONAL_ARGC 0
/* git_patch_from_diff
 *
 * Parameters:
 * - diff: git_diff *
 * - idx: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_from_diff(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_patch * native_out = NULL;
  mrb_value diff;
  mrb_int native_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &diff, &native_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Invocation */
  int native_return_value = git_patch_from_diff(&native_out, native_diff, native_idx);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_patch(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_get_delta */
/* sha: 69d50173badee25fc3d2380acd154dfa1832401385aa745c89e2915aaf8299bf */
#if BIND_git_patch_get_delta_FUNCTION
#define git_patch_get_delta_REQUIRED_ARGC 1
#define git_patch_get_delta_OPTIONAL_ARGC 0
/* git_patch_get_delta
 *
 * Parameters:
 * - patch: const git_patch *
 * Return Type: const git_diff_delta *
 */
mrb_value
mrb_Git_git_patch_get_delta(mrb_state* mrb, mrb_value self) {
  mrb_value patch;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &patch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  const git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  const git_diff_delta * native_return_value = git_patch_get_delta(native_patch);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_diff_delta(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_get_hunk */
/* sha: 6eb4cef3d2ddfd94ecde1994faa35624a396e0152774051906566c32317ac2c7 */
#if BIND_git_patch_get_hunk_FUNCTION
#define git_patch_get_hunk_REQUIRED_ARGC 2
#define git_patch_get_hunk_OPTIONAL_ARGC 0
/* git_patch_get_hunk
 *
 * Parameters:
 * - patch: git_patch *
 * - hunk_idx: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_get_hunk(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value results = mrb_ary_new(mrb);
  git_diff_hunk * native_out = NULL;
  int native_lines_in_hunk;
  mrb_value patch;
  mrb_int native_hunk_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &patch, &native_hunk_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  int native_return_value = git_patch_get_hunk(&native_out, &native_lines_in_hunk, native_patch, native_hunk_idx);

  /* Box out param: out */
  mrb_value out = mruby_box_git_diff_hunk(mrb, native_out);
  /* Box out param: lines_in_hunk */
  mrb_value lines_in_hunk = mrb_fixnum_value(native_lines_in_hunk);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);
  mrb_ary_push(mrb, results, lines_in_hunk);

  RAISE_GIT_ERROR(native_return_value);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_get_line_in_hunk */
/* sha: 20985ef732153f085cb9046bfe5114461ece2ece6995f6cb389af18dc526ef0f */
#if BIND_git_patch_get_line_in_hunk_FUNCTION
#define git_patch_get_line_in_hunk_REQUIRED_ARGC 3
#define git_patch_get_line_in_hunk_OPTIONAL_ARGC 0
/* git_patch_get_line_in_hunk
 *
 * Parameters:
 * - patch: git_patch *
 * - hunk_idx: size_t
 * - line_of_hunk: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_get_line_in_hunk(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_diff_line * native_out = NULL;
  mrb_value patch;
  mrb_int native_hunk_idx;
  mrb_int native_line_of_hunk;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &patch, &native_hunk_idx, &native_line_of_hunk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  int native_return_value = git_patch_get_line_in_hunk(&native_out, native_patch, native_hunk_idx, native_line_of_hunk);

  /* Box out param: out */
  mrb_value out = mruby_box_git_diff_line(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_line_stats */
/* sha: 77c4c1d5eac483f8047ffaae653c40735948e707fe72baa4a3d814b71ebec746 */
#if BIND_git_patch_line_stats_FUNCTION
#define git_patch_line_stats_REQUIRED_ARGC 1
#define git_patch_line_stats_OPTIONAL_ARGC 0
/* git_patch_line_stats
 *
 * Parameters:
 * - patch: const git_patch *
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_line_stats(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value results = mrb_ary_new(mrb);
  int native_total_context;
  int native_total_additions;
  int native_total_deletions;
  mrb_value patch;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &patch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  const git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  int native_return_value = git_patch_line_stats(&native_total_context, &native_total_additions, &native_total_deletions, native_patch);

  /* Box out param: total_context */
  mrb_value total_context = mrb_fixnum_value(native_total_context);
  /* Box out param: total_additions */
  mrb_value total_additions = mrb_fixnum_value(native_total_additions);
  /* Box out param: total_deletions */
  mrb_value total_deletions = mrb_fixnum_value(native_total_deletions);

  /* Add out params to results */
  mrb_ary_push(mrb, results, total_context);
  mrb_ary_push(mrb, results, total_additions);
  mrb_ary_push(mrb, results, total_deletions);

  RAISE_GIT_ERROR(native_return_value);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_num_hunks */
/* sha: af6d6afaa094c0a712fb0ca2d281866c908ce19851b490353d0aa03110c2dd6e */
#if BIND_git_patch_num_hunks_FUNCTION
#define git_patch_num_hunks_REQUIRED_ARGC 1
#define git_patch_num_hunks_OPTIONAL_ARGC 0
/* git_patch_num_hunks
 *
 * Parameters:
 * - patch: const git_patch *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_patch_num_hunks(mrb_state* mrb, mrb_value self) {
  mrb_value patch;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &patch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  const git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  size_t native_return_value = git_patch_num_hunks(native_patch);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_num_lines_in_hunk */
/* sha: 2d845dce6aeb876e7759b5aabca752dccb82af9589ce413f7afc7797097cf3b0 */
#if BIND_git_patch_num_lines_in_hunk_FUNCTION
#define git_patch_num_lines_in_hunk_REQUIRED_ARGC 2
#define git_patch_num_lines_in_hunk_OPTIONAL_ARGC 0
/* git_patch_num_lines_in_hunk
 *
 * Parameters:
 * - patch: const git_patch *
 * - hunk_idx: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_num_lines_in_hunk(mrb_state* mrb, mrb_value self) {
  mrb_value patch;
  mrb_int native_hunk_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &patch, &native_hunk_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  const git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  int native_return_value = git_patch_num_lines_in_hunk(native_patch, native_hunk_idx);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_print */
/* sha: 71d057c403289837cd98959eac494485055d3aebdd3ce427a08168baa7462978 */
#if BIND_git_patch_print_FUNCTION
#define git_patch_print_REQUIRED_ARGC 3
#define git_patch_print_OPTIONAL_ARGC 0
/* git_patch_print
 *
 * Parameters:
 * - patch: git_patch *
 * - print_cb: git_diff_line_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_print(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value patch;
  mrb_value print_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &patch, &print_cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_diff_line_cb(print_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: patch */
  git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Unbox param: print_cb */
  git_diff_line_cb native_print_cb = TODO_mruby_unbox_git_diff_line_cb(print_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_patch_print(native_patch, native_print_cb, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_size */
/* sha: f7c61742d6a34a841ac8cd2c2177406c87244000b46dbb44a14a3483f0857bc5 */
#if BIND_git_patch_size_FUNCTION
#define git_patch_size_REQUIRED_ARGC 4
#define git_patch_size_OPTIONAL_ARGC 0
/* git_patch_size
 *
 * Parameters:
 * - patch: git_patch *
 * - include_context: int
 * - include_hunk_headers: int
 * - include_file_headers: int
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_patch_size(mrb_state* mrb, mrb_value self) {
  mrb_value patch;
  mrb_int native_include_context;
  mrb_int native_include_hunk_headers;
  mrb_int native_include_file_headers;

  /* Fetch the args */
  mrb_get_args(mrb, "oiii", &patch, &native_include_context, &native_include_hunk_headers, &native_include_file_headers);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  size_t native_return_value = git_patch_size(native_patch, native_include_context, native_include_hunk_headers, native_include_file_headers);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_patch_to_buf */
/* sha: 57820b248e9cd884f390abfcd398f8d0f7ddeb6b734166848936294f0d19db2f */
#if BIND_git_patch_to_buf_FUNCTION
#define git_patch_to_buf_REQUIRED_ARGC 1
#define git_patch_to_buf_OPTIONAL_ARGC 0
/* git_patch_to_buf
 *
 * Parameters:
 * - patch: git_patch *
 * Return Type: int
 */
mrb_value
mrb_Git_git_patch_to_buf(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value patch;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &patch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, patch, Patch_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Patch expected");
    return mrb_nil_value();
  }

  /* Unbox param: patch */
  git_patch * native_patch = (mrb_nil_p(patch) ? NULL : mruby_unbox_git_patch(patch));

  /* Invocation */
  int native_return_value = git_patch_to_buf(native_out, native_patch);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_free */
/* sha: bf3ff835398fe96c7c0bdb57ce8fd45b632bf53a3e803c97c42251e35a4ea225 */
#if BIND_git_pathspec_free_FUNCTION
#define git_pathspec_free_REQUIRED_ARGC 1
#define git_pathspec_free_OPTIONAL_ARGC 0
/* git_pathspec_free
 *
 * Parameters:
 * - ps: git_pathspec *
 * Return Type: void
 */
mrb_value
mrb_Git_git_pathspec_free(mrb_state* mrb, mrb_value self) {
  mrb_value ps;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ps);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ps, Pathspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Pathspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: ps */
  git_pathspec * native_ps = (mrb_nil_p(ps) ? NULL : mruby_unbox_git_pathspec(ps));

  /* Invocation */
  git_pathspec_free(native_ps);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_diff */
/* sha: d18d1ca95718b7d896dde4343497c6a9ffe8f8634d1cbb3ab80395339e0622f9 */
#if BIND_git_pathspec_match_diff_FUNCTION
#define git_pathspec_match_diff_REQUIRED_ARGC 3
#define git_pathspec_match_diff_OPTIONAL_ARGC 0
/* git_pathspec_match_diff
 *
 * Parameters:
 * - diff: git_diff *
 * - flags: uint32_t
 * - ps: git_pathspec *
 * Return Type: int
 */
mrb_value
mrb_Git_git_pathspec_match_diff(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_pathspec_match_list * native_out = NULL;
  mrb_value diff;
  mrb_int native_flags;
  mrb_value ps;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &diff, &native_flags, &ps);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, diff, Diff_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Diff expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ps, Pathspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Pathspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: diff */
  git_diff * native_diff = (mrb_nil_p(diff) ? NULL : mruby_unbox_git_diff(diff));

  /* Unbox param: ps */
  git_pathspec * native_ps = (mrb_nil_p(ps) ? NULL : mruby_unbox_git_pathspec(ps));

  /* Invocation */
  int native_return_value = git_pathspec_match_diff(&native_out, native_diff, native_flags, native_ps);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_pathspec_match_list(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_index */
/* sha: 3c07cb5b5c4400b9c32059b1df850cd1c79a1bfd9937345ca18b12a3ee359e8f */
#if BIND_git_pathspec_match_index_FUNCTION
#define git_pathspec_match_index_REQUIRED_ARGC 3
#define git_pathspec_match_index_OPTIONAL_ARGC 0
/* git_pathspec_match_index
 *
 * Parameters:
 * - index: git_index *
 * - flags: uint32_t
 * - ps: git_pathspec *
 * Return Type: int
 */
mrb_value
mrb_Git_git_pathspec_match_index(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_pathspec_match_list * native_out = NULL;
  mrb_value index;
  mrb_int native_flags;
  mrb_value ps;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &index, &native_flags, &ps);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, index, Index_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Index expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ps, Pathspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Pathspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: index */
  git_index * native_index = (mrb_nil_p(index) ? NULL : mruby_unbox_git_index(index));

  /* Unbox param: ps */
  git_pathspec * native_ps = (mrb_nil_p(ps) ? NULL : mruby_unbox_git_pathspec(ps));

  /* Invocation */
  int native_return_value = git_pathspec_match_index(&native_out, native_index, native_flags, native_ps);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_pathspec_match_list(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_list_diff_entry */
/* sha: fc7b30138a3fc0a822d5066bc847bdda309de111d00c22405841e2e3c9a96871 */
#if BIND_git_pathspec_match_list_diff_entry_FUNCTION
#define git_pathspec_match_list_diff_entry_REQUIRED_ARGC 2
#define git_pathspec_match_list_diff_entry_OPTIONAL_ARGC 0
/* git_pathspec_match_list_diff_entry
 *
 * Parameters:
 * - m: const git_pathspec_match_list *
 * - pos: size_t
 * Return Type: const git_diff_delta *
 */
mrb_value
mrb_Git_git_pathspec_match_list_diff_entry(mrb_state* mrb, mrb_value self) {
  mrb_value m;
  mrb_int native_pos;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &m, &native_pos);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, m, PathspecMatchList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PathspecMatchList expected");
    return mrb_nil_value();
  }

  /* Unbox param: m */
  const git_pathspec_match_list * native_m = (mrb_nil_p(m) ? NULL : mruby_unbox_git_pathspec_match_list(m));

  /* Invocation */
  const git_diff_delta * native_return_value = git_pathspec_match_list_diff_entry(native_m, native_pos);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_diff_delta(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_list_entry */
/* sha: f0778e6d53e08a312b8010e4ae0aedf79a5edfbfdac1dcf343af1154f4bac404 */
#if BIND_git_pathspec_match_list_entry_FUNCTION
#define git_pathspec_match_list_entry_REQUIRED_ARGC 2
#define git_pathspec_match_list_entry_OPTIONAL_ARGC 0
/* git_pathspec_match_list_entry
 *
 * Parameters:
 * - m: const git_pathspec_match_list *
 * - pos: size_t
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_pathspec_match_list_entry(mrb_state* mrb, mrb_value self) {
  mrb_value m;
  mrb_int native_pos;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &m, &native_pos);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, m, PathspecMatchList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PathspecMatchList expected");
    return mrb_nil_value();
  }

  /* Unbox param: m */
  const git_pathspec_match_list * native_m = (mrb_nil_p(m) ? NULL : mruby_unbox_git_pathspec_match_list(m));

  /* Invocation */
  const char * native_return_value = git_pathspec_match_list_entry(native_m, native_pos);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_list_entrycount */
/* sha: 9a1c9400b752a1f614104799c72ca48eab7f99cdc156980a17d0bf7534179d00 */
#if BIND_git_pathspec_match_list_entrycount_FUNCTION
#define git_pathspec_match_list_entrycount_REQUIRED_ARGC 1
#define git_pathspec_match_list_entrycount_OPTIONAL_ARGC 0
/* git_pathspec_match_list_entrycount
 *
 * Parameters:
 * - m: const git_pathspec_match_list *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_pathspec_match_list_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value m;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &m);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, m, PathspecMatchList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PathspecMatchList expected");
    return mrb_nil_value();
  }

  /* Unbox param: m */
  const git_pathspec_match_list * native_m = (mrb_nil_p(m) ? NULL : mruby_unbox_git_pathspec_match_list(m));

  /* Invocation */
  size_t native_return_value = git_pathspec_match_list_entrycount(native_m);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_list_failed_entry */
/* sha: b22ddb1f7f2b98e98ff0c4e483365ca60447bff1d9edc4bc6d0f9174a20cf8b6 */
#if BIND_git_pathspec_match_list_failed_entry_FUNCTION
#define git_pathspec_match_list_failed_entry_REQUIRED_ARGC 2
#define git_pathspec_match_list_failed_entry_OPTIONAL_ARGC 0
/* git_pathspec_match_list_failed_entry
 *
 * Parameters:
 * - m: const git_pathspec_match_list *
 * - pos: size_t
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_pathspec_match_list_failed_entry(mrb_state* mrb, mrb_value self) {
  mrb_value m;
  mrb_int native_pos;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &m, &native_pos);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, m, PathspecMatchList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PathspecMatchList expected");
    return mrb_nil_value();
  }

  /* Unbox param: m */
  const git_pathspec_match_list * native_m = (mrb_nil_p(m) ? NULL : mruby_unbox_git_pathspec_match_list(m));

  /* Invocation */
  const char * native_return_value = git_pathspec_match_list_failed_entry(native_m, native_pos);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_list_failed_entrycount */
/* sha: 182266ff44d509afe74eb66b5d4ceb20302faad82592b2c12d16262e2c73f2e5 */
#if BIND_git_pathspec_match_list_failed_entrycount_FUNCTION
#define git_pathspec_match_list_failed_entrycount_REQUIRED_ARGC 1
#define git_pathspec_match_list_failed_entrycount_OPTIONAL_ARGC 0
/* git_pathspec_match_list_failed_entrycount
 *
 * Parameters:
 * - m: const git_pathspec_match_list *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_pathspec_match_list_failed_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value m;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &m);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, m, PathspecMatchList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PathspecMatchList expected");
    return mrb_nil_value();
  }

  /* Unbox param: m */
  const git_pathspec_match_list * native_m = (mrb_nil_p(m) ? NULL : mruby_unbox_git_pathspec_match_list(m));

  /* Invocation */
  size_t native_return_value = git_pathspec_match_list_failed_entrycount(native_m);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_list_free */
/* sha: 9f679386a147294278d80c0855213b49909f48a45ca76c2265d16a446e15ebdd */
#if BIND_git_pathspec_match_list_free_FUNCTION
#define git_pathspec_match_list_free_REQUIRED_ARGC 1
#define git_pathspec_match_list_free_OPTIONAL_ARGC 0
/* git_pathspec_match_list_free
 *
 * Parameters:
 * - m: git_pathspec_match_list *
 * Return Type: void
 */
mrb_value
mrb_Git_git_pathspec_match_list_free(mrb_state* mrb, mrb_value self) {
  mrb_value m;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &m);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, m, PathspecMatchList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PathspecMatchList expected");
    return mrb_nil_value();
  }

  /* Unbox param: m */
  git_pathspec_match_list * native_m = (mrb_nil_p(m) ? NULL : mruby_unbox_git_pathspec_match_list(m));

  /* Invocation */
  git_pathspec_match_list_free(native_m);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_tree */
/* sha: c1c1a950510ecb7aece30ac9ad04441de31359fb34f9f1cb974a01c4c8d112d4 */
#if BIND_git_pathspec_match_tree_FUNCTION
#define git_pathspec_match_tree_REQUIRED_ARGC 3
#define git_pathspec_match_tree_OPTIONAL_ARGC 0
/* git_pathspec_match_tree
 *
 * Parameters:
 * - tree: git_tree *
 * - flags: uint32_t
 * - ps: git_pathspec *
 * Return Type: int
 */
mrb_value
mrb_Git_git_pathspec_match_tree(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_pathspec_match_list * native_out = NULL;
  mrb_value tree;
  mrb_int native_flags;
  mrb_value ps;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &tree, &native_flags, &ps);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ps, Pathspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Pathspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Unbox param: ps */
  git_pathspec * native_ps = (mrb_nil_p(ps) ? NULL : mruby_unbox_git_pathspec(ps));

  /* Invocation */
  int native_return_value = git_pathspec_match_tree(&native_out, native_tree, native_flags, native_ps);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_pathspec_match_list(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_match_workdir */
/* sha: 2910272e4d6a1bfc0a18894bf13fb73e4bbd73f3a092639f72efc6172e4160e7 */
#if BIND_git_pathspec_match_workdir_FUNCTION
#define git_pathspec_match_workdir_REQUIRED_ARGC 3
#define git_pathspec_match_workdir_OPTIONAL_ARGC 0
/* git_pathspec_match_workdir
 *
 * Parameters:
 * - repo: git_repository *
 * - flags: uint32_t
 * - ps: git_pathspec *
 * Return Type: int
 */
mrb_value
mrb_Git_git_pathspec_match_workdir(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_pathspec_match_list * native_out = NULL;
  mrb_value repo;
  mrb_int native_flags;
  mrb_value ps;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &repo, &native_flags, &ps);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ps, Pathspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Pathspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: ps */
  git_pathspec * native_ps = (mrb_nil_p(ps) ? NULL : mruby_unbox_git_pathspec(ps));

  /* Invocation */
  int native_return_value = git_pathspec_match_workdir(&native_out, native_repo, native_flags, native_ps);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_pathspec_match_list(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_matches_path */
/* sha: 3cd416aeec5b9ddf4164f7f263fd2fa86475bebf76dbeb62156f023f25d3ae98 */
#if BIND_git_pathspec_matches_path_FUNCTION
#define git_pathspec_matches_path_REQUIRED_ARGC 3
#define git_pathspec_matches_path_OPTIONAL_ARGC 0
/* git_pathspec_matches_path
 *
 * Parameters:
 * - ps: const git_pathspec *
 * - flags: uint32_t
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_pathspec_matches_path(mrb_state* mrb, mrb_value self) {
  mrb_value ps;
  mrb_int native_flags;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oiz", &ps, &native_flags, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ps, Pathspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Pathspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: ps */
  const git_pathspec * native_ps = (mrb_nil_p(ps) ? NULL : mruby_unbox_git_pathspec(ps));

  /* Invocation */
  int native_return_value = git_pathspec_matches_path(native_ps, native_flags, native_path);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_pathspec_new */
/* sha: d178006081a084d4eb16f8cf2d156e4ac745ebf7822063c67b318b3714da6b9a */
#if BIND_git_pathspec_new_FUNCTION
#define git_pathspec_new_REQUIRED_ARGC 1
#define git_pathspec_new_OPTIONAL_ARGC 0
/* git_pathspec_new
 *
 * Parameters:
 * - pathspec: const git_strarray *
 * Return Type: int
 */
mrb_value
mrb_Git_git_pathspec_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_pathspec * native_out = NULL;
  mrb_value pathspec;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &pathspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pathspec, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }

  /* Unbox param: pathspec */
  const git_strarray * native_pathspec = (mrb_nil_p(pathspec) ? NULL : mruby_unbox_git_strarray(pathspec));

  /* Invocation */
  int native_return_value = git_pathspec_new(&native_out, native_pathspec);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_pathspec(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_push_init_options */
/* sha: 9a81b26781e90ac4fdf73022817d5b09e944dba9504f55105eb585b4fdf78d17 */
#if BIND_git_push_init_options_FUNCTION
#define git_push_init_options_REQUIRED_ARGC 2
#define git_push_init_options_OPTIONAL_ARGC 0
/* git_push_init_options
 *
 * Parameters:
 * - opts: git_push_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_push_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, PushOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PushOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_push_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_push_options(opts));

  /* Invocation */
  int native_return_value = git_push_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_abort */
/* sha: 6e00e217e07bb7039dbebaa280908a3afa10e4887692015c324c85dbe3fe703f */
#if BIND_git_rebase_abort_FUNCTION
#define git_rebase_abort_REQUIRED_ARGC 1
#define git_rebase_abort_OPTIONAL_ARGC 0
/* git_rebase_abort
 *
 * Parameters:
 * - rebase: git_rebase *
 * Return Type: int
 */
mrb_value
mrb_Git_git_rebase_abort(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value rebase;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rebase);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Invocation */
  int native_return_value = git_rebase_abort(native_rebase);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_commit */
/* sha: 9485e7e6ebda83f628d22c1bf63ac329e602836fb62e73b4bd3f5362f3885104 */
#if BIND_git_rebase_commit_FUNCTION
#define git_rebase_commit_REQUIRED_ARGC 6
#define git_rebase_commit_OPTIONAL_ARGC 0
/* git_rebase_commit
 *
 * Parameters:
 * - id: git_oid *
 * - rebase: git_rebase *
 * - author: const git_signature *
 * - committer: const git_signature *
 * - message_encoding: const char *
 * - message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_rebase_commit(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value id;
  mrb_value rebase;
  mrb_value author;
  mrb_value committer;
  char * native_message_encoding = NULL;
  char * native_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oooozz", &id, &rebase, &author, &committer, &native_message_encoding, &native_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, author, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, committer, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: id */
  git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Unbox param: author */
  const git_signature * native_author = (mrb_nil_p(author) ? NULL : mruby_unbox_git_signature(author));

  /* Unbox param: committer */
  const git_signature * native_committer = (mrb_nil_p(committer) ? NULL : mruby_unbox_git_signature(committer));

  /* Invocation */
  int native_return_value = git_rebase_commit(native_id, native_rebase, native_author, native_committer, native_message_encoding, native_message);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_finish */
/* sha: 6db2d6b963aefdceaafdbbad62cadc92ec50df7aebab2af10e041ea88b6c6756 */
#if BIND_git_rebase_finish_FUNCTION
#define git_rebase_finish_REQUIRED_ARGC 2
#define git_rebase_finish_OPTIONAL_ARGC 0
/* git_rebase_finish
 *
 * Parameters:
 * - rebase: git_rebase *
 * - signature: const git_signature *
 * Return Type: int
 */
mrb_value
mrb_Git_git_rebase_finish(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value rebase;
  mrb_value signature;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &rebase, &signature);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, signature, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Unbox param: signature */
  const git_signature * native_signature = (mrb_nil_p(signature) ? NULL : mruby_unbox_git_signature(signature));

  /* Invocation */
  int native_return_value = git_rebase_finish(native_rebase, native_signature);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_free */
/* sha: aac40d5a7b183951a5d66d35a3c197e654487fee9c4995352442bc99cedc5399 */
#if BIND_git_rebase_free_FUNCTION
#define git_rebase_free_REQUIRED_ARGC 1
#define git_rebase_free_OPTIONAL_ARGC 0
/* git_rebase_free
 *
 * Parameters:
 * - rebase: git_rebase *
 * Return Type: void
 */
mrb_value
mrb_Git_git_rebase_free(mrb_state* mrb, mrb_value self) {
  mrb_value rebase;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rebase);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Invocation */
  git_rebase_free(native_rebase);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_init */
/* sha: ce1d5d249a6fd79f54b032abcd7856795131eb594ef699b0490fe71ced3ec9a5 */
#if BIND_git_rebase_init_FUNCTION
#define git_rebase_init_REQUIRED_ARGC 5
#define git_rebase_init_OPTIONAL_ARGC 0
/* git_rebase_init
 *
 * Parameters:
 * - repo: git_repository *
 * - branch: const git_annotated_commit *
 * - upstream: const git_annotated_commit *
 * - onto: const git_annotated_commit *
 * - opts: const git_rebase_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_rebase_init(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_rebase * native_out = NULL;
  mrb_value repo;
  mrb_value branch;
  mrb_value upstream;
  mrb_value onto;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooooo", &repo, &branch, &upstream, &onto, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, branch, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, upstream, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, onto, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, RebaseOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RebaseOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: branch */
  const git_annotated_commit * native_branch = (mrb_nil_p(branch) ? NULL : mruby_unbox_git_annotated_commit(branch));

  /* Unbox param: upstream */
  const git_annotated_commit * native_upstream = (mrb_nil_p(upstream) ? NULL : mruby_unbox_git_annotated_commit(upstream));

  /* Unbox param: onto */
  const git_annotated_commit * native_onto = (mrb_nil_p(onto) ? NULL : mruby_unbox_git_annotated_commit(onto));

  /* Unbox param: opts */
  const git_rebase_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_rebase_options(opts));

  /* Invocation */
  int native_return_value = git_rebase_init(&native_out, native_repo, native_branch, native_upstream, native_onto, native_opts);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_rebase(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_init_options */
/* sha: 2022887a9857a2833c9970a160c9878980bf0643e61f68a5a01b3060214babcb */
#if BIND_git_rebase_init_options_FUNCTION
#define git_rebase_init_options_REQUIRED_ARGC 2
#define git_rebase_init_options_OPTIONAL_ARGC 0
/* git_rebase_init_options
 *
 * Parameters:
 * - opts: git_rebase_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_rebase_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, RebaseOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RebaseOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_rebase_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_rebase_options(opts));

  /* Invocation */
  int native_return_value = git_rebase_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_next */
/* sha: e04ca5d5595aae1e8e8cf400fefdca2716f5b01d5e6a33cc407a571d7a7a39c0 */
#if BIND_git_rebase_next_FUNCTION
#define git_rebase_next_REQUIRED_ARGC 1
#define git_rebase_next_OPTIONAL_ARGC 0
/* git_rebase_next
 *
 * Parameters:
 * - rebase: git_rebase *
 * Return Type: int
 */
mrb_value
mrb_Git_git_rebase_next(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_rebase_operation * native_operation = NULL;
  mrb_value rebase;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rebase);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Invocation */
  int native_return_value = git_rebase_next(&native_operation, native_rebase);

  /* Box out param: operation */
  mrb_value operation = mruby_box_git_rebase_operation(mrb, native_operation);

  RAISE_GIT_ERROR(native_return_value);

  return operation;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_open */
/* sha: 13f32a2a747b0a80bdc980848110a0a8f53e4d044749f7a662e7d078eef0a2f8 */
#if BIND_git_rebase_open_FUNCTION
#define git_rebase_open_REQUIRED_ARGC 2
#define git_rebase_open_OPTIONAL_ARGC 0
/* git_rebase_open
 *
 * Parameters:
 * - repo: git_repository *
 * - opts: const git_rebase_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_rebase_open(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_rebase * native_out = NULL;
  mrb_value repo;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, RebaseOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RebaseOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: opts */
  const git_rebase_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_rebase_options(opts));

  /* Invocation */
  int native_return_value = git_rebase_open(&native_out, native_repo, native_opts);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_rebase(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_operation_byindex */
/* sha: ec0fc1bec5d09da32f2b12e0ed5323eb8e0864f17a3afe46ca82e040520c17cc */
#if BIND_git_rebase_operation_byindex_FUNCTION
#define git_rebase_operation_byindex_REQUIRED_ARGC 2
#define git_rebase_operation_byindex_OPTIONAL_ARGC 0
/* git_rebase_operation_byindex
 *
 * Parameters:
 * - rebase: git_rebase *
 * - idx: size_t
 * Return Type: git_rebase_operation *
 */
mrb_value
mrb_Git_git_rebase_operation_byindex(mrb_state* mrb, mrb_value self) {
  mrb_value rebase;
  mrb_int native_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &rebase, &native_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Invocation */
  git_rebase_operation * native_return_value = git_rebase_operation_byindex(native_rebase, native_idx);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_rebase_operation(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_operation_current */
/* sha: cf6162c1a9d45cded86d10b42c7c31b86d61f512f4cd723da45745b58f8dc5ec */
#if BIND_git_rebase_operation_current_FUNCTION
#define git_rebase_operation_current_REQUIRED_ARGC 1
#define git_rebase_operation_current_OPTIONAL_ARGC 0
/* git_rebase_operation_current
 *
 * Parameters:
 * - rebase: git_rebase *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_rebase_operation_current(mrb_state* mrb, mrb_value self) {
  mrb_value rebase;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rebase);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Invocation */
  size_t native_return_value = git_rebase_operation_current(native_rebase);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_rebase_operation_entrycount */
/* sha: ffc4e655dee236c79089d4c558577f9e750a3036b39f843b6da671706db6afa1 */
#if BIND_git_rebase_operation_entrycount_FUNCTION
#define git_rebase_operation_entrycount_REQUIRED_ARGC 1
#define git_rebase_operation_entrycount_OPTIONAL_ARGC 0
/* git_rebase_operation_entrycount
 *
 * Parameters:
 * - rebase: git_rebase *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_rebase_operation_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value rebase;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rebase);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rebase, Rebase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Rebase expected");
    return mrb_nil_value();
  }

  /* Unbox param: rebase */
  git_rebase * native_rebase = (mrb_nil_p(rebase) ? NULL : mruby_unbox_git_rebase(rebase));

  /* Invocation */
  size_t native_return_value = git_rebase_operation_entrycount(native_rebase);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refdb_compress */
/* sha: 51f06568dd0392f878730d563218c9279a7bf3fab2c9812a45b7ba1c041c6370 */
#if BIND_git_refdb_compress_FUNCTION
#define git_refdb_compress_REQUIRED_ARGC 1
#define git_refdb_compress_OPTIONAL_ARGC 0
/* git_refdb_compress
 *
 * Parameters:
 * - refdb: git_refdb *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refdb_compress(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value refdb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &refdb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refdb, Refdb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refdb expected");
    return mrb_nil_value();
  }

  /* Unbox param: refdb */
  git_refdb * native_refdb = (mrb_nil_p(refdb) ? NULL : mruby_unbox_git_refdb(refdb));

  /* Invocation */
  int native_return_value = git_refdb_compress(native_refdb);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refdb_free */
/* sha: 424a13ce61e049e9664d062b41b3cc9a3bbfefc6d221cb9f279e703e43f84384 */
#if BIND_git_refdb_free_FUNCTION
#define git_refdb_free_REQUIRED_ARGC 1
#define git_refdb_free_OPTIONAL_ARGC 0
/* git_refdb_free
 *
 * Parameters:
 * - refdb: git_refdb *
 * Return Type: void
 */
mrb_value
mrb_Git_git_refdb_free(mrb_state* mrb, mrb_value self) {
  mrb_value refdb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &refdb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refdb, Refdb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refdb expected");
    return mrb_nil_value();
  }

  /* Unbox param: refdb */
  git_refdb * native_refdb = (mrb_nil_p(refdb) ? NULL : mruby_unbox_git_refdb(refdb));

  /* Invocation */
  git_refdb_free(native_refdb);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refdb_new */
/* sha: 1a00e3a5d451d80a40aaeb08536be845cf1faef83fa876ff8df4c869f493d9ae */
#if BIND_git_refdb_new_FUNCTION
#define git_refdb_new_REQUIRED_ARGC 1
#define git_refdb_new_OPTIONAL_ARGC 0
/* git_refdb_new
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refdb_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_refdb * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_refdb_new(&native_out, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_refdb(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refdb_open */
/* sha: 532bab226026df8e31f96e2f71c652c9f89baaa35693a257a0b2b21776ce7488 */
#if BIND_git_refdb_open_FUNCTION
#define git_refdb_open_REQUIRED_ARGC 1
#define git_refdb_open_OPTIONAL_ARGC 0
/* git_refdb_open
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refdb_open(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_refdb * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_refdb_open(&native_out, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_refdb(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_cmp */
/* sha: e63d308eab0c43a841065a1475112b654567fdd9ad6ff0450634ec9eb4736892 */
#if BIND_git_reference_cmp_FUNCTION
#define git_reference_cmp_REQUIRED_ARGC 2
#define git_reference_cmp_OPTIONAL_ARGC 0
/* git_reference_cmp
 *
 * Parameters:
 * - ref1: const git_reference *
 * - ref2: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_cmp(mrb_state* mrb, mrb_value self) {
  mrb_value ref1;
  mrb_value ref2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &ref1, &ref2);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref1, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, ref2, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref1 */
  const git_reference * native_ref1 = (mrb_nil_p(ref1) ? NULL : mruby_unbox_git_reference(ref1));

  /* Unbox param: ref2 */
  const git_reference * native_ref2 = (mrb_nil_p(ref2) ? NULL : mruby_unbox_git_reference(ref2));

  /* Invocation */
  int native_return_value = git_reference_cmp(native_ref1, native_ref2);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_create */
/* sha: 70cd15f10edf99fde2e2efdb9337bd57eeb8bfa305491809c07baa48f884e812 */
#if BIND_git_reference_create_FUNCTION
#define git_reference_create_REQUIRED_ARGC 4
#define git_reference_create_OPTIONAL_ARGC 1
/* git_reference_create
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - id: const git_oid *
 * - force: int
 * - log_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_create(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;
  mrb_value id;
  mrb_bool native_force;
  char * native_log_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozob|z", &repo, &native_name, &id, &native_force, &native_log_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_reference_create(&native_out, native_repo, native_name, native_id, native_force, native_log_message);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_create_matching */
/* sha: f80a9dddc0b13a9ac3f83113e53c00580b8276fa0f7ab0957e9469fe9124f296 */
#if BIND_git_reference_create_matching_FUNCTION
#define git_reference_create_matching_REQUIRED_ARGC 5
#define git_reference_create_matching_OPTIONAL_ARGC 1
/* git_reference_create_matching
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - id: const git_oid *
 * - force: int
 * - current_id: const git_oid *
 * - log_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_create_matching(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;
  mrb_value id;
  mrb_bool native_force;
  mrb_value current_id;
  char * native_log_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozobo|z", &repo, &native_name, &id, &native_force, &current_id, &native_log_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, current_id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Unbox param: current_id */
  const git_oid * native_current_id = (mrb_nil_p(current_id) ? NULL : mruby_unbox_git_oid(current_id));

  /* Invocation */
  int native_return_value = git_reference_create_matching(&native_out, native_repo, native_name, native_id, native_force, native_current_id, native_log_message);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_delete */
/* sha: 1981db7025df7138623939b8f312062b82142cc25bb9d58821af6b61be6a2283 */
#if BIND_git_reference_delete_FUNCTION
#define git_reference_delete_REQUIRED_ARGC 1
#define git_reference_delete_OPTIONAL_ARGC 0
/* git_reference_delete
 *
 * Parameters:
 * - ref: git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_delete(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_delete(native_ref);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_dwim */
/* sha: 9833eafc8c375e471dd7f36049ba81b6f21464f76d4a3e04e29459f685014b8c */
#if BIND_git_reference_dwim_FUNCTION
#define git_reference_dwim_REQUIRED_ARGC 2
#define git_reference_dwim_OPTIONAL_ARGC 0
/* git_reference_dwim
 *
 * Parameters:
 * - repo: git_repository *
 * - shorthand: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_dwim(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_shorthand = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_shorthand);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_dwim(&native_out, native_repo, native_shorthand);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_ensure_log */
/* sha: 3d8a4825bbf997b60b1c2c52e55cdf763884ec9a9a17f23aa4937f2be0a2286a */
#if BIND_git_reference_ensure_log_FUNCTION
#define git_reference_ensure_log_REQUIRED_ARGC 2
#define git_reference_ensure_log_OPTIONAL_ARGC 0
/* git_reference_ensure_log
 *
 * Parameters:
 * - repo: git_repository *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_ensure_log(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_ensure_log(native_repo, native_refname);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_foreach */
/* sha: b93ad8fe0715bfd9505cc6da8856e6cd3aac2ae00bc05b3938cd9201b609da4b */
#if BIND_git_reference_foreach_FUNCTION
#define git_reference_foreach_REQUIRED_ARGC 3
#define git_reference_foreach_OPTIONAL_ARGC 0
/* git_reference_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_reference_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_foreach(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_reference_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_reference_foreach_cb native_callback = TODO_mruby_unbox_git_reference_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_reference_foreach(native_repo, native_callback, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_foreach_glob */
/* sha: edfe61cabd121acc12aa904f2bff9959e62dd34e77744087c973fa4d8f02c12c */
#if BIND_git_reference_foreach_glob_FUNCTION
#define git_reference_foreach_glob_REQUIRED_ARGC 4
#define git_reference_foreach_glob_OPTIONAL_ARGC 0
/* git_reference_foreach_glob
 *
 * Parameters:
 * - repo: git_repository *
 * - glob: const char *
 * - callback: git_reference_foreach_name_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_foreach_glob(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_glob = NULL;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoo", &repo, &native_glob, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_reference_foreach_name_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_reference_foreach_name_cb native_callback = TODO_mruby_unbox_git_reference_foreach_name_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_reference_foreach_glob(native_repo, native_glob, native_callback, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_foreach_name */
/* sha: 54d1620cacf1da4c26c8a9262f79735ac2815d30ede96568ff8487ed1942fd0f */
#if BIND_git_reference_foreach_name_FUNCTION
#define git_reference_foreach_name_REQUIRED_ARGC 3
#define git_reference_foreach_name_OPTIONAL_ARGC 0
/* git_reference_foreach_name
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_reference_foreach_name_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_foreach_name(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_reference_foreach_name_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_reference_foreach_name_cb native_callback = TODO_mruby_unbox_git_reference_foreach_name_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_reference_foreach_name(native_repo, native_callback, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_free */
/* sha: 128e61c41f7e6e2441092437df966d5ca14cf4488193b34875351861b8ecc1c5 */
#if BIND_git_reference_free_FUNCTION
#define git_reference_free_REQUIRED_ARGC 1
#define git_reference_free_OPTIONAL_ARGC 0
/* git_reference_free
 *
 * Parameters:
 * - ref: git_reference *
 * Return Type: void
 */
mrb_value
mrb_Git_git_reference_free(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  git_reference_free(native_ref);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_has_log */
/* sha: 4957ece107cf12162333b54d5c877711d603bf644d037ee9bc73ab84f06d82df */
#if BIND_git_reference_has_log_FUNCTION
#define git_reference_has_log_REQUIRED_ARGC 2
#define git_reference_has_log_OPTIONAL_ARGC 0
/* git_reference_has_log
 *
 * Parameters:
 * - repo: git_repository *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_has_log(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_has_log(native_repo, native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_is_branch */
/* sha: a17c66763bd6e56d5e558fc5e79688ae89869a1f05286b3b79930def7e221b5c */
#if BIND_git_reference_is_branch_FUNCTION
#define git_reference_is_branch_REQUIRED_ARGC 1
#define git_reference_is_branch_OPTIONAL_ARGC 0
/* git_reference_is_branch
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_is_branch(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_is_branch(native_ref);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_is_note */
/* sha: 2199b99a17d8a9c3f9605d7f3c079cb5898862c08d006c8ce03578862a21b39c */
#if BIND_git_reference_is_note_FUNCTION
#define git_reference_is_note_REQUIRED_ARGC 1
#define git_reference_is_note_OPTIONAL_ARGC 0
/* git_reference_is_note
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_is_note(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_is_note(native_ref);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_is_remote */
/* sha: 324667ec5731c817463fe02bfe25d2771e22229fa5e7859c12441c923f94918b */
#if BIND_git_reference_is_remote_FUNCTION
#define git_reference_is_remote_REQUIRED_ARGC 1
#define git_reference_is_remote_OPTIONAL_ARGC 0
/* git_reference_is_remote
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_is_remote(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_is_remote(native_ref);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_is_tag */
/* sha: 3c49b8557e844c8dcfb3f24ed37d2afcdfbfbc25176b2b9e9636f2817b5b324d */
#if BIND_git_reference_is_tag_FUNCTION
#define git_reference_is_tag_REQUIRED_ARGC 1
#define git_reference_is_tag_OPTIONAL_ARGC 0
/* git_reference_is_tag
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_is_tag(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_is_tag(native_ref);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_is_valid_name */
/* sha: ac1ba452f211d45a4a847509129b3b55bdf5f3265608631d6cb87317a61726f5 */
#if BIND_git_reference_is_valid_name_FUNCTION
#define git_reference_is_valid_name_REQUIRED_ARGC 1
#define git_reference_is_valid_name_OPTIONAL_ARGC 0
/* git_reference_is_valid_name
 *
 * Parameters:
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_is_valid_name(mrb_state* mrb, mrb_value self) {
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_refname);

  /* Invocation */
  int native_return_value = git_reference_is_valid_name(native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_iterator_free */
/* sha: e285cfa8a59221072819a4d15f1e535d258bebce610cda72fa5131b8c072d089 */
#if BIND_git_reference_iterator_free_FUNCTION
#define git_reference_iterator_free_REQUIRED_ARGC 1
#define git_reference_iterator_free_OPTIONAL_ARGC 0
/* git_reference_iterator_free
 *
 * Parameters:
 * - iter: git_reference_iterator *
 * Return Type: void
 */
mrb_value
mrb_Git_git_reference_iterator_free(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, ReferenceIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ReferenceIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iter */
  git_reference_iterator * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox_git_reference_iterator(iter));

  /* Invocation */
  git_reference_iterator_free(native_iter);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_iterator_glob_new */
/* sha: a5c321bf81d0de52c90966eb9087e9a847f06cc1d73be59ac5c6e14c7b558481 */
#if BIND_git_reference_iterator_glob_new_FUNCTION
#define git_reference_iterator_glob_new_REQUIRED_ARGC 2
#define git_reference_iterator_glob_new_OPTIONAL_ARGC 0
/* git_reference_iterator_glob_new
 *
 * Parameters:
 * - repo: git_repository *
 * - glob: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_iterator_glob_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference_iterator * native_out = NULL;
  mrb_value repo;
  char * native_glob = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_glob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_iterator_glob_new(&native_out, native_repo, native_glob);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference_iterator(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_iterator_new */
/* sha: 19e44126dbe4c71bdbf1e225e017bc6764bfa702cd1e0ef9c666742296a79e09 */
#if BIND_git_reference_iterator_new_FUNCTION
#define git_reference_iterator_new_REQUIRED_ARGC 1
#define git_reference_iterator_new_OPTIONAL_ARGC 0
/* git_reference_iterator_new
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_iterator_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference_iterator * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_iterator_new(&native_out, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference_iterator(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_list */
/* sha: daea7543ac0a3ababd9c45debe1e75f95c64d36fa530a979b3d88f810ba68394 */
#if BIND_git_reference_list_FUNCTION
#define git_reference_list_REQUIRED_ARGC 1
#define git_reference_list_OPTIONAL_ARGC 0
/* git_reference_list
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_list(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_strarray * native_array = (git_strarray*)calloc(1, sizeof(git_strarray));
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_list(native_array, native_repo);

  /* Box out param: array */
  mrb_value array = native_array == NULL ? mrb_nil_value() : mruby_giftwrap_git_strarray(mrb, native_array);

  RAISE_GIT_ERROR(native_return_value);

  return array;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_lookup */
/* sha: 7f89c894bf73bb712a9d43f5e97aba20d1f74fae9a3f62a145435e96174b9164 */
#if BIND_git_reference_lookup_FUNCTION
#define git_reference_lookup_REQUIRED_ARGC 2
#define git_reference_lookup_OPTIONAL_ARGC 0
/* git_reference_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_lookup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_lookup(&native_out, native_repo, native_name);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_name */
/* sha: 05b295baa93d9545997212f9efb17b82bcb255de62f376cbe12e126864d0e98b */
#if BIND_git_reference_name_FUNCTION
#define git_reference_name_REQUIRED_ARGC 1
#define git_reference_name_OPTIONAL_ARGC 0
/* git_reference_name
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_reference_name(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  const char * native_return_value = git_reference_name(native_ref);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_name_to_id */
/* sha: 97985bdc968225a438d69451829b97967d498fec5e0d7fc7850857d659bcd33d */
#if BIND_git_reference_name_to_id_FUNCTION
#define git_reference_name_to_id_REQUIRED_ARGC 2
#define git_reference_name_to_id_OPTIONAL_ARGC 0
/* git_reference_name_to_id
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_name_to_id(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_oid * native_out = (git_oid*)calloc(1, sizeof(git_oid));
  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_name_to_id(native_out, native_repo, native_name);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_oid(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_next */
/* sha: f0a9a50b05ca77a806ed8c8c0093fe4843f51673f8c6b05c6a67d20af1b78cec */
#if BIND_git_reference_next_FUNCTION
#define git_reference_next_REQUIRED_ARGC 1
#define git_reference_next_OPTIONAL_ARGC 0
/* git_reference_next
 *
 * Parameters:
 * - iter: git_reference_iterator *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_next(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_out = NULL;
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, ReferenceIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ReferenceIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iter */
  git_reference_iterator * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox_git_reference_iterator(iter));

  /* Invocation */
  int native_return_value = git_reference_next(&native_out, native_iter);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_next_name */
/* sha: 1205e76c338c1e104b572e0a5d4ff6d296cea9819e3ce0d4975c831236993926 */
#if BIND_git_reference_next_name_FUNCTION
#define git_reference_next_name_REQUIRED_ARGC 1
#define git_reference_next_name_OPTIONAL_ARGC 0
/* git_reference_next_name
 *
 * Parameters:
 * - iter: git_reference_iterator *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_next_name(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  char * native_out = NULL;
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, ReferenceIterator_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ReferenceIterator expected");
    return mrb_nil_value();
  }

  /* Unbox param: iter */
  git_reference_iterator * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox_git_reference_iterator(iter));

  /* Invocation */
  int native_return_value = git_reference_next_name(&native_out, native_iter);

  /* Box out param: out */
  mrb_value out = native_out ==  NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_normalize_name */
/* sha: 5160e36ef9e3937f7f0b3596c0db77a8f7d8d9dea2041c05220a91555ded1e25 */
#if BIND_git_reference_normalize_name_FUNCTION
#define git_reference_normalize_name_REQUIRED_ARGC 4
#define git_reference_normalize_name_OPTIONAL_ARGC 0
/* git_reference_normalize_name
 *
 * Parameters:
 * - buffer_out: char *
 * - buffer_size: size_t
 * - name: const char *
 * - flags: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_normalize_name(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value buffer_out;
  mrb_int native_buffer_size;
  char * native_name = NULL;
  mrb_int native_flags;

  /* Fetch the args */
  mrb_get_args(mrb, "oizi", &buffer_out, &native_buffer_size, &native_name, &native_flags);

  /* Type checking */
  TODO_type_check_char_PTR(buffer_out);

  /* Unbox param: buffer_out */
  char * native_buffer_out = TODO_mruby_unbox_char_PTR(buffer_out);

  /* Invocation */
  int native_return_value = git_reference_normalize_name(native_buffer_out, native_buffer_size, native_name, native_flags);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_owner */
/* sha: 8bdf2641ad6bef2663a1839f835206cf538dbfdfdc97d415b268519eae38bf9a */
#if BIND_git_reference_owner_FUNCTION
#define git_reference_owner_REQUIRED_ARGC 1
#define git_reference_owner_OPTIONAL_ARGC 0
/* git_reference_owner
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_reference_owner(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  git_repository * native_return_value = git_reference_owner(native_ref);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_peel */
/* sha: d83779b148bd5515ccb1d558961e6115952f4ba8a07681fac9ffe265702b9b57 */
#if BIND_git_reference_peel_FUNCTION
#define git_reference_peel_REQUIRED_ARGC 2
#define git_reference_peel_OPTIONAL_ARGC 0
/* git_reference_peel
 *
 * Parameters:
 * - ref: git_reference *
 * - type: git_otype
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_peel(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_object * native_out = NULL;
  mrb_value ref;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &ref, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_peel(&native_out, native_ref, native_type);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_remove */
/* sha: d16f1caf3f2b9a02b74ac930437085087b4660f010935734005e52528a2fa8a3 */
#if BIND_git_reference_remove_FUNCTION
#define git_reference_remove_REQUIRED_ARGC 2
#define git_reference_remove_OPTIONAL_ARGC 0
/* git_reference_remove
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_remove(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_remove(native_repo, native_name);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_rename */
/* sha: 6b3a26c014e92f5d406a7a7b35e854b26342d7128b1e17fca12077cd20ea367e */
#if BIND_git_reference_rename_FUNCTION
#define git_reference_rename_REQUIRED_ARGC 4
#define git_reference_rename_OPTIONAL_ARGC 0
/* git_reference_rename
 *
 * Parameters:
 * - ref: git_reference *
 * - new_name: const char *
 * - force: int
 * - log_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_rename(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_new_ref = NULL;
  mrb_value ref;
  char * native_new_name = NULL;
  mrb_bool native_force;
  char * native_log_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozbz", &ref, &native_new_name, &native_force, &native_log_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_rename(&native_new_ref, native_ref, native_new_name, native_force, native_log_message);

  /* Box out param: new_ref */
  mrb_value new_ref = native_new_ref == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_new_ref);

  RAISE_GIT_ERROR(native_return_value);

  return new_ref;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_resolve */
/* sha: da04e30175308fe7555410d1b61947d09693179dfda2fff8001740c6f255b727 */
#if BIND_git_reference_resolve_FUNCTION
#define git_reference_resolve_REQUIRED_ARGC 1
#define git_reference_resolve_OPTIONAL_ARGC 0
/* git_reference_resolve
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_resolve(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_out = NULL;
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_resolve(&native_out, native_ref);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_set_target */
/* sha: 873daf55b922826178bb9228ab49627d4bac885bfeb6acd955790216e8586c88 */
#if BIND_git_reference_set_target_FUNCTION
#define git_reference_set_target_REQUIRED_ARGC 3
#define git_reference_set_target_OPTIONAL_ARGC 0
/* git_reference_set_target
 *
 * Parameters:
 * - ref: git_reference *
 * - id: const git_oid *
 * - log_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_set_target(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_out = NULL;
  mrb_value ref;
  mrb_value id;
  char * native_log_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &ref, &id, &native_log_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_reference_set_target(&native_out, native_ref, native_id, native_log_message);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_shorthand */
/* sha: ec09b0964ebccf032de7b0f54b18ed0f6d20ee6ba570fe3321682d8c083b235e */
#if BIND_git_reference_shorthand_FUNCTION
#define git_reference_shorthand_REQUIRED_ARGC 1
#define git_reference_shorthand_OPTIONAL_ARGC 0
/* git_reference_shorthand
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_reference_shorthand(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  const char * native_return_value = git_reference_shorthand(native_ref);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_symbolic_create */
/* sha: d5fecdfd49d34a287667983667b3abca38c2aa39e705b0d01999f91b0aced7b0 */
#if BIND_git_reference_symbolic_create_FUNCTION
#define git_reference_symbolic_create_REQUIRED_ARGC 5
#define git_reference_symbolic_create_OPTIONAL_ARGC 0
/* git_reference_symbolic_create
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - target: const char *
 * - force: int
 * - log_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_symbolic_create(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;
  char * native_target = NULL;
  mrb_bool native_force;
  char * native_log_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzbz", &repo, &native_name, &native_target, &native_force, &native_log_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_symbolic_create(&native_out, native_repo, native_name, native_target, native_force, native_log_message);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_symbolic_create_matching */
/* sha: 6c0de31e13653539e8ddbf3d3d4760f6e09a7b84d478bab600cfa73455be2bc0 */
#if BIND_git_reference_symbolic_create_matching_FUNCTION
#define git_reference_symbolic_create_matching_REQUIRED_ARGC 6
#define git_reference_symbolic_create_matching_OPTIONAL_ARGC 0
/* git_reference_symbolic_create_matching
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - target: const char *
 * - force: int
 * - current_value: const char *
 * - log_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_symbolic_create_matching(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;
  char * native_target = NULL;
  mrb_bool native_force;
  char * native_current_value = NULL;
  char * native_log_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzbzz", &repo, &native_name, &native_target, &native_force, &native_current_value, &native_log_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reference_symbolic_create_matching(&native_out, native_repo, native_name, native_target, native_force, native_current_value, native_log_message);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_symbolic_set_target */
/* sha: a17bade7eb1eae7d825bbf470508e3a8002b1bc48833798888ff7a2b94ceee17 */
#if BIND_git_reference_symbolic_set_target_FUNCTION
#define git_reference_symbolic_set_target_REQUIRED_ARGC 3
#define git_reference_symbolic_set_target_OPTIONAL_ARGC 0
/* git_reference_symbolic_set_target
 *
 * Parameters:
 * - ref: git_reference *
 * - target: const char *
 * - log_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reference_symbolic_set_target(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_out = NULL;
  mrb_value ref;
  char * native_target = NULL;
  char * native_log_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &ref, &native_target, &native_log_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  int native_return_value = git_reference_symbolic_set_target(&native_out, native_ref, native_target, native_log_message);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_symbolic_target */
/* sha: 5729e9239b98317e5e490b48450984be82ccc9336204ad066ad33fa810de7a5a */
#if BIND_git_reference_symbolic_target_FUNCTION
#define git_reference_symbolic_target_REQUIRED_ARGC 1
#define git_reference_symbolic_target_OPTIONAL_ARGC 0
/* git_reference_symbolic_target
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_reference_symbolic_target(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  const char * native_return_value = git_reference_symbolic_target(native_ref);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_target */
/* sha: 064292dc06951b25778ce09bcbc25887d365e887c127d89bb86dcf44b68b2571 */
#if BIND_git_reference_target_FUNCTION
#define git_reference_target_REQUIRED_ARGC 1
#define git_reference_target_OPTIONAL_ARGC 0
/* git_reference_target
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_reference_target(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  const git_oid * native_return_value = git_reference_target(native_ref);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_target_peel */
/* sha: 8437bf881541d62a307d06547e44e3405bee86bcf8ffeb01fbf66a9e1acd97f1 */
#if BIND_git_reference_target_peel_FUNCTION
#define git_reference_target_peel_REQUIRED_ARGC 1
#define git_reference_target_peel_OPTIONAL_ARGC 0
/* git_reference_target_peel
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_reference_target_peel(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  const git_oid * native_return_value = git_reference_target_peel(native_ref);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reference_type */
/* sha: d56db66d0d25b896e5ecb50c97b2eaf52a69d92ae64787fe0df39ffcc43b61e0 */
#if BIND_git_reference_type_FUNCTION
#define git_reference_type_REQUIRED_ARGC 1
#define git_reference_type_OPTIONAL_ARGC 0
/* git_reference_type
 *
 * Parameters:
 * - ref: const git_reference *
 * Return Type: git_ref_t
 */
mrb_value
mrb_Git_git_reference_type(mrb_state* mrb, mrb_value self) {
  mrb_value ref;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &ref);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, ref, Reference_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reference expected");
    return mrb_nil_value();
  }

  /* Unbox param: ref */
  const git_reference * native_ref = (mrb_nil_p(ref) ? NULL : mruby_unbox_git_reference(ref));

  /* Invocation */
  git_ref_t native_return_value = git_reference_type(native_ref);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_append */
/* sha: b22eb43d13a7693e6cbbe4fbf1c94f7d329840686f4bd129780985faeea78872 */
#if BIND_git_reflog_append_FUNCTION
#define git_reflog_append_REQUIRED_ARGC 4
#define git_reflog_append_OPTIONAL_ARGC 0
/* git_reflog_append
 *
 * Parameters:
 * - reflog: git_reflog *
 * - id: const git_oid *
 * - committer: const git_signature *
 * - msg: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reflog_append(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value reflog;
  mrb_value id;
  mrb_value committer;
  char * native_msg = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oooz", &reflog, &id, &committer, &native_msg);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, reflog, Reflog_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reflog expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, committer, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: reflog */
  git_reflog * native_reflog = (mrb_nil_p(reflog) ? NULL : mruby_unbox_git_reflog(reflog));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Unbox param: committer */
  const git_signature * native_committer = (mrb_nil_p(committer) ? NULL : mruby_unbox_git_signature(committer));

  /* Invocation */
  int native_return_value = git_reflog_append(native_reflog, native_id, native_committer, native_msg);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_delete */
/* sha: 8cc9b8e6e8f2493ba542d217393847cdb1f8d8dc38c5a018abf5796c764a8a1c */
#if BIND_git_reflog_delete_FUNCTION
#define git_reflog_delete_REQUIRED_ARGC 2
#define git_reflog_delete_OPTIONAL_ARGC 0
/* git_reflog_delete
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reflog_delete(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reflog_delete(native_repo, native_name);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_drop */
/* sha: 11b52802a69a791f6cd3445050c2af7c70a8ccc300c1f043d2339e4694636f60 */
#if BIND_git_reflog_drop_FUNCTION
#define git_reflog_drop_REQUIRED_ARGC 3
#define git_reflog_drop_OPTIONAL_ARGC 0
/* git_reflog_drop
 *
 * Parameters:
 * - reflog: git_reflog *
 * - idx: size_t
 * - rewrite_previous_entry: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_reflog_drop(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value reflog;
  mrb_int native_idx;
  mrb_int native_rewrite_previous_entry;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &reflog, &native_idx, &native_rewrite_previous_entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, reflog, Reflog_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reflog expected");
    return mrb_nil_value();
  }

  /* Unbox param: reflog */
  git_reflog * native_reflog = (mrb_nil_p(reflog) ? NULL : mruby_unbox_git_reflog(reflog));

  /* Invocation */
  int native_return_value = git_reflog_drop(native_reflog, native_idx, native_rewrite_previous_entry);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_entry_byindex */
/* sha: b80377c6dce9ae8f43c7bde448c77a1db0c84b4acfe5cd16763ef6cb3e7aea66 */
#if BIND_git_reflog_entry_byindex_FUNCTION
#define git_reflog_entry_byindex_REQUIRED_ARGC 2
#define git_reflog_entry_byindex_OPTIONAL_ARGC 0
/* git_reflog_entry_byindex
 *
 * Parameters:
 * - reflog: const git_reflog *
 * - idx: size_t
 * Return Type: const git_reflog_entry *
 */
mrb_value
mrb_Git_git_reflog_entry_byindex(mrb_state* mrb, mrb_value self) {
  mrb_value reflog;
  mrb_int native_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &reflog, &native_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, reflog, Reflog_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reflog expected");
    return mrb_nil_value();
  }

  /* Unbox param: reflog */
  const git_reflog * native_reflog = (mrb_nil_p(reflog) ? NULL : mruby_unbox_git_reflog(reflog));

  /* Invocation */
  const git_reflog_entry * native_return_value = git_reflog_entry_byindex(native_reflog, native_idx);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_reflog_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_entry_committer */
/* sha: 30aecfb4911f3a543d642893b0a5abeecc0d35125f6d54b0673c035d6687e3c9 */
#if BIND_git_reflog_entry_committer_FUNCTION
#define git_reflog_entry_committer_REQUIRED_ARGC 1
#define git_reflog_entry_committer_OPTIONAL_ARGC 0
/* git_reflog_entry_committer
 *
 * Parameters:
 * - entry: const git_reflog_entry *
 * Return Type: const git_signature *
 */
mrb_value
mrb_Git_git_reflog_entry_committer(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, ReflogEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ReflogEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_reflog_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_reflog_entry(entry));

  /* Invocation */
  const git_signature * native_return_value = git_reflog_entry_committer(native_entry);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_signature(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_entry_id_new */
/* sha: a15346bdc3926e516d6931003ed649d3c1c03382268037aac9889b71921628d9 */
#if BIND_git_reflog_entry_id_new_FUNCTION
#define git_reflog_entry_id_new_REQUIRED_ARGC 1
#define git_reflog_entry_id_new_OPTIONAL_ARGC 0
/* git_reflog_entry_id_new
 *
 * Parameters:
 * - entry: const git_reflog_entry *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_reflog_entry_id_new(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, ReflogEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ReflogEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_reflog_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_reflog_entry(entry));

  /* Invocation */
  const git_oid * native_return_value = git_reflog_entry_id_new(native_entry);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_entry_id_old */
/* sha: 70b18790d3ad4a58a7195211a29dd3bf96577f701cc97f9cc870e22986412956 */
#if BIND_git_reflog_entry_id_old_FUNCTION
#define git_reflog_entry_id_old_REQUIRED_ARGC 1
#define git_reflog_entry_id_old_OPTIONAL_ARGC 0
/* git_reflog_entry_id_old
 *
 * Parameters:
 * - entry: const git_reflog_entry *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_reflog_entry_id_old(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, ReflogEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ReflogEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_reflog_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_reflog_entry(entry));

  /* Invocation */
  const git_oid * native_return_value = git_reflog_entry_id_old(native_entry);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_entry_message */
/* sha: 2bcd630b9f276097bbb254d8c3ea25e89e90bd3c8ad10d568398329ce62920cb */
#if BIND_git_reflog_entry_message_FUNCTION
#define git_reflog_entry_message_REQUIRED_ARGC 1
#define git_reflog_entry_message_OPTIONAL_ARGC 0
/* git_reflog_entry_message
 *
 * Parameters:
 * - entry: const git_reflog_entry *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_reflog_entry_message(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, ReflogEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "ReflogEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_reflog_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_reflog_entry(entry));

  /* Invocation */
  const char * native_return_value = git_reflog_entry_message(native_entry);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_entrycount */
/* sha: 6058f43eb6160fa05195a85ef01b9c13907ace3aa678990855772af1ac7d8c5a */
#if BIND_git_reflog_entrycount_FUNCTION
#define git_reflog_entrycount_REQUIRED_ARGC 1
#define git_reflog_entrycount_OPTIONAL_ARGC 0
/* git_reflog_entrycount
 *
 * Parameters:
 * - reflog: git_reflog *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_reflog_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value reflog;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &reflog);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, reflog, Reflog_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reflog expected");
    return mrb_nil_value();
  }

  /* Unbox param: reflog */
  git_reflog * native_reflog = (mrb_nil_p(reflog) ? NULL : mruby_unbox_git_reflog(reflog));

  /* Invocation */
  size_t native_return_value = git_reflog_entrycount(native_reflog);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_free */
/* sha: 37acbfe82d591233d01e68e3922869ae21a6e94d837e3bf72a1153eb93c87b33 */
#if BIND_git_reflog_free_FUNCTION
#define git_reflog_free_REQUIRED_ARGC 1
#define git_reflog_free_OPTIONAL_ARGC 0
/* git_reflog_free
 *
 * Parameters:
 * - reflog: git_reflog *
 * Return Type: void
 */
mrb_value
mrb_Git_git_reflog_free(mrb_state* mrb, mrb_value self) {
  mrb_value reflog;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &reflog);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, reflog, Reflog_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reflog expected");
    return mrb_nil_value();
  }

  /* Unbox param: reflog */
  git_reflog * native_reflog = (mrb_nil_p(reflog) ? NULL : mruby_unbox_git_reflog(reflog));

  /* Invocation */
  git_reflog_free(native_reflog);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_read */
/* sha: be962f21e2047eefbcd5a280db5fdb3fc5c5492e82ab68be0f0163f6fd619290 */
#if BIND_git_reflog_read_FUNCTION
#define git_reflog_read_REQUIRED_ARGC 2
#define git_reflog_read_OPTIONAL_ARGC 0
/* git_reflog_read
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reflog_read(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reflog * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reflog_read(&native_out, native_repo, native_name);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reflog(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_rename */
/* sha: ac3597d72f8b9b46f48b463d4f644f6294ceff85ebf802eef0bc60f8520c3c23 */
#if BIND_git_reflog_rename_FUNCTION
#define git_reflog_rename_REQUIRED_ARGC 3
#define git_reflog_rename_OPTIONAL_ARGC 0
/* git_reflog_rename
 *
 * Parameters:
 * - repo: git_repository *
 * - old_name: const char *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reflog_rename(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_old_name = NULL;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_old_name, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_reflog_rename(native_repo, native_old_name, native_name);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reflog_write */
/* sha: 628017e4aa0e20467e9b3751f1bfffd80ef762b4aa27a903fedddf71b5fc237a */
#if BIND_git_reflog_write_FUNCTION
#define git_reflog_write_REQUIRED_ARGC 1
#define git_reflog_write_OPTIONAL_ARGC 0
/* git_reflog_write
 *
 * Parameters:
 * - reflog: git_reflog *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reflog_write(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value reflog;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &reflog);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, reflog, Reflog_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reflog expected");
    return mrb_nil_value();
  }

  /* Unbox param: reflog */
  git_reflog * native_reflog = (mrb_nil_p(reflog) ? NULL : mruby_unbox_git_reflog(reflog));

  /* Invocation */
  int native_return_value = git_reflog_write(native_reflog);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_direction */
/* sha: 5c3320d99c939bfb590ea115066a2746bab43083d9b0a232ed112bd57c8569d8 */
#if BIND_git_refspec_direction_FUNCTION
#define git_refspec_direction_REQUIRED_ARGC 1
#define git_refspec_direction_OPTIONAL_ARGC 0
/* git_refspec_direction
 *
 * Parameters:
 * - spec: const git_refspec *
 * Return Type: git_direction
 */
mrb_value
mrb_Git_git_refspec_direction(mrb_state* mrb, mrb_value self) {
  mrb_value spec;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &spec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, spec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: spec */
  const git_refspec * native_spec = (mrb_nil_p(spec) ? NULL : mruby_unbox_git_refspec(spec));

  /* Invocation */
  git_direction native_return_value = git_refspec_direction(native_spec);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_dst */
/* sha: c911c03db0542e9ea2453a371cb288d51f5f84351eb8164aeab954b0dc7ac461 */
#if BIND_git_refspec_dst_FUNCTION
#define git_refspec_dst_REQUIRED_ARGC 1
#define git_refspec_dst_OPTIONAL_ARGC 0
/* git_refspec_dst
 *
 * Parameters:
 * - refspec: const git_refspec *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_refspec_dst(mrb_state* mrb, mrb_value self) {
  mrb_value refspec;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &refspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refspec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: refspec */
  const git_refspec * native_refspec = (mrb_nil_p(refspec) ? NULL : mruby_unbox_git_refspec(refspec));

  /* Invocation */
  const char * native_return_value = git_refspec_dst(native_refspec);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_dst_matches */
/* sha: c406e52831f01b538cbfdb304ada95f1424aa2e20935af94b1b02989a53964e4 */
#if BIND_git_refspec_dst_matches_FUNCTION
#define git_refspec_dst_matches_REQUIRED_ARGC 2
#define git_refspec_dst_matches_OPTIONAL_ARGC 0
/* git_refspec_dst_matches
 *
 * Parameters:
 * - refspec: const git_refspec *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refspec_dst_matches(mrb_state* mrb, mrb_value self) {
  mrb_value refspec;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &refspec, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refspec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: refspec */
  const git_refspec * native_refspec = (mrb_nil_p(refspec) ? NULL : mruby_unbox_git_refspec(refspec));

  /* Invocation */
  int native_return_value = git_refspec_dst_matches(native_refspec, native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_force */
/* sha: d9f865f5a70216b07975536111f4376626ab7599077fa61a4010958449cfba0a */
#if BIND_git_refspec_force_FUNCTION
#define git_refspec_force_REQUIRED_ARGC 1
#define git_refspec_force_OPTIONAL_ARGC 0
/* git_refspec_force
 *
 * Parameters:
 * - refspec: const git_refspec *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refspec_force(mrb_state* mrb, mrb_value self) {
  mrb_value refspec;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &refspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refspec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: refspec */
  const git_refspec * native_refspec = (mrb_nil_p(refspec) ? NULL : mruby_unbox_git_refspec(refspec));

  /* Invocation */
  int native_return_value = git_refspec_force(native_refspec);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_rtransform */
/* sha: 46032b79542ef88fec0b9563f5ab8e476c45941fc672ee938a0be938e2115b5c */
#if BIND_git_refspec_rtransform_FUNCTION
#define git_refspec_rtransform_REQUIRED_ARGC 2
#define git_refspec_rtransform_OPTIONAL_ARGC 0
/* git_refspec_rtransform
 *
 * Parameters:
 * - spec: const git_refspec *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refspec_rtransform(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value spec;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &spec, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, spec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: spec */
  const git_refspec * native_spec = (mrb_nil_p(spec) ? NULL : mruby_unbox_git_refspec(spec));

  /* Invocation */
  int native_return_value = git_refspec_rtransform(native_out, native_spec, native_name);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_src */
/* sha: ab77aaed716f657f8e95ebe98e6cd16fafcaf6d44c77550e4c5af19ddebd576a */
#if BIND_git_refspec_src_FUNCTION
#define git_refspec_src_REQUIRED_ARGC 1
#define git_refspec_src_OPTIONAL_ARGC 0
/* git_refspec_src
 *
 * Parameters:
 * - refspec: const git_refspec *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_refspec_src(mrb_state* mrb, mrb_value self) {
  mrb_value refspec;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &refspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refspec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: refspec */
  const git_refspec * native_refspec = (mrb_nil_p(refspec) ? NULL : mruby_unbox_git_refspec(refspec));

  /* Invocation */
  const char * native_return_value = git_refspec_src(native_refspec);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_src_matches */
/* sha: e16ae06f5e0b62281ead54448156c98cdebeaca089adb9a0be97751a8e38e833 */
#if BIND_git_refspec_src_matches_FUNCTION
#define git_refspec_src_matches_REQUIRED_ARGC 2
#define git_refspec_src_matches_OPTIONAL_ARGC 0
/* git_refspec_src_matches
 *
 * Parameters:
 * - refspec: const git_refspec *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refspec_src_matches(mrb_state* mrb, mrb_value self) {
  mrb_value refspec;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &refspec, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refspec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: refspec */
  const git_refspec * native_refspec = (mrb_nil_p(refspec) ? NULL : mruby_unbox_git_refspec(refspec));

  /* Invocation */
  int native_return_value = git_refspec_src_matches(native_refspec, native_refname);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_string */
/* sha: 420a36f9fe44f661f91ee2eb04c97cc07fe051834a0480b43e0cd9967970a83d */
#if BIND_git_refspec_string_FUNCTION
#define git_refspec_string_REQUIRED_ARGC 1
#define git_refspec_string_OPTIONAL_ARGC 0
/* git_refspec_string
 *
 * Parameters:
 * - refspec: const git_refspec *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_refspec_string(mrb_state* mrb, mrb_value self) {
  mrb_value refspec;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &refspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, refspec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: refspec */
  const git_refspec * native_refspec = (mrb_nil_p(refspec) ? NULL : mruby_unbox_git_refspec(refspec));

  /* Invocation */
  const char * native_return_value = git_refspec_string(native_refspec);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_refspec_transform */
/* sha: 631061222aef5a6f14be55bf1b828b030875585fe5535b8eff21b402145ac7ba */
#if BIND_git_refspec_transform_FUNCTION
#define git_refspec_transform_REQUIRED_ARGC 2
#define git_refspec_transform_OPTIONAL_ARGC 0
/* git_refspec_transform
 *
 * Parameters:
 * - spec: const git_refspec *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_refspec_transform(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value spec;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &spec, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, spec, Refspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Refspec expected");
    return mrb_nil_value();
  }

  /* Unbox param: spec */
  const git_refspec * native_spec = (mrb_nil_p(spec) ? NULL : mruby_unbox_git_refspec(spec));

  /* Invocation */
  int native_return_value = git_refspec_transform(native_out, native_spec, native_name);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_add_fetch */
/* sha: 9b60d26e14f3c3cdbd10966157f3e78c320be5f4d745fd4ddcc5057e3b64839b */
#if BIND_git_remote_add_fetch_FUNCTION
#define git_remote_add_fetch_REQUIRED_ARGC 3
#define git_remote_add_fetch_OPTIONAL_ARGC 0
/* git_remote_add_fetch
 *
 * Parameters:
 * - repo: git_repository *
 * - remote: const char *
 * - refspec: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_add_fetch(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_remote = NULL;
  char * native_refspec = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_remote, &native_refspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_add_fetch(native_repo, native_remote, native_refspec);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_add_push */
/* sha: 7d7ce85ad952f6c907799047f569c5f6c6ba58831daa05da3bdb6e372feca2d1 */
#if BIND_git_remote_add_push_FUNCTION
#define git_remote_add_push_REQUIRED_ARGC 3
#define git_remote_add_push_OPTIONAL_ARGC 0
/* git_remote_add_push
 *
 * Parameters:
 * - repo: git_repository *
 * - remote: const char *
 * - refspec: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_add_push(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_remote = NULL;
  char * native_refspec = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_remote, &native_refspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_add_push(native_repo, native_remote, native_refspec);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_autotag */
/* sha: bbd8c5cbd61532e3ed6f634920e28a25daa42a761bbc31f3282ec45bbc07b57f */
#if BIND_git_remote_autotag_FUNCTION
#define git_remote_autotag_REQUIRED_ARGC 1
#define git_remote_autotag_OPTIONAL_ARGC 0
/* git_remote_autotag
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: git_remote_autotag_option_t
 */
mrb_value
mrb_Git_git_remote_autotag(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  git_remote_autotag_option_t native_return_value = git_remote_autotag(native_remote);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_connect */
/* sha: cf8c12e109860d5090a7dbfa6354594323fe4d82acc884b23dc1df0e985b94e5 */
#if BIND_git_remote_connect_FUNCTION
#define git_remote_connect_REQUIRED_ARGC 4
#define git_remote_connect_OPTIONAL_ARGC 0
/* git_remote_connect
 *
 * Parameters:
 * - remote: git_remote *
 * - direction: git_direction
 * - callbacks: const git_remote_callbacks *
 * - custom_headers: const git_strarray *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_connect(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value remote;
  mrb_int native_direction;
  mrb_value callbacks;
  mrb_value custom_headers;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &remote, &native_direction, &callbacks, &custom_headers);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, callbacks, RemoteCallbacks_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RemoteCallbacks expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, custom_headers, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Unbox param: callbacks */
  const git_remote_callbacks * native_callbacks = (mrb_nil_p(callbacks) ? NULL : mruby_unbox_git_remote_callbacks(callbacks));

  /* Unbox param: custom_headers */
  const git_strarray * native_custom_headers = (mrb_nil_p(custom_headers) ? NULL : mruby_unbox_git_strarray(custom_headers));

  /* Invocation */
  int native_return_value = git_remote_connect(native_remote, native_direction, native_callbacks, native_custom_headers);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_connected */
/* sha: cd8e34ae5e5bea2f51db56f0dcbe1bb6c04fefc643d466a7d6c511838d1cdd9e */
#if BIND_git_remote_connected_FUNCTION
#define git_remote_connected_REQUIRED_ARGC 1
#define git_remote_connected_OPTIONAL_ARGC 0
/* git_remote_connected
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_connected(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  int native_return_value = git_remote_connected(native_remote);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_create */
/* sha: 3c6a829e7b214b7b480e8115045e5561070dc116ad3e15324a0869c8586e607d */
#if BIND_git_remote_create_FUNCTION
#define git_remote_create_REQUIRED_ARGC 3
#define git_remote_create_OPTIONAL_ARGC 0
/* git_remote_create
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - url: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_create(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_remote * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;
  char * native_url = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_name, &native_url);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_create(&native_out, native_repo, native_name, native_url);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_remote(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_create_anonymous */
/* sha: fd7bed8abc115d6b15abc26189d4b9254fa7f1313d16d0fa44aed27fe88198e7 */
#if BIND_git_remote_create_anonymous_FUNCTION
#define git_remote_create_anonymous_REQUIRED_ARGC 2
#define git_remote_create_anonymous_OPTIONAL_ARGC 0
/* git_remote_create_anonymous
 *
 * Parameters:
 * - repo: git_repository *
 * - url: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_create_anonymous(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_remote * native_out = NULL;
  mrb_value repo;
  char * native_url = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_url);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_create_anonymous(&native_out, native_repo, native_url);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_remote(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_create_with_fetchspec */
/* sha: 2dd999a188cfc8182e214b2b285fa9642bd8415a33a0fd19529c0c72c84fce76 */
#if BIND_git_remote_create_with_fetchspec_FUNCTION
#define git_remote_create_with_fetchspec_REQUIRED_ARGC 4
#define git_remote_create_with_fetchspec_OPTIONAL_ARGC 0
/* git_remote_create_with_fetchspec
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - url: const char *
 * - fetch: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_create_with_fetchspec(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_remote * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;
  char * native_url = NULL;
  char * native_fetch = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzz", &repo, &native_name, &native_url, &native_fetch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_create_with_fetchspec(&native_out, native_repo, native_name, native_url, native_fetch);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_remote(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_default_branch */
/* sha: 37aab81dff10716a4e41718f742d869ff34cd3d20edea9415f0135e07c1e1444 */
#if BIND_git_remote_default_branch_FUNCTION
#define git_remote_default_branch_REQUIRED_ARGC 1
#define git_remote_default_branch_OPTIONAL_ARGC 0
/* git_remote_default_branch
 *
 * Parameters:
 * - remote: git_remote *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_default_branch(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  int native_return_value = git_remote_default_branch(native_out, native_remote);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_delete */
/* sha: f9cb16ee310207815a67ad6176094e3964ef048c43856b70100c8ed4cf3afa0e */
#if BIND_git_remote_delete_FUNCTION
#define git_remote_delete_REQUIRED_ARGC 2
#define git_remote_delete_OPTIONAL_ARGC 0
/* git_remote_delete
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_delete(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_delete(native_repo, native_name);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_disconnect */
/* sha: 58f2c5af0ca974bf027ddb52549fea5f57f5b32bf401e9ebce2721a7d674b3a9 */
#if BIND_git_remote_disconnect_FUNCTION
#define git_remote_disconnect_REQUIRED_ARGC 1
#define git_remote_disconnect_OPTIONAL_ARGC 0
/* git_remote_disconnect
 *
 * Parameters:
 * - remote: git_remote *
 * Return Type: void
 */
mrb_value
mrb_Git_git_remote_disconnect(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  git_remote_disconnect(native_remote);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_download */
/* sha: 14899d4ab2e9c9d65cc559c34e8436c2d015a708bb8fd35d310607316a07d0cd */
#if BIND_git_remote_download_FUNCTION
#define git_remote_download_REQUIRED_ARGC 3
#define git_remote_download_OPTIONAL_ARGC 0
/* git_remote_download
 *
 * Parameters:
 * - remote: git_remote *
 * - refspecs: const git_strarray *
 * - opts: const git_fetch_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_download(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value remote;
  mrb_value refspecs;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &remote, &refspecs, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, refspecs, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, FetchOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FetchOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Unbox param: refspecs */
  const git_strarray * native_refspecs = (mrb_nil_p(refspecs) ? NULL : mruby_unbox_git_strarray(refspecs));

  /* Unbox param: opts */
  const git_fetch_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_fetch_options(opts));

  /* Invocation */
  int native_return_value = git_remote_download(native_remote, native_refspecs, native_opts);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_dup */
/* sha: 9e9559239ea9ef75c02a19705bacc53a0e391a11dd93aa52fc5af21723058334 */
#if BIND_git_remote_dup_FUNCTION
#define git_remote_dup_REQUIRED_ARGC 1
#define git_remote_dup_OPTIONAL_ARGC 0
/* git_remote_dup
 *
 * Parameters:
 * - source: git_remote *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_dup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_remote * native_dest = NULL;
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: source */
  git_remote * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox_git_remote(source));

  /* Invocation */
  int native_return_value = git_remote_dup(&native_dest, native_source);

  /* Box out param: dest */
  mrb_value dest = native_dest == NULL ? mrb_nil_value() : mruby_giftwrap_git_remote(mrb, native_dest);

  RAISE_GIT_ERROR(native_return_value);

  return dest;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_fetch */
/* sha: 9deafd9f5b53e4ef3f463b153970759574c517b08e485a1af7d2de3ec4b7bd2f */
#if BIND_git_remote_fetch_FUNCTION
#define git_remote_fetch_REQUIRED_ARGC 4
#define git_remote_fetch_OPTIONAL_ARGC 0
/* git_remote_fetch
 *
 * Parameters:
 * - remote: git_remote *
 * - refspecs: const git_strarray *
 * - opts: const git_fetch_options *
 * - reflog_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_fetch(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value remote;
  mrb_value refspecs;
  mrb_value opts;
  char * native_reflog_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oooz", &remote, &refspecs, &opts, &native_reflog_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, refspecs, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, FetchOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "FetchOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Unbox param: refspecs */
  const git_strarray * native_refspecs = (mrb_nil_p(refspecs) ? NULL : mruby_unbox_git_strarray(refspecs));

  /* Unbox param: opts */
  const git_fetch_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_fetch_options(opts));

  /* Invocation */
  int native_return_value = git_remote_fetch(native_remote, native_refspecs, native_opts, native_reflog_message);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_free */
/* sha: dfbbe4198662f3dc3d15f38a81c477fb4310c7e35202143626cb34b40ab8c026 */
#if BIND_git_remote_free_FUNCTION
#define git_remote_free_REQUIRED_ARGC 1
#define git_remote_free_OPTIONAL_ARGC 0
/* git_remote_free
 *
 * Parameters:
 * - remote: git_remote *
 * Return Type: void
 */
mrb_value
mrb_Git_git_remote_free(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  git_remote_free(native_remote);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_get_fetch_refspecs */
/* sha: f4e56080d85cccfd958b2de2215f8661096debfff92eff7c1d78bb1c92e60a0d */
#if BIND_git_remote_get_fetch_refspecs_FUNCTION
#define git_remote_get_fetch_refspecs_REQUIRED_ARGC 1
#define git_remote_get_fetch_refspecs_OPTIONAL_ARGC 0
/* git_remote_get_fetch_refspecs
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_get_fetch_refspecs(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_strarray * native_array = (git_strarray*)calloc(1, sizeof(git_strarray));
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  int native_return_value = git_remote_get_fetch_refspecs(native_array, native_remote);

  /* Box out param: array */
  mrb_value array = native_array == NULL ? mrb_nil_value() : mruby_giftwrap_git_strarray(mrb, native_array);

  RAISE_GIT_ERROR(native_return_value);

  return array;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_get_push_refspecs */
/* sha: 7e750d7b3f83d37f79c0a7943542fb78cfcc7eba01bc30883a3ad0aca0a426f4 */
#if BIND_git_remote_get_push_refspecs_FUNCTION
#define git_remote_get_push_refspecs_REQUIRED_ARGC 1
#define git_remote_get_push_refspecs_OPTIONAL_ARGC 0
/* git_remote_get_push_refspecs
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_get_push_refspecs(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_strarray * native_array = (git_strarray*)calloc(1, sizeof(git_strarray));
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  int native_return_value = git_remote_get_push_refspecs(native_array, native_remote);

  /* Box out param: array */
  mrb_value array = native_array == NULL ? mrb_nil_value() : mruby_giftwrap_git_strarray(mrb, native_array);

  RAISE_GIT_ERROR(native_return_value);

  return array;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_get_refspec */
/* sha: 02af21ea779549dae73de93bcd8e4a1ffa887ace6afca0faac0240fc511b73e8 */
#if BIND_git_remote_get_refspec_FUNCTION
#define git_remote_get_refspec_REQUIRED_ARGC 2
#define git_remote_get_refspec_OPTIONAL_ARGC 0
/* git_remote_get_refspec
 *
 * Parameters:
 * - remote: const git_remote *
 * - n: size_t
 * Return Type: const git_refspec *
 */
mrb_value
mrb_Git_git_remote_get_refspec(mrb_state* mrb, mrb_value self) {
  mrb_value remote;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &remote, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  const git_refspec * native_return_value = git_remote_get_refspec(native_remote, native_n);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_refspec(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_init_callbacks */
/* sha: ff6bc4c7d8a9b5e4cbd57643c9381893c711ba99887d1a306f4e9a245d34f74d */
#if BIND_git_remote_init_callbacks_FUNCTION
#define git_remote_init_callbacks_REQUIRED_ARGC 2
#define git_remote_init_callbacks_OPTIONAL_ARGC 0
/* git_remote_init_callbacks
 *
 * Parameters:
 * - opts: git_remote_callbacks *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_init_callbacks(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, RemoteCallbacks_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RemoteCallbacks expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_remote_callbacks * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_remote_callbacks(opts));

  /* Invocation */
  int native_return_value = git_remote_init_callbacks(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_is_valid_name */
/* sha: d6e1f12aefd3f5f38096ae78cb100b0387dbcda3dc7fb8100dc49a2af1d1d0b0 */
#if BIND_git_remote_is_valid_name_FUNCTION
#define git_remote_is_valid_name_REQUIRED_ARGC 1
#define git_remote_is_valid_name_OPTIONAL_ARGC 0
/* git_remote_is_valid_name
 *
 * Parameters:
 * - remote_name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_is_valid_name(mrb_state* mrb, mrb_value self) {
  char * native_remote_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_remote_name);

  /* Invocation */
  int native_return_value = git_remote_is_valid_name(native_remote_name);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_list */
/* sha: 442a152518613e15edb858a8a362c65ae2b271266ee4df9360d4df486f2542a2 */
#if BIND_git_remote_list_FUNCTION
#define git_remote_list_REQUIRED_ARGC 1
#define git_remote_list_OPTIONAL_ARGC 0
/* git_remote_list
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_list(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_strarray * native_out = (git_strarray*)calloc(1, sizeof(git_strarray));
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_list(native_out, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_strarray(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_lookup */
/* sha: 2509df4343cdc1ce422d8e3182ccd7bffc3c3f1c3d01a8f0679b6acca8a84155 */
#if BIND_git_remote_lookup_FUNCTION
#define git_remote_lookup_REQUIRED_ARGC 2
#define git_remote_lookup_OPTIONAL_ARGC 0
/* git_remote_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_lookup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_remote * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_lookup(&native_out, native_repo, native_name);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_remote(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_ls */
/* sha: 9a00218b6d61a9e1d1b90f94a657ad03e52f75b4ac308ccb7c18602871dad893 */
#if BIND_git_remote_ls_FUNCTION
#define git_remote_ls_REQUIRED_ARGC 2
#define git_remote_ls_OPTIONAL_ARGC 0
/* git_remote_ls
 *
 * Parameters:
 * - out: const git_remote_head ***
 * - remote: git_remote *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_ls(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  int native_size;
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &remote);

  /* Type checking */
  TODO_type_check_git_remote_head_PTR_PTR_PTR(out);
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  const git_remote_head *** native_out = TODO_mruby_unbox_git_remote_head_PTR_PTR_PTR(out);

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  int native_return_value = git_remote_ls(native_out, &native_size, native_remote);

  /* Box out param: size */
  mrb_value size = mrb_fixnum_value(native_size);

  RAISE_GIT_ERROR(native_return_value);

  return size;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_name */
/* sha: d77c09691cfed316276d3bde473c2da5b3030a0315913de7c91d4cd9fade2d35 */
#if BIND_git_remote_name_FUNCTION
#define git_remote_name_REQUIRED_ARGC 1
#define git_remote_name_OPTIONAL_ARGC 0
/* git_remote_name
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_remote_name(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  const char * native_return_value = git_remote_name(native_remote);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_owner */
/* sha: da6aa02801b5718200b6d3c3277931c96671ac4e249f43a6e10895b79043f24d */
#if BIND_git_remote_owner_FUNCTION
#define git_remote_owner_REQUIRED_ARGC 1
#define git_remote_owner_OPTIONAL_ARGC 0
/* git_remote_owner
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_remote_owner(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  git_repository * native_return_value = git_remote_owner(native_remote);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_prune */
/* sha: 2ffe9ee3893041b27a8cd13831a7dcd2c5562a3b73d5ac6310bedfc74bca1f1a */
#if BIND_git_remote_prune_FUNCTION
#define git_remote_prune_REQUIRED_ARGC 2
#define git_remote_prune_OPTIONAL_ARGC 0
/* git_remote_prune
 *
 * Parameters:
 * - remote: git_remote *
 * - callbacks: const git_remote_callbacks *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_prune(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value remote;
  mrb_value callbacks;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &remote, &callbacks);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, callbacks, RemoteCallbacks_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RemoteCallbacks expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Unbox param: callbacks */
  const git_remote_callbacks * native_callbacks = (mrb_nil_p(callbacks) ? NULL : mruby_unbox_git_remote_callbacks(callbacks));

  /* Invocation */
  int native_return_value = git_remote_prune(native_remote, native_callbacks);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_prune_refs */
/* sha: 65116335714650e85bd450f369944d170238682d29cf136a799394349330e943 */
#if BIND_git_remote_prune_refs_FUNCTION
#define git_remote_prune_refs_REQUIRED_ARGC 1
#define git_remote_prune_refs_OPTIONAL_ARGC 0
/* git_remote_prune_refs
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_prune_refs(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  int native_return_value = git_remote_prune_refs(native_remote);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_push */
/* sha: 96dbd7c4868983c5c8ce0ed435c8275c7116affe0c6a2c5dfdc8fedea5872561 */
#if BIND_git_remote_push_FUNCTION
#define git_remote_push_REQUIRED_ARGC 3
#define git_remote_push_OPTIONAL_ARGC 0
/* git_remote_push
 *
 * Parameters:
 * - remote: git_remote *
 * - refspecs: const git_strarray *
 * - opts: const git_push_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_push(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value remote;
  mrb_value refspecs;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &remote, &refspecs, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, refspecs, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, PushOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PushOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Unbox param: refspecs */
  const git_strarray * native_refspecs = (mrb_nil_p(refspecs) ? NULL : mruby_unbox_git_strarray(refspecs));

  /* Unbox param: opts */
  const git_push_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_push_options(opts));

  /* Invocation */
  int native_return_value = git_remote_push(native_remote, native_refspecs, native_opts);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_pushurl */
/* sha: 4b52e0b378b8c44fe39be1c0456e991e11edcde8cc63767444ecb64183bdb602 */
#if BIND_git_remote_pushurl_FUNCTION
#define git_remote_pushurl_REQUIRED_ARGC 1
#define git_remote_pushurl_OPTIONAL_ARGC 0
/* git_remote_pushurl
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_remote_pushurl(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  const char * native_return_value = git_remote_pushurl(native_remote);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_refspec_count */
/* sha: 518506c97e0971614d325ae406a78e55a1b9fb4bb96be9a1b1a462f9ae920542 */
#if BIND_git_remote_refspec_count_FUNCTION
#define git_remote_refspec_count_REQUIRED_ARGC 1
#define git_remote_refspec_count_OPTIONAL_ARGC 0
/* git_remote_refspec_count
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_remote_refspec_count(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  size_t native_return_value = git_remote_refspec_count(native_remote);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_rename */
/* sha: d1eef039ddc7d4b5edbd305259d8db369dcec2fddf43d438e9ad16b99ffb18a0 */
#if BIND_git_remote_rename_FUNCTION
#define git_remote_rename_REQUIRED_ARGC 3
#define git_remote_rename_OPTIONAL_ARGC 0
/* git_remote_rename
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - new_name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_rename(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_strarray * native_problems = (git_strarray*)calloc(1, sizeof(git_strarray));
  mrb_value repo;
  char * native_name = NULL;
  char * native_new_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_name, &native_new_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_rename(native_problems, native_repo, native_name, native_new_name);

  /* Box out param: problems */
  mrb_value problems = native_problems == NULL ? mrb_nil_value() : mruby_giftwrap_git_strarray(mrb, native_problems);

  RAISE_GIT_ERROR(native_return_value);

  return problems;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_set_autotag */
/* sha: b5850145ec366e7f0ea0d4371e51a6fcaa2673e97812fcadde5ed1ca374c09a1 */
#if BIND_git_remote_set_autotag_FUNCTION
#define git_remote_set_autotag_REQUIRED_ARGC 3
#define git_remote_set_autotag_OPTIONAL_ARGC 0
/* git_remote_set_autotag
 *
 * Parameters:
 * - repo: git_repository *
 * - remote: const char *
 * - value: git_remote_autotag_option_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_set_autotag(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_remote = NULL;
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &repo, &native_remote, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_set_autotag(native_repo, native_remote, native_value);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_set_pushurl */
/* sha: fb5e7cc7ce2a67eb8afcd782b181ea1d4b2195e435d0a2d48b2a723e2ceadef3 */
#if BIND_git_remote_set_pushurl_FUNCTION
#define git_remote_set_pushurl_REQUIRED_ARGC 3
#define git_remote_set_pushurl_OPTIONAL_ARGC 0
/* git_remote_set_pushurl
 *
 * Parameters:
 * - repo: git_repository *
 * - remote: const char *
 * - url: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_set_pushurl(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_remote = NULL;
  char * native_url = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_remote, &native_url);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_set_pushurl(native_repo, native_remote, native_url);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_set_url */
/* sha: 8b48fc97cd7afd53228d922dca4436d58394f7eaa455d7375517ca581319024e */
#if BIND_git_remote_set_url_FUNCTION
#define git_remote_set_url_REQUIRED_ARGC 3
#define git_remote_set_url_OPTIONAL_ARGC 0
/* git_remote_set_url
 *
 * Parameters:
 * - repo: git_repository *
 * - remote: const char *
 * - url: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_set_url(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_remote = NULL;
  char * native_url = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_remote, &native_url);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_remote_set_url(native_repo, native_remote, native_url);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_stats */
/* sha: b5bdf9dc2c97b5a86a5411694dd0422d350b900546de391dc360442fe35c8a70 */
#if BIND_git_remote_stats_FUNCTION
#define git_remote_stats_REQUIRED_ARGC 1
#define git_remote_stats_OPTIONAL_ARGC 0
/* git_remote_stats
 *
 * Parameters:
 * - remote: git_remote *
 * Return Type: const git_transfer_progress *
 */
mrb_value
mrb_Git_git_remote_stats(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  const git_transfer_progress * native_return_value = git_remote_stats(native_remote);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_transfer_progress(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_stop */
/* sha: 635ac15a912f4c25b60879e1ebddc5ffcf5bf4b6e5fcdd2a8d415109fde804b7 */
#if BIND_git_remote_stop_FUNCTION
#define git_remote_stop_REQUIRED_ARGC 1
#define git_remote_stop_OPTIONAL_ARGC 0
/* git_remote_stop
 *
 * Parameters:
 * - remote: git_remote *
 * Return Type: void
 */
mrb_value
mrb_Git_git_remote_stop(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  git_remote_stop(native_remote);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_update_tips */
/* sha: 0722548b8dc3afcb9d1218f4e0638616ab881976f230cf85b00cc3e3cfdd8a91 */
#if BIND_git_remote_update_tips_FUNCTION
#define git_remote_update_tips_REQUIRED_ARGC 5
#define git_remote_update_tips_OPTIONAL_ARGC 0
/* git_remote_update_tips
 *
 * Parameters:
 * - remote: git_remote *
 * - callbacks: const git_remote_callbacks *
 * - update_fetchhead: int
 * - download_tags: git_remote_autotag_option_t
 * - reflog_message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_update_tips(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value remote;
  mrb_value callbacks;
  mrb_int native_update_fetchhead;
  mrb_int native_download_tags;
  char * native_reflog_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooiiz", &remote, &callbacks, &native_update_fetchhead, &native_download_tags, &native_reflog_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, callbacks, RemoteCallbacks_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RemoteCallbacks expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Unbox param: callbacks */
  const git_remote_callbacks * native_callbacks = (mrb_nil_p(callbacks) ? NULL : mruby_unbox_git_remote_callbacks(callbacks));

  /* Invocation */
  int native_return_value = git_remote_update_tips(native_remote, native_callbacks, native_update_fetchhead, native_download_tags, native_reflog_message);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_upload */
/* sha: 0315ff8e5f9391b539b6ba40ab89af75782429e396d228d9d24db4c963b9d7c8 */
#if BIND_git_remote_upload_FUNCTION
#define git_remote_upload_REQUIRED_ARGC 3
#define git_remote_upload_OPTIONAL_ARGC 0
/* git_remote_upload
 *
 * Parameters:
 * - remote: git_remote *
 * - refspecs: const git_strarray *
 * - opts: const git_push_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_remote_upload(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value remote;
  mrb_value refspecs;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &remote, &refspecs, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, refspecs, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, PushOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "PushOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Unbox param: refspecs */
  const git_strarray * native_refspecs = (mrb_nil_p(refspecs) ? NULL : mruby_unbox_git_strarray(refspecs));

  /* Unbox param: opts */
  const git_push_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_push_options(opts));

  /* Invocation */
  int native_return_value = git_remote_upload(native_remote, native_refspecs, native_opts);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_remote_url */
/* sha: b41eea3d5b787b6cc32d6a360d8248d4e1171ac054af5bfc06b2b800fc7f5564 */
#if BIND_git_remote_url_FUNCTION
#define git_remote_url_REQUIRED_ARGC 1
#define git_remote_url_OPTIONAL_ARGC 0
/* git_remote_url
 *
 * Parameters:
 * - remote: const git_remote *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_remote_url(mrb_state* mrb, mrb_value self) {
  mrb_value remote;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &remote);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, remote, Remote_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Remote expected");
    return mrb_nil_value();
  }

  /* Unbox param: remote */
  const git_remote * native_remote = (mrb_nil_p(remote) ? NULL : mruby_unbox_git_remote(remote));

  /* Invocation */
  const char * native_return_value = git_remote_url(native_remote);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_config */
/* sha: 7d6b7cea3b6bca82745772362ab5eb3c7f2c441d02b91eebfd03fb0132647839 */
#if BIND_git_repository_config_FUNCTION
#define git_repository_config_REQUIRED_ARGC 1
#define git_repository_config_OPTIONAL_ARGC 0
/* git_repository_config
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_config(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_config * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_config(&native_out, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_config_snapshot */
/* sha: 2f46d580a4f42253e7ada72cdf307708cd4f6c748f35eddd237eed3d4932c300 */
#if BIND_git_repository_config_snapshot_FUNCTION
#define git_repository_config_snapshot_REQUIRED_ARGC 1
#define git_repository_config_snapshot_OPTIONAL_ARGC 0
/* git_repository_config_snapshot
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_config_snapshot(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_config * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_config_snapshot(&native_out, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_config(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_detach_head */
/* sha: 180b6d8a829ada99d8a8b25100a5dca77f2669d7d97dc0b7de54a77bfefb0f26 */
#if BIND_git_repository_detach_head_FUNCTION
#define git_repository_detach_head_REQUIRED_ARGC 1
#define git_repository_detach_head_OPTIONAL_ARGC 0
/* git_repository_detach_head
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_detach_head(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_detach_head(native_repo);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_discover */
/* sha: 6718271ddc97ed6370bd0a83a73f9fbcbde28fd4bc1edb913c146c938f180ff7 */
#if BIND_git_repository_discover_FUNCTION
#define git_repository_discover_REQUIRED_ARGC 1
#define git_repository_discover_OPTIONAL_ARGC 2
/* git_repository_discover
 *
 * Parameters:
 * - start_path: const char *
 * - across_fs: int
 * - ceiling_dirs: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_discover(mrb_state* mrb, mrb_value self) {
  giterr_clear();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  char * native_start_path = NULL;
  mrb_int native_across_fs = 0;
  char * native_ceiling_dirs = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z|iz", &native_start_path, &native_across_fs, &native_ceiling_dirs);

  /* Invocation */
  int native_return_value = git_repository_discover(native_out, native_start_path, native_across_fs, native_ceiling_dirs);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);
  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_fetchhead_foreach */
/* sha: 32693f32ad0782dc9e89a262de941b134a70475364d62bad5e224c64d528fccd */
#if BIND_git_repository_fetchhead_foreach_FUNCTION
#define git_repository_fetchhead_foreach_REQUIRED_ARGC 3
#define git_repository_fetchhead_foreach_OPTIONAL_ARGC 0
/* git_repository_fetchhead_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_repository_fetchhead_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_fetchhead_foreach(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_repository_fetchhead_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_repository_fetchhead_foreach_cb native_callback = TODO_mruby_unbox_git_repository_fetchhead_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_repository_fetchhead_foreach(native_repo, native_callback, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_free */
/* sha: 0b9e2daeeb2f198f45486ad4b9c0c5e7193e8a10a8227930403b06147e3732b6 */
#if BIND_git_repository_free_FUNCTION
#define git_repository_free_REQUIRED_ARGC 1
#define git_repository_free_OPTIONAL_ARGC 0
/* git_repository_free
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: void
 */
mrb_value
mrb_Git_git_repository_free(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  git_repository_free(native_repo);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_get_namespace */
/* sha: d83bd5e8f93eab4b5a5dfefbe55140b8fc7f6775eac6a89c8e30da1a481f3460 */
#if BIND_git_repository_get_namespace_FUNCTION
#define git_repository_get_namespace_REQUIRED_ARGC 1
#define git_repository_get_namespace_OPTIONAL_ARGC 0
/* git_repository_get_namespace
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_repository_get_namespace(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  const char * native_return_value = git_repository_get_namespace(native_repo);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_hashfile */
/* sha: 56f877d67f6de3460b060dad403b42638e7e81b0283f7f9c9b85868f85180251 */
#if BIND_git_repository_hashfile_FUNCTION
#define git_repository_hashfile_REQUIRED_ARGC 5
#define git_repository_hashfile_OPTIONAL_ARGC 0
/* git_repository_hashfile
 *
 * Parameters:
 * - out: git_oid *
 * - repo: git_repository *
 * - path: const char *
 * - type: git_otype
 * - as_path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_hashfile(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  mrb_value repo;
  char * native_path = NULL;
  mrb_int native_type;
  char * native_as_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooziz", &out, &repo, &native_path, &native_type, &native_as_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_hashfile(native_out, native_repo, native_path, native_type, native_as_path);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_head */
/* sha: 5fd5449e166ce7a746f2618f5742a9435ebed3d07186160015c050a7aee934d9 */
#if BIND_git_repository_head_FUNCTION
#define git_repository_head_REQUIRED_ARGC 1
#define git_repository_head_OPTIONAL_ARGC 0
/* git_repository_head
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_head(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_reference * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_head(&native_out, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_head_detached */
/* sha: 831ca1435d5816f1055cac1183bfee1578a2f24e489fe4767b5ad5df992ab1a0 */
#if BIND_git_repository_head_detached_FUNCTION
#define git_repository_head_detached_REQUIRED_ARGC 1
#define git_repository_head_detached_OPTIONAL_ARGC 0
/* git_repository_head_detached
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_head_detached(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_head_detached(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_head_unborn */
/* sha: dc524de86915875485ae7ce2479080d3d789c8582b61c09e60722ee975edfe03 */
#if BIND_git_repository_head_unborn_FUNCTION
#define git_repository_head_unborn_REQUIRED_ARGC 1
#define git_repository_head_unborn_OPTIONAL_ARGC 0
/* git_repository_head_unborn
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_head_unborn(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_head_unborn(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_ident */
/* sha: 2b064c56a7bdeadc8e7e75cb5dafadaf7cfdc11163107ff799ca58573364b111 */
#if BIND_git_repository_ident_FUNCTION
#define git_repository_ident_REQUIRED_ARGC 1
#define git_repository_ident_OPTIONAL_ARGC 0
/* git_repository_ident
 *
 * Parameters:
 * - repo: const git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_ident(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value results = mrb_ary_new(mrb);
  char * native_name = NULL;
  char * native_email = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  const git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_ident(&native_name, &native_email, native_repo);

  /* Box out param: name */
  mrb_value name = native_name ==  NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_name);
  /* Box out param: email */
  mrb_value email = native_email ==  NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_email);

  /* Add out params to results */
  mrb_ary_push(mrb, results, name);
  mrb_ary_push(mrb, results, email);

  RAISE_GIT_ERROR(native_return_value);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_index */
/* sha: e6595f151dcad8c2ef855d3ca906a8f1a9a51088119716de5195d57ea32073b5 */
#if BIND_git_repository_index_FUNCTION
#define git_repository_index_REQUIRED_ARGC 1
#define git_repository_index_OPTIONAL_ARGC 0
/* git_repository_index
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_index(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_index * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_index(&native_out, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_init */
/* sha: 7715b5970a6983ecc4f008d7cf049b64c14b21f783457a5b4fa993deeaded328 */
#if BIND_git_repository_init_FUNCTION
#define git_repository_init_REQUIRED_ARGC 2
#define git_repository_init_OPTIONAL_ARGC 0
/* git_repository_init
 *
 * Parameters:
 * - path: const char *
 * - is_bare: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_init(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  git_repository * native_out = NULL;
  char * native_path = NULL;
  mrb_value is_bare;
  int native_is_bare;

  /* Fetch the args */
  mrb_get_args(mrb, "zo", &native_path, &is_bare);
  
  native_is_bare = mrb_test(is_bare);

  /* Invocation */
  int native_return_value = git_repository_init(&native_out, native_path, native_is_bare);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_init_ext */
/* sha: 98e231d1a582205436c519872b175f2f16d0c9751ef2de71ddfbde7eb6569056 */
#if BIND_git_repository_init_ext_FUNCTION
#define git_repository_init_ext_REQUIRED_ARGC 2
#define git_repository_init_ext_OPTIONAL_ARGC 0
/* git_repository_init_ext
 *
 * Parameters:
 * - repo_path: const char *
 * - opts: git_repository_init_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_init_ext(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_repository * native_out = NULL;
  char * native_repo_path = NULL;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "zo", &native_repo_path, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, RepositoryInitOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RepositoryInitOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_repository_init_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_repository_init_options(opts));

  /* Invocation */
  int native_return_value = git_repository_init_ext(&native_out, native_repo_path, native_opts);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_init_init_options */
/* sha: 75db10b96cc300f26e361c3595d95a79f8fb76e4872cce2d3d3893ac70e9ba13 */
#if BIND_git_repository_init_init_options_FUNCTION
#define git_repository_init_init_options_REQUIRED_ARGC 2
#define git_repository_init_init_options_OPTIONAL_ARGC 0
/* git_repository_init_init_options
 *
 * Parameters:
 * - opts: git_repository_init_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_init_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, RepositoryInitOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RepositoryInitOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_repository_init_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_repository_init_options(opts));

  /* Invocation */
  int native_return_value = git_repository_init_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_is_bare */
/* sha: 779b7d8874d292f5343ecd8ee1497be6cb09086391db0a913c806299a7bca431 */
#if BIND_git_repository_is_bare_FUNCTION
#define git_repository_is_bare_REQUIRED_ARGC 1
#define git_repository_is_bare_OPTIONAL_ARGC 0
/* git_repository_is_bare
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_is_bare(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_is_bare(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_is_empty */
/* sha: 9aa4bbe40dcbd1149b7a71420adaca27317c6b0cd92e1b1073285fc7c1c764f7 */
#if BIND_git_repository_is_empty_FUNCTION
#define git_repository_is_empty_REQUIRED_ARGC 1
#define git_repository_is_empty_OPTIONAL_ARGC 0
/* git_repository_is_empty
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_is_empty(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_is_empty(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_is_shallow */
/* sha: 6b8f2cc109f633d3bba86e0577923f469b4cdd3ed69cfcbfa7a4b9c27061f1d2 */
#if BIND_git_repository_is_shallow_FUNCTION
#define git_repository_is_shallow_REQUIRED_ARGC 1
#define git_repository_is_shallow_OPTIONAL_ARGC 0
/* git_repository_is_shallow
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_is_shallow(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_is_shallow(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_bool_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_mergehead_foreach */
/* sha: 3fdf6ec90b19dc4c78af5715e85b3f45556f4aee2333544d53c67b367e62a6b9 */
#if BIND_git_repository_mergehead_foreach_FUNCTION
#define git_repository_mergehead_foreach_REQUIRED_ARGC 3
#define git_repository_mergehead_foreach_OPTIONAL_ARGC 0
/* git_repository_mergehead_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_repository_mergehead_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_mergehead_foreach(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_repository_mergehead_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_repository_mergehead_foreach_cb native_callback = TODO_mruby_unbox_git_repository_mergehead_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_repository_mergehead_foreach(native_repo, native_callback, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_message */
/* sha: 355e2b01f0c2ba6165150226bc68f72d2f63d53b8fa781ef765647273c020368 */
#if BIND_git_repository_message_FUNCTION
#define git_repository_message_REQUIRED_ARGC 1
#define git_repository_message_OPTIONAL_ARGC 0
/* git_repository_message
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_message(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_message(native_out, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_message_remove */
/* sha: 691dcf0a44d2d35eb77eb42112fd7f1d32c14e47c2eb90208603ce38900b1461 */
#if BIND_git_repository_message_remove_FUNCTION
#define git_repository_message_remove_REQUIRED_ARGC 1
#define git_repository_message_remove_OPTIONAL_ARGC 0
/* git_repository_message_remove
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_message_remove(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_message_remove(native_repo);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_odb */
/* sha: 88b2c8e38e624431aad0bde9a7bcff1a335bcaaa4d8aa54e8d416f31a93d6f2f */
#if BIND_git_repository_odb_FUNCTION
#define git_repository_odb_REQUIRED_ARGC 1
#define git_repository_odb_OPTIONAL_ARGC 0
/* git_repository_odb
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_odb(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_odb * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_odb(&native_out, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_odb(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_open */
/* sha: 9825dea103d7b3809fea462d7758141739e97154317f3108990763f67b71de25 */
#if BIND_git_repository_open_FUNCTION
#define git_repository_open_REQUIRED_ARGC 1
#define git_repository_open_OPTIONAL_ARGC 0
/* git_repository_open
 *
 * Parameters:
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_open(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_repository * native_out = NULL;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_path);

  /* Invocation */
  int native_return_value = git_repository_open(&native_out, native_path);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_open_bare */
/* sha: 200424fdb17f22a1c46f68f77434371ddbc6d9999cfab75fee759c7a660f2c65 */
#if BIND_git_repository_open_bare_FUNCTION
#define git_repository_open_bare_REQUIRED_ARGC 1
#define git_repository_open_bare_OPTIONAL_ARGC 0
/* git_repository_open_bare
 *
 * Parameters:
 * - bare_path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_open_bare(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_repository * native_out = NULL;
  char * native_bare_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z", &native_bare_path);

  /* Invocation */
  int native_return_value = git_repository_open_bare(&native_out, native_bare_path);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_open_ext */
/* sha: a86c404cb877d9452cc66df45ae6b0632d624c7fd9f17159b1ac14aea32ee9df */
#if BIND_git_repository_open_ext_FUNCTION
#define git_repository_open_ext_REQUIRED_ARGC 1
#define git_repository_open_ext_OPTIONAL_ARGC 2
/* git_repository_open_ext
 *
 * Parameters:
 * - path: const char *
 * - flags: unsigned int
 * - ceiling_dirs: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_open_ext(mrb_state* mrb, mrb_value self) {
  giterr_clear();
  mrb_value results = mrb_ary_new(mrb);
  git_repository * native_out = NULL;
  char * native_path = NULL;
  mrb_int native_flags = 0;
  char * native_ceiling_dirs = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z|iz", &native_path, &native_flags, &native_ceiling_dirs);

  /* Invocation */
  int native_return_value = git_repository_open_ext(&native_out, native_path, native_flags, native_ceiling_dirs);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, out);

  RAISE_GIT_ERROR(native_return_value);
  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_path */
/* sha: 88fa0935245a2190d257f38feef8cfae64952fbb870af4b43ff44ced4a0e6331 */
#if BIND_git_repository_path_FUNCTION
#define git_repository_path_REQUIRED_ARGC 1
#define git_repository_path_OPTIONAL_ARGC 0
/* git_repository_path
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_repository_path(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  const char * native_return_value = git_repository_path(native_repo);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_refdb */
/* sha: 28696b2f1ed387af561e32d4334322370e6ad639f374491f92914f378d9cdfe3 */
#if BIND_git_repository_refdb_FUNCTION
#define git_repository_refdb_REQUIRED_ARGC 1
#define git_repository_refdb_OPTIONAL_ARGC 0
/* git_repository_refdb
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_refdb(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_refdb * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_refdb(&native_out, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_refdb(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_set_head */
/* sha: f0a4681472f3228db8a7a824830db47ea024cc22e5533cd02523da4f7d664b8f */
#if BIND_git_repository_set_head_FUNCTION
#define git_repository_set_head_REQUIRED_ARGC 2
#define git_repository_set_head_OPTIONAL_ARGC 0
/* git_repository_set_head
 *
 * Parameters:
 * - repo: git_repository *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_set_head(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_set_head(native_repo, native_refname);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_set_head_detached */
/* sha: 385053baea5c085c3b4ed6404c174167516c0f0aa862b367547dae25c3214fae */
#if BIND_git_repository_set_head_detached_FUNCTION
#define git_repository_set_head_detached_REQUIRED_ARGC 2
#define git_repository_set_head_detached_OPTIONAL_ARGC 0
/* git_repository_set_head_detached
 *
 * Parameters:
 * - repo: git_repository *
 * - commitish: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_set_head_detached(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value commitish;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &commitish);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commitish, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: commitish */
  const git_oid * native_commitish = (mrb_nil_p(commitish) ? NULL : mruby_unbox_git_oid(commitish));

  /* Invocation */
  int native_return_value = git_repository_set_head_detached(native_repo, native_commitish);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_set_head_detached_from_annotated */
/* sha: 796773f175f677134a13e0f7bd1e420e55777e3a6c5823d140c350ff38175916 */
#if BIND_git_repository_set_head_detached_from_annotated_FUNCTION
#define git_repository_set_head_detached_from_annotated_REQUIRED_ARGC 2
#define git_repository_set_head_detached_from_annotated_OPTIONAL_ARGC 0
/* git_repository_set_head_detached_from_annotated
 *
 * Parameters:
 * - repo: git_repository *
 * - commitish: const git_annotated_commit *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_set_head_detached_from_annotated(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value commitish;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &commitish);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commitish, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: commitish */
  const git_annotated_commit * native_commitish = (mrb_nil_p(commitish) ? NULL : mruby_unbox_git_annotated_commit(commitish));

  /* Invocation */
  int native_return_value = git_repository_set_head_detached_from_annotated(native_repo, native_commitish);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_set_ident */
/* sha: 90b20793948dc79130b6242bb0a1a74f2856899f58b44b647e71ab71470c056b */
#if BIND_git_repository_set_ident_FUNCTION
#define git_repository_set_ident_REQUIRED_ARGC 3
#define git_repository_set_ident_OPTIONAL_ARGC 0
/* git_repository_set_ident
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - email: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_set_ident(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_name = NULL;
  char * native_email = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_name, &native_email);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_set_ident(native_repo, native_name, native_email);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_set_namespace */
/* sha: 39b00a734d0d06c42d9332e7a5baca50704233a7a03b8545d192efcd683006a3 */
#if BIND_git_repository_set_namespace_FUNCTION
#define git_repository_set_namespace_REQUIRED_ARGC 2
#define git_repository_set_namespace_OPTIONAL_ARGC 0
/* git_repository_set_namespace
 *
 * Parameters:
 * - repo: git_repository *
 * - nmspace: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_set_namespace(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_nmspace = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_nmspace);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_set_namespace(native_repo, native_nmspace);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_set_workdir */
/* sha: faaf266aa986cd03f751c9db8b3d8dad2d27d6c1e20137cecac2ec7056053e84 */
#if BIND_git_repository_set_workdir_FUNCTION
#define git_repository_set_workdir_REQUIRED_ARGC 3
#define git_repository_set_workdir_OPTIONAL_ARGC 0
/* git_repository_set_workdir
 *
 * Parameters:
 * - repo: git_repository *
 * - workdir: const char *
 * - update_gitlink: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_set_workdir(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_workdir = NULL;
  mrb_int native_update_gitlink;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &repo, &native_workdir, &native_update_gitlink);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_set_workdir(native_repo, native_workdir, native_update_gitlink);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_state */
/* sha: fe390c57a2d0361409659bce8e2cde2d5db06a16bc9b4082966af3c0534b7740 */
#if BIND_git_repository_state_FUNCTION
#define git_repository_state_REQUIRED_ARGC 1
#define git_repository_state_OPTIONAL_ARGC 0
/* git_repository_state
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_state(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_state(native_repo);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_state_cleanup */
/* sha: 8b2afeebf8a12bc68a38e64d8ef6f68e7970412e4e3f3475a09b20acec807f4a */
#if BIND_git_repository_state_cleanup_FUNCTION
#define git_repository_state_cleanup_REQUIRED_ARGC 1
#define git_repository_state_cleanup_OPTIONAL_ARGC 0
/* git_repository_state_cleanup
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_state_cleanup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_repository_state_cleanup(native_repo);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_workdir */
/* sha: f18c5e76df2aa2dc1907cc85a5276ad8d6be2608791716978933e74c1c3ea128 */
#if BIND_git_repository_workdir_FUNCTION
#define git_repository_workdir_REQUIRED_ARGC 1
#define git_repository_workdir_OPTIONAL_ARGC 0
/* git_repository_workdir
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_repository_workdir(mrb_state* mrb, mrb_value self) {
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  const char * native_return_value = git_repository_workdir(native_repo);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_repository_wrap_odb */
/* sha: d3212c601a1bc4272dff81943762b1457ddc4753da782e5ce42927581dc1407e */
#if BIND_git_repository_wrap_odb_FUNCTION
#define git_repository_wrap_odb_REQUIRED_ARGC 1
#define git_repository_wrap_odb_OPTIONAL_ARGC 0
/* git_repository_wrap_odb
 *
 * Parameters:
 * - odb: git_odb *
 * Return Type: int
 */
mrb_value
mrb_Git_git_repository_wrap_odb(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_repository * native_out = NULL;
  mrb_value odb;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &odb);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, odb, Odb_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Odb expected");
    return mrb_nil_value();
  }

  /* Unbox param: odb */
  git_odb * native_odb = (mrb_nil_p(odb) ? NULL : mruby_unbox_git_odb(odb));

  /* Invocation */
  int native_return_value = git_repository_wrap_odb(&native_out, native_odb);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reset */
/* sha: 29f2358b7983196e285cb5e532e7df5fd940e92f06bdd7f06687268a51986a01 */
#if BIND_git_reset_FUNCTION
#define git_reset_REQUIRED_ARGC 4
#define git_reset_OPTIONAL_ARGC 0
/* git_reset
 *
 * Parameters:
 * - repo: git_repository *
 * - target: git_object *
 * - reset_type: git_reset_t
 * - checkout_opts: const git_checkout_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reset(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value target;
  mrb_int native_reset_type;
  mrb_value checkout_opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooio", &repo, &target, &native_reset_type, &checkout_opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, checkout_opts, CheckoutOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CheckoutOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: target */
  git_object * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_object(target));

  /* Unbox param: checkout_opts */
  const git_checkout_options * native_checkout_opts = (mrb_nil_p(checkout_opts) ? NULL : mruby_unbox_git_checkout_options(checkout_opts));

  /* Invocation */
  int native_return_value = git_reset(native_repo, native_target, native_reset_type, native_checkout_opts);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reset_default */
/* sha: e81db1eabd9b63e1421cc04e9ffd65171e82a213cd672af9cb0e8a81b9af51a1 */
#if BIND_git_reset_default_FUNCTION
#define git_reset_default_REQUIRED_ARGC 2
#define git_reset_default_OPTIONAL_ARGC 0
/* git_reset_default
 *
 * Parameters:
 * - repo: git_repository *
 * - target: git_object *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reset_default(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value target;
  git_strarray * native_pathspecs = (git_strarray*)calloc(1, sizeof(git_strarray));

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &target);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: target */
  git_object * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_object(target));

  /* Invocation */
  int native_return_value = git_reset_default(native_repo, native_target, native_pathspecs);

  /* Box out param: pathspecs */
  mrb_value pathspecs = native_pathspecs == NULL ? mrb_nil_value() : mruby_giftwrap_git_strarray(mrb, native_pathspecs);

  RAISE_GIT_ERROR(native_return_value);

  return pathspecs;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_reset_from_annotated */
/* sha: b624be8f711a6f972d671e2b07c51844af75d37ffbec748cccba6f59ead81c74 */
#if BIND_git_reset_from_annotated_FUNCTION
#define git_reset_from_annotated_REQUIRED_ARGC 4
#define git_reset_from_annotated_OPTIONAL_ARGC 0
/* git_reset_from_annotated
 *
 * Parameters:
 * - repo: git_repository *
 * - commit: git_annotated_commit *
 * - reset_type: git_reset_t
 * - checkout_opts: const git_checkout_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_reset_from_annotated(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value commit;
  mrb_int native_reset_type;
  mrb_value checkout_opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooio", &repo, &commit, &native_reset_type, &checkout_opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit, AnnotatedCommit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "AnnotatedCommit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, checkout_opts, CheckoutOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "CheckoutOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: commit */
  git_annotated_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_annotated_commit(commit));

  /* Unbox param: checkout_opts */
  const git_checkout_options * native_checkout_opts = (mrb_nil_p(checkout_opts) ? NULL : mruby_unbox_git_checkout_options(checkout_opts));

  /* Invocation */
  int native_return_value = git_reset_from_annotated(native_repo, native_commit, native_reset_type, native_checkout_opts);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revert */
/* sha: 7b20a808ec0abad491f27c0ec50dcadac82f35ea639e7fd548f0afed78688688 */
#if BIND_git_revert_FUNCTION
#define git_revert_REQUIRED_ARGC 3
#define git_revert_OPTIONAL_ARGC 0
/* git_revert
 *
 * Parameters:
 * - repo: git_repository *
 * - commit: git_commit *
 * - given_opts: const git_revert_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revert(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value commit;
  mrb_value given_opts;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &commit, &given_opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, given_opts, RevertOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RevertOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: commit */
  git_commit * native_commit = (mrb_nil_p(commit) ? NULL : mruby_unbox_git_commit(commit));

  /* Unbox param: given_opts */
  const git_revert_options * native_given_opts = (mrb_nil_p(given_opts) ? NULL : mruby_unbox_git_revert_options(given_opts));

  /* Invocation */
  int native_return_value = git_revert(native_repo, native_commit, native_given_opts);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revert_commit */
/* sha: 68f04d5e2b13417247b82bb4ec150ff3e85a5b641ecb42078a65ad85e624f0c1 */
#if BIND_git_revert_commit_FUNCTION
#define git_revert_commit_REQUIRED_ARGC 5
#define git_revert_commit_OPTIONAL_ARGC 0
/* git_revert_commit
 *
 * Parameters:
 * - repo: git_repository *
 * - revert_commit: git_commit *
 * - our_commit: git_commit *
 * - mainline: unsigned int
 * - merge_options: const git_merge_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revert_commit(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_index * native_out = NULL;
  mrb_value repo;
  mrb_value revert_commit;
  mrb_value our_commit;
  mrb_int native_mainline;
  mrb_value merge_options;

  /* Fetch the args */
  mrb_get_args(mrb, "oooio", &repo, &revert_commit, &our_commit, &native_mainline, &merge_options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, revert_commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, our_commit, Commit_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Commit expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, merge_options, MergeOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "MergeOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: revert_commit */
  git_commit * native_revert_commit = (mrb_nil_p(revert_commit) ? NULL : mruby_unbox_git_commit(revert_commit));

  /* Unbox param: our_commit */
  git_commit * native_our_commit = (mrb_nil_p(our_commit) ? NULL : mruby_unbox_git_commit(our_commit));

  /* Unbox param: merge_options */
  const git_merge_options * native_merge_options = (mrb_nil_p(merge_options) ? NULL : mruby_unbox_git_merge_options(merge_options));

  /* Invocation */
  int native_return_value = git_revert_commit(&native_out, native_repo, native_revert_commit, native_our_commit, native_mainline, native_merge_options);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_index(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revert_init_options */
/* sha: f4c586b0d2ad6d013439559717948861fe8f3d66bb7751414a235d98ac933b60 */
#if BIND_git_revert_init_options_FUNCTION
#define git_revert_init_options_REQUIRED_ARGC 2
#define git_revert_init_options_OPTIONAL_ARGC 0
/* git_revert_init_options
 *
 * Parameters:
 * - opts: git_revert_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_revert_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, RevertOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "RevertOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_revert_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_revert_options(opts));

  /* Invocation */
  int native_return_value = git_revert_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revparse */
/* sha: 8d2cab10cc0652530dffb27bc04931ff8da98f9074330fab3de35b7d396cecb1 */
#if BIND_git_revparse_FUNCTION
#define git_revparse_REQUIRED_ARGC 3
#define git_revparse_OPTIONAL_ARGC 0
/* git_revparse
 *
 * Parameters:
 * - revspec: git_revspec *
 * - repo: git_repository *
 * - spec: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revparse(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value revspec;
  mrb_value repo;
  char * native_spec = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &revspec, &repo, &native_spec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, revspec, Revspec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revspec expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: revspec */
  git_revspec * native_revspec = (mrb_nil_p(revspec) ? NULL : mruby_unbox_git_revspec(revspec));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_revparse(native_revspec, native_repo, native_spec);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revparse_ext */
/* sha: 530d4d92f0596c20a4f13d061ebf181558d7e49c6c1ed311e809626943ce70fa */
#if BIND_git_revparse_ext_FUNCTION
#define git_revparse_ext_REQUIRED_ARGC 2
#define git_revparse_ext_OPTIONAL_ARGC 0
/* git_revparse_ext
 *
 * Parameters:
 * - repo: git_repository *
 * - spec: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revparse_ext(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value results = mrb_ary_new(mrb);
  git_object * native_object_out = NULL;
  git_reference * native_reference_out = NULL;
  mrb_value repo;
  char * native_spec = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_spec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_revparse_ext(&native_object_out, &native_reference_out, native_repo, native_spec);

  /* Box out param: object_out */
  mrb_value object_out = native_object_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_object_out);
  /* Box out param: reference_out */
  mrb_value reference_out = native_reference_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_reference(mrb, native_reference_out);

  /* Add out params to results */
  mrb_ary_push(mrb, results, object_out);
  mrb_ary_push(mrb, results, reference_out);

  RAISE_GIT_ERROR(native_return_value);

  return results;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revparse_single */
/* sha: 5a52eb4b997b3624d8a562b1ed39a7eac92d361fe1aa9a98de62d3b3898394aa */
#if BIND_git_revparse_single_FUNCTION
#define git_revparse_single_REQUIRED_ARGC 2
#define git_revparse_single_OPTIONAL_ARGC 0
/* git_revparse_single
 *
 * Parameters:
 * - repo: git_repository *
 * - spec: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revparse_single(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_object * native_out = NULL;
  mrb_value repo;
  char * native_spec = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_spec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_revparse_single(&native_out, native_repo, native_spec);

  /* Box out param: out */
  mrb_value out = mrb_nil_value();
  if (native_return_value == 0) {
    out = mruby_git_giftwrap_object_virtual(mrb, native_out);
  }

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_add_hide_cb */
/* sha: 82614b831ac5396899731c91bd276a87104fea5ae2cbcc2771fb25eaebc2a262 */
#if BIND_git_revwalk_add_hide_cb_FUNCTION
#define git_revwalk_add_hide_cb_REQUIRED_ARGC 3
#define git_revwalk_add_hide_cb_OPTIONAL_ARGC 0
/* git_revwalk_add_hide_cb
 *
 * Parameters:
 * - walk: git_revwalk *
 * - hide_cb: git_revwalk_hide_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_add_hide_cb(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value walk;
  mrb_value hide_cb;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &walk, &hide_cb, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_revwalk_hide_cb(hide_cb);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Unbox param: hide_cb */
  git_revwalk_hide_cb native_hide_cb = TODO_mruby_unbox_git_revwalk_hide_cb(hide_cb);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_revwalk_add_hide_cb(native_walk, native_hide_cb, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_free */
/* sha: 4a664613c18c06cb1e75cac0e83c3212b64cd5330a49c0568e2d295d0a46607f */
#if BIND_git_revwalk_free_FUNCTION
#define git_revwalk_free_REQUIRED_ARGC 1
#define git_revwalk_free_OPTIONAL_ARGC 0
/* git_revwalk_free
 *
 * Parameters:
 * - walk: git_revwalk *
 * Return Type: void
 */
mrb_value
mrb_Git_git_revwalk_free(mrb_state* mrb, mrb_value self) {
  mrb_value walk;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &walk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  git_revwalk_free(native_walk);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_hide */
/* sha: abfcdee5c0fe4d9dc64740a55a9c9c846f7b9e55b53e1043dcefd20381377f19 */
#if BIND_git_revwalk_hide_FUNCTION
#define git_revwalk_hide_REQUIRED_ARGC 2
#define git_revwalk_hide_OPTIONAL_ARGC 0
/* git_revwalk_hide
 *
 * Parameters:
 * - walk: git_revwalk *
 * - commit_id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_hide(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value walk;
  mrb_value commit_id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &walk, &commit_id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, commit_id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Unbox param: commit_id */
  const git_oid * native_commit_id = (mrb_nil_p(commit_id) ? NULL : mruby_unbox_git_oid(commit_id));

  /* Invocation */
  int native_return_value = git_revwalk_hide(native_walk, native_commit_id);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_hide_glob */
/* sha: adfb053551239d9773bae7edabc8b882a92dab7996fef5514d2bc2a2d6ff2ea7 */
#if BIND_git_revwalk_hide_glob_FUNCTION
#define git_revwalk_hide_glob_REQUIRED_ARGC 2
#define git_revwalk_hide_glob_OPTIONAL_ARGC 0
/* git_revwalk_hide_glob
 *
 * Parameters:
 * - walk: git_revwalk *
 * - glob: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_hide_glob(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value walk;
  char * native_glob = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &walk, &native_glob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_hide_glob(native_walk, native_glob);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_hide_head */
/* sha: 525ca28feb59b82ddeb6b318ec0d33a89f959ae8e745694e4f5dd96f20c07de1 */
#if BIND_git_revwalk_hide_head_FUNCTION
#define git_revwalk_hide_head_REQUIRED_ARGC 1
#define git_revwalk_hide_head_OPTIONAL_ARGC 0
/* git_revwalk_hide_head
 *
 * Parameters:
 * - walk: git_revwalk *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_hide_head(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value walk;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &walk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_hide_head(native_walk);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_hide_ref */
/* sha: f1de199e7410d0ff46d5469031dd873cd731008fe32e4b8c1165defd06321c16 */
#if BIND_git_revwalk_hide_ref_FUNCTION
#define git_revwalk_hide_ref_REQUIRED_ARGC 2
#define git_revwalk_hide_ref_OPTIONAL_ARGC 0
/* git_revwalk_hide_ref
 *
 * Parameters:
 * - walk: git_revwalk *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_hide_ref(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value walk;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &walk, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_hide_ref(native_walk, native_refname);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_new */
/* sha: d426efe740701759dcc1ef0686e62dce622790ecfa8aa7190c620e358f43b0af */
#if BIND_git_revwalk_new_FUNCTION
#define git_revwalk_new_REQUIRED_ARGC 1
#define git_revwalk_new_OPTIONAL_ARGC 0
/* git_revwalk_new
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_revwalk * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_revwalk_new(&native_out, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_revwalk(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_next */
/* sha: d9b41f88dcd2a04fe4d493354647584d57ed429cd0e7d21416dbcc60c1900071 */
#if BIND_git_revwalk_next_FUNCTION
#define git_revwalk_next_REQUIRED_ARGC 2
#define git_revwalk_next_OPTIONAL_ARGC 0
/* git_revwalk_next
 *
 * Parameters:
 * - out: git_oid *
 * - walk: git_revwalk *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_next(mrb_state* mrb, mrb_value self) {
  mrb_value out;
  mrb_value walk;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &out, &walk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_next(native_out, native_walk);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_push */
/* sha: 1c002042460b8a99c5471d383b79532504abbb06de7a405a0c70471728e68919 */
#if BIND_git_revwalk_push_FUNCTION
#define git_revwalk_push_REQUIRED_ARGC 2
#define git_revwalk_push_OPTIONAL_ARGC 0
/* git_revwalk_push
 *
 * Parameters:
 * - walk: git_revwalk *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_push(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value walk;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &walk, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_revwalk_push(native_walk, native_id);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_push_glob */
/* sha: a4f9cc6df4d419722b3da11f2b3b8788247a6e52a687a6ffd03343d1a95dcf5b */
#if BIND_git_revwalk_push_glob_FUNCTION
#define git_revwalk_push_glob_REQUIRED_ARGC 2
#define git_revwalk_push_glob_OPTIONAL_ARGC 0
/* git_revwalk_push_glob
 *
 * Parameters:
 * - walk: git_revwalk *
 * - glob: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_push_glob(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value walk;
  char * native_glob = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &walk, &native_glob);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_push_glob(native_walk, native_glob);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_push_head */
/* sha: 54076050ea6f624ca226e51cbdc6f9a886ee9d3a2d245acec2ac29a555d023ab */
#if BIND_git_revwalk_push_head_FUNCTION
#define git_revwalk_push_head_REQUIRED_ARGC 1
#define git_revwalk_push_head_OPTIONAL_ARGC 0
/* git_revwalk_push_head
 *
 * Parameters:
 * - walk: git_revwalk *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_push_head(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value walk;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &walk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_push_head(native_walk);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_push_range */
/* sha: 53114b34b61e5f505cf320e65ccf128d0ba849cf5fda0e4639560b0f58c9482e */
#if BIND_git_revwalk_push_range_FUNCTION
#define git_revwalk_push_range_REQUIRED_ARGC 2
#define git_revwalk_push_range_OPTIONAL_ARGC 0
/* git_revwalk_push_range
 *
 * Parameters:
 * - walk: git_revwalk *
 * - range: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_push_range(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value walk;
  char * native_range = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &walk, &native_range);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_push_range(native_walk, native_range);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_push_ref */
/* sha: cb047869f28d1581828f7efa886154a1b7c3404d4f31a29fdb9ce6afccb39b09 */
#if BIND_git_revwalk_push_ref_FUNCTION
#define git_revwalk_push_ref_REQUIRED_ARGC 2
#define git_revwalk_push_ref_OPTIONAL_ARGC 0
/* git_revwalk_push_ref
 *
 * Parameters:
 * - walk: git_revwalk *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_revwalk_push_ref(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value walk;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &walk, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  int native_return_value = git_revwalk_push_ref(native_walk, native_refname);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_repository */
/* sha: c61a01ab4a78edb139d29f5b39b8533bbc0a8e8297382d7e940b96a070a22b62 */
#if BIND_git_revwalk_repository_FUNCTION
#define git_revwalk_repository_REQUIRED_ARGC 1
#define git_revwalk_repository_OPTIONAL_ARGC 0
/* git_revwalk_repository
 *
 * Parameters:
 * - walk: git_revwalk *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_revwalk_repository(mrb_state* mrb, mrb_value self) {
  mrb_value walk;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &walk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  git_repository * native_return_value = git_revwalk_repository(native_walk);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_reset */
/* sha: 86c7c20e4b187a5cd832a82bc67be2f23ad209c917c4bb3d0fc1f64cc9649942 */
#if BIND_git_revwalk_reset_FUNCTION
#define git_revwalk_reset_REQUIRED_ARGC 1
#define git_revwalk_reset_OPTIONAL_ARGC 0
/* git_revwalk_reset
 *
 * Parameters:
 * - walker: git_revwalk *
 * Return Type: void
 */
mrb_value
mrb_Git_git_revwalk_reset(mrb_state* mrb, mrb_value self) {
  mrb_value walker;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &walker);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walker, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walker */
  git_revwalk * native_walker = (mrb_nil_p(walker) ? NULL : mruby_unbox_git_revwalk(walker));

  /* Invocation */
  git_revwalk_reset(native_walker);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_simplify_first_parent */
/* sha: c447f9d3479e113a371fa48155a102fae443a05f0e93f090eb4accd02bc0a0e0 */
#if BIND_git_revwalk_simplify_first_parent_FUNCTION
#define git_revwalk_simplify_first_parent_REQUIRED_ARGC 1
#define git_revwalk_simplify_first_parent_OPTIONAL_ARGC 0
/* git_revwalk_simplify_first_parent
 *
 * Parameters:
 * - walk: git_revwalk *
 * Return Type: void
 */
mrb_value
mrb_Git_git_revwalk_simplify_first_parent(mrb_state* mrb, mrb_value self) {
  mrb_value walk;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &walk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  git_revwalk_simplify_first_parent(native_walk);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_revwalk_sorting */
/* sha: 7c62402bdb3ae1ba635328f24d66dd8f4150d26e364c39b75485f86a0f3328f7 */
#if BIND_git_revwalk_sorting_FUNCTION
#define git_revwalk_sorting_REQUIRED_ARGC 2
#define git_revwalk_sorting_OPTIONAL_ARGC 0
/* git_revwalk_sorting
 *
 * Parameters:
 * - walk: git_revwalk *
 * - sort_mode: unsigned int
 * Return Type: void
 */
mrb_value
mrb_Git_git_revwalk_sorting(mrb_state* mrb, mrb_value self) {
  mrb_value walk;
  mrb_int native_sort_mode;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &walk, &native_sort_mode);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, walk, Revwalk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Revwalk expected");
    return mrb_nil_value();
  }

  /* Unbox param: walk */
  git_revwalk * native_walk = (mrb_nil_p(walk) ? NULL : mruby_unbox_git_revwalk(walk));

  /* Invocation */
  git_revwalk_sorting(native_walk, native_sort_mode);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_signature_default */
/* sha: 180363feff27f3d4f4b5a77ce12cdb111ad89ca669a64cce67b7b82297cff235 */
#if BIND_git_signature_default_FUNCTION
#define git_signature_default_REQUIRED_ARGC 1
#define git_signature_default_OPTIONAL_ARGC 0
/* git_signature_default
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_signature_default(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_signature * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_signature_default(&native_out, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_signature(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_signature_dup */
/* sha: 53cf5819be9a45d62c6a203d0f7199bd133345bb99708ce869be64262f38fa4a */
#if BIND_git_signature_dup_FUNCTION
#define git_signature_dup_REQUIRED_ARGC 1
#define git_signature_dup_OPTIONAL_ARGC 0
/* git_signature_dup
 *
 * Parameters:
 * - sig: const git_signature *
 * Return Type: int
 */
mrb_value
mrb_Git_git_signature_dup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_signature * native_dest = NULL;
  mrb_value sig;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &sig);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, sig, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: sig */
  const git_signature * native_sig = (mrb_nil_p(sig) ? NULL : mruby_unbox_git_signature(sig));

  /* Invocation */
  int native_return_value = git_signature_dup(&native_dest, native_sig);

  /* Box out param: dest */
  mrb_value dest = native_dest == NULL ? mrb_nil_value() : mruby_giftwrap_git_signature(mrb, native_dest);

  RAISE_GIT_ERROR(native_return_value);

  return dest;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_signature_free */
/* sha: 05c158517a03633395b2736892296ee8481f59c4580d0561fe94f39592cc7a69 */
#if BIND_git_signature_free_FUNCTION
#define git_signature_free_REQUIRED_ARGC 1
#define git_signature_free_OPTIONAL_ARGC 0
/* git_signature_free
 *
 * Parameters:
 * - sig: git_signature *
 * Return Type: void
 */
mrb_value
mrb_Git_git_signature_free(mrb_state* mrb, mrb_value self) {
  mrb_value sig;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &sig);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, sig, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: sig */
  git_signature * native_sig = (mrb_nil_p(sig) ? NULL : mruby_unbox_git_signature(sig));

  /* Invocation */
  git_signature_free(native_sig);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_signature_new */
/* sha: 46a16082dc11c0de9c4fa30b59b0346693578472fe3a1bf72d22b435f3cd7962 */
#if BIND_git_signature_new_FUNCTION
#define git_signature_new_REQUIRED_ARGC 4
#define git_signature_new_OPTIONAL_ARGC 0
/* git_signature_new
 *
 * Parameters:
 * - name: const char *
 * - email: const char *
 * - time: git_time_t
 * - offset: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_signature_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_signature * native_out = NULL;
  char * native_name = NULL;
  char * native_email = NULL;
  mrb_int native_time;
  mrb_int native_offset;

  /* Fetch the args */
  mrb_get_args(mrb, "zzii", &native_name, &native_email, &native_time, &native_offset);

  /* Invocation */
  int native_return_value = git_signature_new(&native_out, native_name, native_email, native_time, native_offset);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_signature(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_signature_now */
/* sha: d80507851575d09dbfb8835852869e6a22d162cd4b894f69eb5d45e3ddd1028b */
#if BIND_git_signature_now_FUNCTION
#define git_signature_now_REQUIRED_ARGC 2
#define git_signature_now_OPTIONAL_ARGC 0
/* git_signature_now
 *
 * Parameters:
 * - name: const char *
 * - email: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_signature_now(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_signature * native_out = NULL;
  char * native_name = NULL;
  char * native_email = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "zz", &native_name, &native_email);

  /* Invocation */
  int native_return_value = git_signature_now(&native_out, native_name, native_email);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_signature(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_stash_apply */
/* sha: 2fc2c70021d5f555d40d5f021fcc03ca6e8d27c9093b07183fe5e05a3a146805 */
#if BIND_git_stash_apply_FUNCTION
#define git_stash_apply_REQUIRED_ARGC 3
#define git_stash_apply_OPTIONAL_ARGC 0
/* git_stash_apply
 *
 * Parameters:
 * - repo: git_repository *
 * - index: size_t
 * - options: const git_stash_apply_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_stash_apply(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_int native_index;
  mrb_value options;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &repo, &native_index, &options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, options, StashApplyOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StashApplyOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: options */
  const git_stash_apply_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_stash_apply_options(options));

  /* Invocation */
  int native_return_value = git_stash_apply(native_repo, native_index, native_options);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_stash_apply_init_options */
/* sha: 6f070deea7cd76eaa6976ca1c19af4a6f38f0f47e8a2b789dc3ef36d190cf5b9 */
#if BIND_git_stash_apply_init_options_FUNCTION
#define git_stash_apply_init_options_REQUIRED_ARGC 2
#define git_stash_apply_init_options_OPTIONAL_ARGC 0
/* git_stash_apply_init_options
 *
 * Parameters:
 * - opts: git_stash_apply_options *
 * - version: unsigned int
 * Return Type: int
 */
////// TODO: This is not exposed by the shared library yet. (https://github.com/libgit2/libgit2/pull/3584)
// mrb_value
// mrb_Git_git_stash_apply_init_options(mrb_state* mrb, mrb_value self) {
//   CLEAR_GIT_ERROR();
// 
//   mrb_value opts;
//   mrb_int native_version;
// 
//   /* Fetch the args */
//   mrb_get_args(mrb, "oi", &opts, &native_version);
// 
//   /* Type checking */
//   if (!mrb_obj_is_kind_of(mrb, opts, StashApplyOptions_class(mrb))) {
//     mrb_raise(mrb, E_TYPE_ERROR, "StashApplyOptions expected");
//     return mrb_nil_value();
//   }
// 
//   /* Unbox param: opts */
//   git_stash_apply_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_stash_apply_options(opts));
// 
//   /* Invocation */
//   int native_return_value = git_stash_apply_init_options(native_opts, native_version);
// 
//   RAISE_GIT_ERROR(native_return_value);
// 
//   return mrb_nil_value();
// }
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_stash_drop */
/* sha: 8f9e73640b35a0956e33a9d6bb245940206cf0aff83fcdfb44257fa186784af1 */
#if BIND_git_stash_drop_FUNCTION
#define git_stash_drop_REQUIRED_ARGC 2
#define git_stash_drop_OPTIONAL_ARGC 0
/* git_stash_drop
 *
 * Parameters:
 * - repo: git_repository *
 * - index: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_stash_drop(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_int native_index;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &repo, &native_index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_stash_drop(native_repo, native_index);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_stash_foreach */
/* sha: 8e693e6c20e127acd3a97141bca0a960585a9c63a65c60b882336a379de01151 */
#if BIND_git_stash_foreach_FUNCTION
#define git_stash_foreach_REQUIRED_ARGC 3
#define git_stash_foreach_OPTIONAL_ARGC 0
/* git_stash_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_stash_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_stash_foreach(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_stash_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_stash_cb native_callback = TODO_mruby_unbox_git_stash_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_stash_foreach(native_repo, native_callback, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_stash_pop */
/* sha: 5ba5602eef982f8b8f0b9af80f07d89f14b46f833463e260be74bbb50c21c1fe */
#if BIND_git_stash_pop_FUNCTION
#define git_stash_pop_REQUIRED_ARGC 3
#define git_stash_pop_OPTIONAL_ARGC 0
/* git_stash_pop
 *
 * Parameters:
 * - repo: git_repository *
 * - index: size_t
 * - options: const git_stash_apply_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_stash_pop(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_int native_index;
  mrb_value options;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &repo, &native_index, &options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, options, StashApplyOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StashApplyOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: options */
  const git_stash_apply_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_stash_apply_options(options));

  /* Invocation */
  int native_return_value = git_stash_pop(native_repo, native_index, native_options);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_stash_save */
/* sha: 5272ec6b9db293d6cffa7a4f2931f75aba3920c25f836857a2adff965b078dea */
#if BIND_git_stash_save_FUNCTION
#define git_stash_save_REQUIRED_ARGC 5
#define git_stash_save_OPTIONAL_ARGC 0
/* git_stash_save
 *
 * Parameters:
 * - out: git_oid *
 * - repo: git_repository *
 * - stasher: const git_signature *
 * - message: const char *
 * - flags: uint32_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_stash_save(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value out;
  mrb_value repo;
  mrb_value stasher;
  char * native_message = NULL;
  mrb_int native_flags;

  /* Fetch the args */
  mrb_get_args(mrb, "ooozi", &out, &repo, &stasher, &native_message, &native_flags);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, out, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, stasher, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: out */
  git_oid * native_out = (mrb_nil_p(out) ? NULL : mruby_unbox_git_oid(out));

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: stasher */
  const git_signature * native_stasher = (mrb_nil_p(stasher) ? NULL : mruby_unbox_git_signature(stasher));

  /* Invocation */
  int native_return_value = git_stash_save(native_out, native_repo, native_stasher, native_message, native_flags);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_byindex */
/* sha: 2c5a45b6d9881fb2e625bec9b700e5508d11870ffa88ebf59ca75e7ec6a7b428 */
#if BIND_git_status_byindex_FUNCTION
#define git_status_byindex_REQUIRED_ARGC 2
#define git_status_byindex_OPTIONAL_ARGC 0
/* git_status_byindex
 *
 * Parameters:
 * - statuslist: git_status_list *
 * - idx: size_t
 * Return Type: const git_status_entry *
 */
mrb_value
mrb_Git_git_status_byindex(mrb_state* mrb, mrb_value self) {
  mrb_value statuslist;
  mrb_int native_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &statuslist, &native_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, statuslist, StatusList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StatusList expected");
    return mrb_nil_value();
  }

  /* Unbox param: statuslist */
  git_status_list * native_statuslist = (mrb_nil_p(statuslist) ? NULL : mruby_unbox_git_status_list(statuslist));

  /* Invocation */
  const git_status_entry * native_return_value = git_status_byindex(native_statuslist, native_idx);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_status_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_file */
/* sha: 63fa0ec9ec00a9db4586fb5c7524f6ad8e923c8e0b529da50d1f5cc16a37491c */
#if BIND_git_status_file_FUNCTION
#define git_status_file_REQUIRED_ARGC 2
#define git_status_file_OPTIONAL_ARGC 0
/* git_status_file
 *
 * Parameters:
 * - repo: git_repository *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_status_file(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  int native_status_flags;
  mrb_value repo;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_status_file(&native_status_flags, native_repo, native_path);

  /* Box out param: status_flags */
  mrb_value status_flags = mrb_fixnum_value(native_status_flags);

  RAISE_GIT_ERROR(native_return_value);

  return status_flags;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_foreach */
/* sha: e97c5bfbf4b189beea7ad81c141eb2f696b6f908fed95031b7a93a4c1cf59cba */
#if BIND_git_status_foreach_FUNCTION
#define git_status_foreach_REQUIRED_ARGC 3
#define git_status_foreach_OPTIONAL_ARGC 0
/* git_status_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_status_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_status_foreach(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_status_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_status_cb native_callback = TODO_mruby_unbox_git_status_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_status_foreach(native_repo, native_callback, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_foreach_ext */
/* sha: 0fdfb497487094a790dcd150acfc97ee42d0204cb7cb49720734f45f0e904d5f */
#if BIND_git_status_foreach_ext_FUNCTION
#define git_status_foreach_ext_REQUIRED_ARGC 4
#define git_status_foreach_ext_OPTIONAL_ARGC 0
/* git_status_foreach_ext
 *
 * Parameters:
 * - repo: git_repository *
 * - opts: const git_status_options *
 * - callback: git_status_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_status_foreach_ext(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value opts;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &repo, &opts, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, StatusOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StatusOptions expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_status_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: opts */
  const git_status_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_status_options(opts));

  /* Unbox param: callback */
  git_status_cb native_callback = TODO_mruby_unbox_git_status_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_status_foreach_ext(native_repo, native_opts, native_callback, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_init_options */
/* sha: f5b1c9c4da5b8b5c46440ebe01a4a827ddcc2e6cdb8d1bee682afcdae333ef43 */
#if BIND_git_status_init_options_FUNCTION
#define git_status_init_options_REQUIRED_ARGC 2
#define git_status_init_options_OPTIONAL_ARGC 0
/* git_status_init_options
 *
 * Parameters:
 * - opts: git_status_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_status_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, StatusOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StatusOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_status_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_status_options(opts));

  /* Invocation */
  int native_return_value = git_status_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_list_entrycount */
/* sha: 4ee2413aaed3bc11d4fd5f786b50c10be874efed835ad0bece135aabc0c128c5 */
#if BIND_git_status_list_entrycount_FUNCTION
#define git_status_list_entrycount_REQUIRED_ARGC 1
#define git_status_list_entrycount_OPTIONAL_ARGC 0
/* git_status_list_entrycount
 *
 * Parameters:
 * - statuslist: git_status_list *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_status_list_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value statuslist;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &statuslist);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, statuslist, StatusList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StatusList expected");
    return mrb_nil_value();
  }

  /* Unbox param: statuslist */
  git_status_list * native_statuslist = (mrb_nil_p(statuslist) ? NULL : mruby_unbox_git_status_list(statuslist));

  /* Invocation */
  size_t native_return_value = git_status_list_entrycount(native_statuslist);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_list_free */
/* sha: 9d5795f9018cb09f4958e19c8bb790b07b829d333eaa1bf42e656a338b49dbce */
#if BIND_git_status_list_free_FUNCTION
#define git_status_list_free_REQUIRED_ARGC 1
#define git_status_list_free_OPTIONAL_ARGC 0
/* git_status_list_free
 *
 * Parameters:
 * - statuslist: git_status_list *
 * Return Type: void
 */
mrb_value
mrb_Git_git_status_list_free(mrb_state* mrb, mrb_value self) {
  mrb_value statuslist;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &statuslist);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, statuslist, StatusList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StatusList expected");
    return mrb_nil_value();
  }

  /* Unbox param: statuslist */
  git_status_list * native_statuslist = (mrb_nil_p(statuslist) ? NULL : mruby_unbox_git_status_list(statuslist));

  /* Invocation */
  git_status_list_free(native_statuslist);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_list_new */
/* sha: cada3a54e6f4d28e18ab637863e8557431d739f95cf11b903993c7bd01a07fdd */
#if BIND_git_status_list_new_FUNCTION
#define git_status_list_new_REQUIRED_ARGC 2
#define git_status_list_new_OPTIONAL_ARGC 0
/* git_status_list_new
 *
 * Parameters:
 * - repo: git_repository *
 * - opts: const git_status_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_status_list_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_status_list * native_out = NULL;
  mrb_value repo;
  mrb_value opts;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &opts);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, opts, StatusOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "StatusOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: opts */
  const git_status_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_status_options(opts));

  /* Invocation */
  int native_return_value = git_status_list_new(&native_out, native_repo, native_opts);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_status_list(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_status_should_ignore */
/* sha: 3629d8aaeac91de084445d48ca4255d46a4effa2d34e4115a4d1f057bc692eb6 */
#if BIND_git_status_should_ignore_FUNCTION
#define git_status_should_ignore_REQUIRED_ARGC 3
#define git_status_should_ignore_OPTIONAL_ARGC 0
/* git_status_should_ignore
 *
 * Parameters:
 * - ignored: int *
 * - repo: git_repository *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_status_should_ignore(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value ignored;
  mrb_value repo;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz", &ignored, &repo, &native_path);

  /* Type checking */
  TODO_type_check_int_PTR(ignored);
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: ignored */
  int * native_ignored = TODO_mruby_unbox_int_PTR(ignored);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_status_should_ignore(native_ignored, native_repo, native_path);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_strarray_copy */
/* sha: 3c1fb808e7bddb24e837ebec54cf4244fe4ee8257f0df0198cfc10910f742841 */
#if BIND_git_strarray_copy_FUNCTION
#define git_strarray_copy_REQUIRED_ARGC 1
#define git_strarray_copy_OPTIONAL_ARGC 0
/* git_strarray_copy
 *
 * Parameters:
 * - src: const git_strarray *
 * Return Type: int
 */
mrb_value
mrb_Git_git_strarray_copy(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_strarray * native_tgt = (git_strarray*)calloc(1, sizeof(git_strarray));
  mrb_value src;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &src);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, src, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }

  /* Unbox param: src */
  const git_strarray * native_src = (mrb_nil_p(src) ? NULL : mruby_unbox_git_strarray(src));

  /* Invocation */
  int native_return_value = git_strarray_copy(native_tgt, native_src);

  /* Box out param: tgt */
  mrb_value tgt = native_tgt == NULL ? mrb_nil_value() : mruby_giftwrap_git_strarray(mrb, native_tgt);

  RAISE_GIT_ERROR(native_return_value);

  return tgt;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_strarray_free */
/* sha: 6927ac6e8a7782d8295216aab1574d5922b4cbd1bd330f6ec03f1b1ea9f7ea99 */
#if BIND_git_strarray_free_FUNCTION
#define git_strarray_free_REQUIRED_ARGC 1
#define git_strarray_free_OPTIONAL_ARGC 0
/* git_strarray_free
 *
 * Parameters:
 * - array: git_strarray *
 * Return Type: void
 */
mrb_value
mrb_Git_git_strarray_free(mrb_state* mrb, mrb_value self) {
  mrb_value array;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, Strarray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Strarray expected");
    return mrb_nil_value();
  }

  /* Unbox param: array */
  git_strarray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox_git_strarray(array));

  /* Invocation */
  git_strarray_free(native_array);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_add_finalize */
/* sha: cfe7663176f06991b134110f62d04b89e88a15fbb4565ebb661163b897b27ff8 */
#if BIND_git_submodule_add_finalize_FUNCTION
#define git_submodule_add_finalize_REQUIRED_ARGC 1
#define git_submodule_add_finalize_OPTIONAL_ARGC 0
/* git_submodule_add_finalize
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_add_finalize(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  int native_return_value = git_submodule_add_finalize(native_submodule);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_add_setup */
/* sha: 03010eeb01be8db6002d62b9e66afb90a46afa92723950410d47eeafa7225708 */
#if BIND_git_submodule_add_setup_FUNCTION
#define git_submodule_add_setup_REQUIRED_ARGC 4
#define git_submodule_add_setup_OPTIONAL_ARGC 0
/* git_submodule_add_setup
 *
 * Parameters:
 * - repo: git_repository *
 * - url: const char *
 * - path: const char *
 * - use_gitlink: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_add_setup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_submodule * native_out = NULL;
  mrb_value repo;
  char * native_url = NULL;
  char * native_path = NULL;
  mrb_int native_use_gitlink;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzi", &repo, &native_url, &native_path, &native_use_gitlink);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_add_setup(&native_out, native_repo, native_url, native_path, native_use_gitlink);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_submodule(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_add_to_index */
/* sha: d6cc9f1d7682b7a065d5faf2fdb8ef45b7a32ed59eba8c97c5e7c2ea220e1ca5 */
#if BIND_git_submodule_add_to_index_FUNCTION
#define git_submodule_add_to_index_REQUIRED_ARGC 2
#define git_submodule_add_to_index_OPTIONAL_ARGC 0
/* git_submodule_add_to_index
 *
 * Parameters:
 * - submodule: git_submodule *
 * - write_index: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_add_to_index(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value submodule;
  mrb_int native_write_index;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &submodule, &native_write_index);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  int native_return_value = git_submodule_add_to_index(native_submodule, native_write_index);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_branch */
/* sha: 24d87df887f95ae556a9673c95fc8e89d4c46fdec9608e0b250623676db362ae */
#if BIND_git_submodule_branch_FUNCTION
#define git_submodule_branch_REQUIRED_ARGC 1
#define git_submodule_branch_OPTIONAL_ARGC 0
/* git_submodule_branch
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_submodule_branch(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  const char * native_return_value = git_submodule_branch(native_submodule);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_fetch_recurse_submodules */
/* sha: 8d6e9b1dc3eb43866f7d7791f88152a13946b38c27b0da3154cd19a46c0bad31 */
#if BIND_git_submodule_fetch_recurse_submodules_FUNCTION
#define git_submodule_fetch_recurse_submodules_REQUIRED_ARGC 1
#define git_submodule_fetch_recurse_submodules_OPTIONAL_ARGC 0
/* git_submodule_fetch_recurse_submodules
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: git_submodule_recurse_t
 */
mrb_value
mrb_Git_git_submodule_fetch_recurse_submodules(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  git_submodule_recurse_t native_return_value = git_submodule_fetch_recurse_submodules(native_submodule);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_foreach */
/* sha: bddb2e2e5614c78510996be2e17c57c1d87d0dc2a4f99cb396dfa962d852386e */
#if BIND_git_submodule_foreach_FUNCTION
#define git_submodule_foreach_REQUIRED_ARGC 3
#define git_submodule_foreach_OPTIONAL_ARGC 0
/* git_submodule_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_submodule_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_foreach(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_submodule_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_submodule_cb native_callback = TODO_mruby_unbox_git_submodule_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_submodule_foreach(native_repo, native_callback, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_free */
/* sha: 500db70b425dcca1028ef1a584ce9d63987ae18a8c8c88979a456ec854e334ae */
#if BIND_git_submodule_free_FUNCTION
#define git_submodule_free_REQUIRED_ARGC 1
#define git_submodule_free_OPTIONAL_ARGC 0
/* git_submodule_free
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: void
 */
mrb_value
mrb_Git_git_submodule_free(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  git_submodule_free(native_submodule);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_head_id */
/* sha: 271f50d5cc7a8c5decf9ac3d3ae5f24573f79da52fcf57d749cab80e35496ce4 */
#if BIND_git_submodule_head_id_FUNCTION
#define git_submodule_head_id_REQUIRED_ARGC 1
#define git_submodule_head_id_OPTIONAL_ARGC 0
/* git_submodule_head_id
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_submodule_head_id(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  const git_oid * native_return_value = git_submodule_head_id(native_submodule);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_ignore */
/* sha: b8e5d91399950801775a25fb6701ebbb5c7914e8d057f4c315196460afcfa2fd */
#if BIND_git_submodule_ignore_FUNCTION
#define git_submodule_ignore_REQUIRED_ARGC 1
#define git_submodule_ignore_OPTIONAL_ARGC 0
/* git_submodule_ignore
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: git_submodule_ignore_t
 */
mrb_value
mrb_Git_git_submodule_ignore(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  git_submodule_ignore_t native_return_value = git_submodule_ignore(native_submodule);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_index_id */
/* sha: 7e86e8c3c5f3d952f1cdbbdd34a5948fd618c3fe3c579d83ebd26a6c24c05844 */
#if BIND_git_submodule_index_id_FUNCTION
#define git_submodule_index_id_REQUIRED_ARGC 1
#define git_submodule_index_id_OPTIONAL_ARGC 0
/* git_submodule_index_id
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_submodule_index_id(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  const git_oid * native_return_value = git_submodule_index_id(native_submodule);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_init */
/* sha: a539a6db89630b107fc451a7982fee00cc77e2389a16aa92dcb5064d5fd9ea0f */
#if BIND_git_submodule_init_FUNCTION
#define git_submodule_init_REQUIRED_ARGC 2
#define git_submodule_init_OPTIONAL_ARGC 0
/* git_submodule_init
 *
 * Parameters:
 * - submodule: git_submodule *
 * - overwrite: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_init(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value submodule;
  mrb_int native_overwrite;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &submodule, &native_overwrite);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  int native_return_value = git_submodule_init(native_submodule, native_overwrite);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_location */
/* sha: 38b3c66d96eafaad4a0940a447d7abde2cc05eca5e1d28ec4a65b31122a17694 */
#if BIND_git_submodule_location_FUNCTION
#define git_submodule_location_REQUIRED_ARGC 1
#define git_submodule_location_OPTIONAL_ARGC 0
/* git_submodule_location
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_location(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  int native_location_status;
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  int native_return_value = git_submodule_location(&native_location_status, native_submodule);

  /* Box out param: location_status */
  mrb_value location_status = mrb_fixnum_value(native_location_status);

  RAISE_GIT_ERROR(native_return_value);

  return location_status;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_lookup */
/* sha: 2429a3be83cfa41342c9c14d26fa70078628c3ca584b76ddceee10aaff078f72 */
#if BIND_git_submodule_lookup_FUNCTION
#define git_submodule_lookup_REQUIRED_ARGC 2
#define git_submodule_lookup_OPTIONAL_ARGC 0
/* git_submodule_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_lookup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_submodule * native_out = NULL;
  mrb_value repo;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_lookup(&native_out, native_repo, native_name);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_submodule(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_name */
/* sha: 1a3d7ea776b60fe87e8d7470af67aba9df34664eb72e19e455b2c41b5fb552fc */
#if BIND_git_submodule_name_FUNCTION
#define git_submodule_name_REQUIRED_ARGC 1
#define git_submodule_name_OPTIONAL_ARGC 0
/* git_submodule_name
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_submodule_name(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  const char * native_return_value = git_submodule_name(native_submodule);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_open */
/* sha: f198149c8129074b115bf3ad368b78a6a3f718deb69a8a8d94d05e444a633a1d */
#if BIND_git_submodule_open_FUNCTION
#define git_submodule_open_REQUIRED_ARGC 1
#define git_submodule_open_OPTIONAL_ARGC 0
/* git_submodule_open
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_open(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_repository * native_repo = NULL;
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  int native_return_value = git_submodule_open(&native_repo, native_submodule);

  /* Box out param: repo */
  mrb_value repo = native_repo == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_repo);

  RAISE_GIT_ERROR(native_return_value);

  return repo;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_owner */
/* sha: 2c8805dd7669c29ed5550cfe85b80535097c53525acee59af92cc79ba16e1886 */
#if BIND_git_submodule_owner_FUNCTION
#define git_submodule_owner_REQUIRED_ARGC 1
#define git_submodule_owner_OPTIONAL_ARGC 0
/* git_submodule_owner
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_submodule_owner(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  git_repository * native_return_value = git_submodule_owner(native_submodule);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_path */
/* sha: 8628bf020227abc6fb136daf841d89829b30332327585c21b58e5b0e530de9bb */
#if BIND_git_submodule_path_FUNCTION
#define git_submodule_path_REQUIRED_ARGC 1
#define git_submodule_path_OPTIONAL_ARGC 0
/* git_submodule_path
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_submodule_path(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  const char * native_return_value = git_submodule_path(native_submodule);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_reload */
/* sha: e76026209fe0eb3e570e01da52ac7d3f3117b953f4f24fda1e61fcbda935b561 */
#if BIND_git_submodule_reload_FUNCTION
#define git_submodule_reload_REQUIRED_ARGC 2
#define git_submodule_reload_OPTIONAL_ARGC 0
/* git_submodule_reload
 *
 * Parameters:
 * - submodule: git_submodule *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_reload(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value submodule;
  mrb_bool native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "ob", &submodule, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  int native_return_value = git_submodule_reload(native_submodule, native_force);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_repo_init */
/* sha: 8b9d69c58dd8a1a928a65206eab3419db3a169d94aefe6942d4f2dca46865f3e */
#if BIND_git_submodule_repo_init_FUNCTION
#define git_submodule_repo_init_REQUIRED_ARGC 2
#define git_submodule_repo_init_OPTIONAL_ARGC 0
/* git_submodule_repo_init
 *
 * Parameters:
 * - sm: const git_submodule *
 * - use_gitlink: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_repo_init(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_repository * native_out = NULL;
  mrb_value sm;
  mrb_int native_use_gitlink;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &sm, &native_use_gitlink);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, sm, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: sm */
  const git_submodule * native_sm = (mrb_nil_p(sm) ? NULL : mruby_unbox_git_submodule(sm));

  /* Invocation */
  int native_return_value = git_submodule_repo_init(&native_out, native_sm, native_use_gitlink);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_repository(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_resolve_url */
/* sha: e418246145e760afee5d46a015c732497e999c6d2f7ca9d2f70f3c3ef4c47a98 */
#if BIND_git_submodule_resolve_url_FUNCTION
#define git_submodule_resolve_url_REQUIRED_ARGC 2
#define git_submodule_resolve_url_OPTIONAL_ARGC 0
/* git_submodule_resolve_url
 *
 * Parameters:
 * - repo: git_repository *
 * - url: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_resolve_url(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_buf * native_out = (git_buf*)calloc(1, sizeof(git_buf));
  mrb_value repo;
  char * native_url = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_url);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_resolve_url(native_out, native_repo, native_url);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_buf(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_set_branch */
/* sha: 62136068d1f8172ec0ec4e13ef0dc452bc14b74a23ee88aa7868438ae21406e4 */
#if BIND_git_submodule_set_branch_FUNCTION
#define git_submodule_set_branch_REQUIRED_ARGC 3
#define git_submodule_set_branch_OPTIONAL_ARGC 0
/* git_submodule_set_branch
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - branch: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_set_branch(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_name = NULL;
  char * native_branch = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_name, &native_branch);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_set_branch(native_repo, native_name, native_branch);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_set_fetch_recurse_submodules */
/* sha: c8d2aeddc087d494f9118df248c44b450c909d34f9650d572f177696153f0190 */
#if BIND_git_submodule_set_fetch_recurse_submodules_FUNCTION
#define git_submodule_set_fetch_recurse_submodules_REQUIRED_ARGC 3
#define git_submodule_set_fetch_recurse_submodules_OPTIONAL_ARGC 0
/* git_submodule_set_fetch_recurse_submodules
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - fetch_recurse_submodules: git_submodule_recurse_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_set_fetch_recurse_submodules(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_name = NULL;
  mrb_int native_fetch_recurse_submodules;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &repo, &native_name, &native_fetch_recurse_submodules);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_set_fetch_recurse_submodules(native_repo, native_name, native_fetch_recurse_submodules);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_set_ignore */
/* sha: 50418e0fcfb8010cac1882c8b83be012fae4d972e12439a96af36ea63972568c */
#if BIND_git_submodule_set_ignore_FUNCTION
#define git_submodule_set_ignore_REQUIRED_ARGC 3
#define git_submodule_set_ignore_OPTIONAL_ARGC 0
/* git_submodule_set_ignore
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - ignore: git_submodule_ignore_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_set_ignore(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_name = NULL;
  mrb_int native_ignore;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &repo, &native_name, &native_ignore);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_set_ignore(native_repo, native_name, native_ignore);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_set_update */
/* sha: e2bb50be18a8a6032a2bc0cc5a3bc5623fc2ae86816e37b83db446962fe2f323 */
#if BIND_git_submodule_set_update_FUNCTION
#define git_submodule_set_update_REQUIRED_ARGC 3
#define git_submodule_set_update_OPTIONAL_ARGC 0
/* git_submodule_set_update
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - update: git_submodule_update_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_set_update(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_name = NULL;
  mrb_int native_update;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &repo, &native_name, &native_update);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_set_update(native_repo, native_name, native_update);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_set_url */
/* sha: 39ed512f9f808230b3733ae7084ed3b62512a9f7a9048e69dbb6418e6a5ea8bb */
#if BIND_git_submodule_set_url_FUNCTION
#define git_submodule_set_url_REQUIRED_ARGC 3
#define git_submodule_set_url_OPTIONAL_ARGC 0
/* git_submodule_set_url
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - url: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_set_url(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_name = NULL;
  char * native_url = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozz", &repo, &native_name, &native_url);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_set_url(native_repo, native_name, native_url);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_status */
/* sha: 1ba5bf7eae6b50d7c9f19d6a20dbe758718abc1899e994c068829972e97bc127 */
#if BIND_git_submodule_status_FUNCTION
#define git_submodule_status_REQUIRED_ARGC 3
#define git_submodule_status_OPTIONAL_ARGC 0
/* git_submodule_status
 *
 * Parameters:
 * - repo: git_repository *
 * - name: const char *
 * - ignore: git_submodule_ignore_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_status(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  int native_status;
  mrb_value repo;
  char * native_name = NULL;
  mrb_int native_ignore;

  /* Fetch the args */
  mrb_get_args(mrb, "ozi", &repo, &native_name, &native_ignore);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_submodule_status(&native_status, native_repo, native_name, native_ignore);

  /* Box out param: status */
  mrb_value status = mrb_fixnum_value(native_status);

  RAISE_GIT_ERROR(native_return_value);

  return status;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_sync */
/* sha: 87db49f852a85a60ff0dec14f979fcd2bb0ed4fa88e22f9465d00a1f601da838 */
#if BIND_git_submodule_sync_FUNCTION
#define git_submodule_sync_REQUIRED_ARGC 1
#define git_submodule_sync_OPTIONAL_ARGC 0
/* git_submodule_sync
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_sync(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  int native_return_value = git_submodule_sync(native_submodule);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_update */
/* sha: 4df670f62f63d6a26dfc70ed1421af861f1565abb9abaeb67f98070c1c8147cb */
#if BIND_git_submodule_update_FUNCTION
#define git_submodule_update_REQUIRED_ARGC 3
#define git_submodule_update_OPTIONAL_ARGC 0
/* git_submodule_update
 *
 * Parameters:
 * - submodule: git_submodule *
 * - init: int
 * - options: git_submodule_update_options *
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_update(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value submodule;
  mrb_int native_init;
  mrb_value options;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &submodule, &native_init, &options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, options, SubmoduleUpdateOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "SubmoduleUpdateOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Unbox param: options */
  git_submodule_update_options * native_options = (mrb_nil_p(options) ? NULL : mruby_unbox_git_submodule_update_options(options));

  /* Invocation */
  int native_return_value = git_submodule_update(native_submodule, native_init, native_options);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_update_init_options */
/* sha: ae86e250d43813dee9400bcd5760e39d12d1c0b96529b62ac667c60bf358fa84 */
#if BIND_git_submodule_update_init_options_FUNCTION
#define git_submodule_update_init_options_REQUIRED_ARGC 2
#define git_submodule_update_init_options_OPTIONAL_ARGC 0
/* git_submodule_update_init_options
 *
 * Parameters:
 * - opts: git_submodule_update_options *
 * - version: unsigned int
 * Return Type: int
 */
mrb_value
mrb_Git_git_submodule_update_init_options(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value opts;
  mrb_int native_version;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &opts, &native_version);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, opts, SubmoduleUpdateOptions_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "SubmoduleUpdateOptions expected");
    return mrb_nil_value();
  }

  /* Unbox param: opts */
  git_submodule_update_options * native_opts = (mrb_nil_p(opts) ? NULL : mruby_unbox_git_submodule_update_options(opts));

  /* Invocation */
  int native_return_value = git_submodule_update_init_options(native_opts, native_version);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_update_strategy */
/* sha: 0703ebb67562e0501491ef4c3c92b362473c014ffdfa6c6157fc0cc79f76a4a5 */
#if BIND_git_submodule_update_strategy_FUNCTION
#define git_submodule_update_strategy_REQUIRED_ARGC 1
#define git_submodule_update_strategy_OPTIONAL_ARGC 0
/* git_submodule_update_strategy
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: git_submodule_update_t
 */
mrb_value
mrb_Git_git_submodule_update_strategy(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  git_submodule_update_t native_return_value = git_submodule_update_strategy(native_submodule);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_url */
/* sha: 90eeac5834c35dd599edc06df5496532e48e9b75a8aa8f6e5cc8d2d4d23eba38 */
#if BIND_git_submodule_url_FUNCTION
#define git_submodule_url_REQUIRED_ARGC 1
#define git_submodule_url_OPTIONAL_ARGC 0
/* git_submodule_url
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_submodule_url(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  const char * native_return_value = git_submodule_url(native_submodule);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_submodule_wd_id */
/* sha: 841f2c3533833db847858f4e4cf36a5bec38edeb7f935e260706529bdbc65838 */
#if BIND_git_submodule_wd_id_FUNCTION
#define git_submodule_wd_id_REQUIRED_ARGC 1
#define git_submodule_wd_id_OPTIONAL_ARGC 0
/* git_submodule_wd_id
 *
 * Parameters:
 * - submodule: git_submodule *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_submodule_wd_id(mrb_state* mrb, mrb_value self) {
  mrb_value submodule;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &submodule);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, submodule, Submodule_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Submodule expected");
    return mrb_nil_value();
  }

  /* Unbox param: submodule */
  git_submodule * native_submodule = (mrb_nil_p(submodule) ? NULL : mruby_unbox_git_submodule(submodule));

  /* Invocation */
  const git_oid * native_return_value = git_submodule_wd_id(native_submodule);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_annotation_create */
/* sha: baf3a279827aeb34a6d9dfe4cc9cb92cf9327a661719fe2c43d7b4f114bd53ac */
#if BIND_git_tag_annotation_create_FUNCTION
#define git_tag_annotation_create_REQUIRED_ARGC 5
#define git_tag_annotation_create_OPTIONAL_ARGC 0
/* git_tag_annotation_create
 *
 * Parameters:
 * - repo: git_repository *
 * - tag_name: const char *
 * - target: const git_object *
 * - tagger: const git_signature *
 * - message: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_annotation_create(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_oid * native_oid = (git_oid*)calloc(1, sizeof(git_oid));
  mrb_value repo;
  char * native_tag_name = NULL;
  mrb_value target;
  mrb_value tagger;
  char * native_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozooz", &repo, &native_tag_name, &target, &tagger, &native_message);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, tagger, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: target */
  const git_object * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_object(target));

  /* Unbox param: tagger */
  const git_signature * native_tagger = (mrb_nil_p(tagger) ? NULL : mruby_unbox_git_signature(tagger));

  /* Invocation */
  int native_return_value = git_tag_annotation_create(native_oid, native_repo, native_tag_name, native_target, native_tagger, native_message);

  /* Box out param: oid */
  mrb_value oid = native_oid == NULL ? mrb_nil_value() : mruby_giftwrap_git_oid(mrb, native_oid);

  RAISE_GIT_ERROR(native_return_value);

  return oid;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_create */
/* sha: c44101d89ce1f849278bfbe0e3817024625c2391a9cef624e8e6e0a604fd3d1b */
#if BIND_git_tag_create_FUNCTION
#define git_tag_create_REQUIRED_ARGC 6
#define git_tag_create_OPTIONAL_ARGC 0
/* git_tag_create
 *
 * Parameters:
 * - repo: git_repository *
 * - tag_name: const char *
 * - target: const git_object *
 * - tagger: const git_signature *
 * - message: const char *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_create(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_oid * native_oid = (git_oid*)calloc(1, sizeof(git_oid));
  mrb_value repo;
  char * native_tag_name = NULL;
  mrb_value target;
  mrb_value tagger;
  char * native_message = NULL;
  mrb_bool native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoozb", &repo, &native_tag_name, &target, &tagger, &native_message, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, tagger, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: target */
  const git_object * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_object(target));

  /* Unbox param: tagger */
  const git_signature * native_tagger = (mrb_nil_p(tagger) ? NULL : mruby_unbox_git_signature(tagger));

  /* Invocation */
  int native_return_value = git_tag_create(native_oid, native_repo, native_tag_name, native_target, native_tagger, native_message, native_force);

  /* Box out param: oid */
  mrb_value oid = native_oid == NULL ? mrb_nil_value() : mruby_giftwrap_git_oid(mrb, native_oid);

  RAISE_GIT_ERROR(native_return_value);

  return oid;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_create_frombuffer */
/* sha: 17dbc7e85b3fdf843d51ecd0617c6ca32ff7f65a17c355403ccd3ddd643f6e3e */
#if BIND_git_tag_create_frombuffer_FUNCTION
#define git_tag_create_frombuffer_REQUIRED_ARGC 3
#define git_tag_create_frombuffer_OPTIONAL_ARGC 0
/* git_tag_create_frombuffer
 *
 * Parameters:
 * - repo: git_repository *
 * - buffer: const char *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_create_frombuffer(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_oid * native_oid = (git_oid*)calloc(1, sizeof(git_oid));
  mrb_value repo;
  char * native_buffer = NULL;
  mrb_bool native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "ozb", &repo, &native_buffer, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_tag_create_frombuffer(native_oid, native_repo, native_buffer, native_force);

  /* Box out param: oid */
  mrb_value oid = native_oid == NULL ? mrb_nil_value() : mruby_giftwrap_git_oid(mrb, native_oid);

  RAISE_GIT_ERROR(native_return_value);

  return oid;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_create_lightweight */
/* sha: 70707d0e6c95fffa16f12a47ff2a84b6c213f317299c2a16ab2de93044721da6 */
#if BIND_git_tag_create_lightweight_FUNCTION
#define git_tag_create_lightweight_REQUIRED_ARGC 4
#define git_tag_create_lightweight_OPTIONAL_ARGC 0
/* git_tag_create_lightweight
 *
 * Parameters:
 * - repo: git_repository *
 * - tag_name: const char *
 * - target: const git_object *
 * - force: int
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_create_lightweight(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_oid * native_oid = (git_oid*)calloc(1, sizeof(git_oid));
  mrb_value repo;
  char * native_tag_name = NULL;
  mrb_value target;
  mrb_bool native_force;

  /* Fetch the args */
  mrb_get_args(mrb, "ozob", &repo, &native_tag_name, &target, &native_force);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Object_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Object expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: target */
  const git_object * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_object(target));

  /* Invocation */
  int native_return_value = git_tag_create_lightweight(native_oid, native_repo, native_tag_name, native_target, native_force);

  /* Box out param: oid */
  mrb_value oid = native_oid == NULL ? mrb_nil_value() : mruby_giftwrap_git_oid(mrb, native_oid);

  RAISE_GIT_ERROR(native_return_value);

  return oid;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_delete */
/* sha: 9b17196564a96d9a0dca93b7ffe9bf2090eaae58af0797bd1840343b89d2fec0 */
#if BIND_git_tag_delete_FUNCTION
#define git_tag_delete_REQUIRED_ARGC 2
#define git_tag_delete_OPTIONAL_ARGC 0
/* git_tag_delete
 *
 * Parameters:
 * - repo: git_repository *
 * - tag_name: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_delete(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value repo;
  char * native_tag_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &repo, &native_tag_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_tag_delete(native_repo, native_tag_name);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_foreach */
/* sha: 7a401f6c091da5b2460020e65f5fd0fd4cceadaff790bcc59fef6f8312514c0b */
#if BIND_git_tag_foreach_FUNCTION
#define git_tag_foreach_REQUIRED_ARGC 3
#define git_tag_foreach_OPTIONAL_ARGC 0
/* git_tag_foreach
 *
 * Parameters:
 * - repo: git_repository *
 * - callback: git_tag_foreach_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value repo;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &repo, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_tag_foreach_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: callback */
  git_tag_foreach_cb native_callback = TODO_mruby_unbox_git_tag_foreach_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_tag_foreach(native_repo, native_callback, native_payload);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_free */
/* sha: 052b5a2772be6b07bbf26a8b20e15abcf77ef5d91c0d62c2a3af4b5f56b05537 */
#if BIND_git_tag_free_FUNCTION
#define git_tag_free_REQUIRED_ARGC 1
#define git_tag_free_OPTIONAL_ARGC 0
/* git_tag_free
 *
 * Parameters:
 * - tag: git_tag *
 * Return Type: void
 */
mrb_value
mrb_Git_git_tag_free(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  git_tag_free(native_tag);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_id */
/* sha: c32511f6ff9a3efe8b0ecbb4940b21e640736f0fde08ba13f9615ae39256052a */
#if BIND_git_tag_id_FUNCTION
#define git_tag_id_REQUIRED_ARGC 1
#define git_tag_id_OPTIONAL_ARGC 0
/* git_tag_id
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_tag_id(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  const git_oid * native_return_value = git_tag_id(native_tag);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_list */
/* sha: 442a5d2b9cf28fffd2e3bcb2d949ee00abdf0afd09ec39bba26a64fe381488eb */
#if BIND_git_tag_list_FUNCTION
#define git_tag_list_REQUIRED_ARGC 1
#define git_tag_list_OPTIONAL_ARGC 0
/* git_tag_list
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_list(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_strarray * native_tag_names = (git_strarray*)calloc(1, sizeof(git_strarray));
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_tag_list(native_tag_names, native_repo);

  /* Box out param: tag_names */
  mrb_value tag_names = native_tag_names == NULL ? mrb_nil_value() : mruby_giftwrap_git_strarray(mrb, native_tag_names);

  RAISE_GIT_ERROR(native_return_value);

  return tag_names;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_list_match */
/* sha: f0e885d493103ff14391e5eba2ddd42f8130b66d7273863e2b1c2cd270e7d53f */
#if BIND_git_tag_list_match_FUNCTION
#define git_tag_list_match_REQUIRED_ARGC 2
#define git_tag_list_match_OPTIONAL_ARGC 0
/* git_tag_list_match
 *
 * Parameters:
 * - pattern: const char *
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_list_match(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_strarray * native_tag_names = (git_strarray*)calloc(1, sizeof(git_strarray));
  char * native_pattern = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "zo", &native_pattern, &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_tag_list_match(native_tag_names, native_pattern, native_repo);

  /* Box out param: tag_names */
  mrb_value tag_names = native_tag_names == NULL ? mrb_nil_value() : mruby_giftwrap_git_strarray(mrb, native_tag_names);

  RAISE_GIT_ERROR(native_return_value);

  return tag_names;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_lookup */
/* sha: 2064386d8cd46af1cdddbc6dca51b9f7583803c3a801dd9380bdd460b65bec90 */
#if BIND_git_tag_lookup_FUNCTION
#define git_tag_lookup_REQUIRED_ARGC 2
#define git_tag_lookup_OPTIONAL_ARGC 0
/* git_tag_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_lookup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_tag * native_out = NULL;
  mrb_value repo;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_tag_lookup(&native_out, native_repo, native_id);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_tag(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_lookup_prefix */
/* sha: 48d5669443571011f9dc99797f111027814c1d7f564e4fec026e2fce20d172c2 */
#if BIND_git_tag_lookup_prefix_FUNCTION
#define git_tag_lookup_prefix_REQUIRED_ARGC 3
#define git_tag_lookup_prefix_OPTIONAL_ARGC 0
/* git_tag_lookup_prefix
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_lookup_prefix(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_tag * native_out = NULL;
  mrb_value repo;
  mrb_value id;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &repo, &id, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_tag_lookup_prefix(&native_out, native_repo, native_id, native_len);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_tag(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_message */
/* sha: c4f9a8dfd1f427dfc83b1a7b89932496a73f616ad064c6ccf9fdf83d4a3cc8ce */
#if BIND_git_tag_message_FUNCTION
#define git_tag_message_REQUIRED_ARGC 1
#define git_tag_message_OPTIONAL_ARGC 0
/* git_tag_message
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_tag_message(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  const char * native_return_value = git_tag_message(native_tag);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_name */
/* sha: 3ce6a2aa634632f444a234866aa4bc7a0d2c7a65f79d528e3cf01e33d7a9fdaa */
#if BIND_git_tag_name_FUNCTION
#define git_tag_name_REQUIRED_ARGC 1
#define git_tag_name_OPTIONAL_ARGC 0
/* git_tag_name
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_tag_name(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  const char * native_return_value = git_tag_name(native_tag);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_owner */
/* sha: cdb7acb92cd7feec98eb4639ffc752aaebdce7432cacd9080377b18b753c6f57 */
#if BIND_git_tag_owner_FUNCTION
#define git_tag_owner_REQUIRED_ARGC 1
#define git_tag_owner_OPTIONAL_ARGC 0
/* git_tag_owner
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_tag_owner(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  git_repository * native_return_value = git_tag_owner(native_tag);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_peel */
/* sha: 1680576f4b0747097d454859c93192c9233751c9ac4a688b96106720030462ee */
#if BIND_git_tag_peel_FUNCTION
#define git_tag_peel_REQUIRED_ARGC 1
#define git_tag_peel_OPTIONAL_ARGC 0
/* git_tag_peel
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_peel(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_object * native_tag_target_out = NULL;
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  int native_return_value = git_tag_peel(&native_tag_target_out, native_tag);

  /* Box out param: tag_target_out */
  mrb_value tag_target_out = native_tag_target_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_tag_target_out);

  RAISE_GIT_ERROR(native_return_value);

  return tag_target_out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_tagger */
/* sha: c837ab2c914bbb2701a0656ffddb7969f7b2add242bc6f483bbf2cface6d0890 */
#if BIND_git_tag_tagger_FUNCTION
#define git_tag_tagger_REQUIRED_ARGC 1
#define git_tag_tagger_OPTIONAL_ARGC 0
/* git_tag_tagger
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: const git_signature *
 */
mrb_value
mrb_Git_git_tag_tagger(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  const git_signature * native_return_value = git_tag_tagger(native_tag);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_signature(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_target */
/* sha: e6ecbe085b129c7053dd90a73978c369fa5b9bb77b5ed3dbbb1b70ae77b037b5 */
#if BIND_git_tag_target_FUNCTION
#define git_tag_target_REQUIRED_ARGC 1
#define git_tag_target_OPTIONAL_ARGC 0
/* git_tag_target
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tag_target(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_object * native_target_out = NULL;
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  int native_return_value = git_tag_target(&native_target_out, native_tag);

  /* Box out param: target_out */
  mrb_value target_out = native_target_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_target_out);

  RAISE_GIT_ERROR(native_return_value);

  return target_out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_target_id */
/* sha: 17b36e87b8a238b13713361688a6b97051a0b8d355369cf28579b332a827776f */
#if BIND_git_tag_target_id_FUNCTION
#define git_tag_target_id_REQUIRED_ARGC 1
#define git_tag_target_id_OPTIONAL_ARGC 0
/* git_tag_target_id
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_tag_target_id(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  const git_oid * native_return_value = git_tag_target_id(native_tag);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tag_target_type */
/* sha: 15db3e6518567a124504a4db8157e1baf72a5fbd927f27b3eb1f5c0cd3c2496b */
#if BIND_git_tag_target_type_FUNCTION
#define git_tag_target_type_REQUIRED_ARGC 1
#define git_tag_target_type_OPTIONAL_ARGC 0
/* git_tag_target_type
 *
 * Parameters:
 * - tag: const git_tag *
 * Return Type: git_otype
 */
mrb_value
mrb_Git_git_tag_target_type(mrb_state* mrb, mrb_value self) {
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tag, Tag_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tag expected");
    return mrb_nil_value();
  }

  /* Unbox param: tag */
  const git_tag * native_tag = (mrb_nil_p(tag) ? NULL : mruby_unbox_git_tag(tag));

  /* Invocation */
  git_otype native_return_value = git_tag_target_type(native_tag);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_trace_set */
/* sha: 822eefd9443131a7d86184b1048b2196448cdf95669a2ed71017819705353b5c */
#if BIND_git_trace_set_FUNCTION
#define git_trace_set_REQUIRED_ARGC 2
#define git_trace_set_OPTIONAL_ARGC 0
/* git_trace_set
 *
 * Parameters:
 * - level: git_trace_level_t
 * - cb: git_trace_callback
 * Return Type: int
 */
mrb_value
mrb_Git_git_trace_set(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_int native_level;
  mrb_value cb;

  /* Fetch the args */
  mrb_get_args(mrb, "io", &native_level, &cb);

  /* Type checking */
  TODO_type_check_git_trace_callback(cb);

  /* Unbox param: cb */
  git_trace_callback native_cb = TODO_mruby_unbox_git_trace_callback(cb);

  /* Invocation */
  int native_return_value = git_trace_set(native_level, native_cb);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_commit */
/* sha: 567f50e8a3adc546136ae576e890bf347c0effe920bfcdb9b9cb8382b290b15f */
#if BIND_git_transaction_commit_FUNCTION
#define git_transaction_commit_REQUIRED_ARGC 1
#define git_transaction_commit_OPTIONAL_ARGC 0
/* git_transaction_commit
 *
 * Parameters:
 * - tx: git_transaction *
 * Return Type: int
 */
mrb_value
mrb_Git_git_transaction_commit(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value tx;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tx, Transaction_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Transaction expected");
    return mrb_nil_value();
  }

  /* Unbox param: tx */
  git_transaction * native_tx = (mrb_nil_p(tx) ? NULL : mruby_unbox_git_transaction(tx));

  /* Invocation */
  int native_return_value = git_transaction_commit(native_tx);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_free */
/* sha: 8d5000522bc4eef74bc023782b7100e54b64c10826ad1b890b215a6d8e8c3839 */
#if BIND_git_transaction_free_FUNCTION
#define git_transaction_free_REQUIRED_ARGC 1
#define git_transaction_free_OPTIONAL_ARGC 0
/* git_transaction_free
 *
 * Parameters:
 * - tx: git_transaction *
 * Return Type: void
 */
mrb_value
mrb_Git_git_transaction_free(mrb_state* mrb, mrb_value self) {
  mrb_value tx;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tx, Transaction_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Transaction expected");
    return mrb_nil_value();
  }

  /* Unbox param: tx */
  git_transaction * native_tx = (mrb_nil_p(tx) ? NULL : mruby_unbox_git_transaction(tx));

  /* Invocation */
  git_transaction_free(native_tx);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_lock_ref */
/* sha: 5a8fb6150872d3b61a52333e649e7e83e27da26d8bba32eaeeb3032a76d16586 */
#if BIND_git_transaction_lock_ref_FUNCTION
#define git_transaction_lock_ref_REQUIRED_ARGC 2
#define git_transaction_lock_ref_OPTIONAL_ARGC 0
/* git_transaction_lock_ref
 *
 * Parameters:
 * - tx: git_transaction *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_transaction_lock_ref(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value tx;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &tx, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tx, Transaction_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Transaction expected");
    return mrb_nil_value();
  }

  /* Unbox param: tx */
  git_transaction * native_tx = (mrb_nil_p(tx) ? NULL : mruby_unbox_git_transaction(tx));

  /* Invocation */
  int native_return_value = git_transaction_lock_ref(native_tx, native_refname);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_new */
/* sha: efbca11172b57b627b6415755d4996c773f971f6696aea3c82903dba66d95ca7 */
#if BIND_git_transaction_new_FUNCTION
#define git_transaction_new_REQUIRED_ARGC 1
#define git_transaction_new_OPTIONAL_ARGC 0
/* git_transaction_new
 *
 * Parameters:
 * - repo: git_repository *
 * Return Type: int
 */
mrb_value
mrb_Git_git_transaction_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_transaction * native_out = NULL;
  mrb_value repo;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &repo);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Invocation */
  int native_return_value = git_transaction_new(&native_out, native_repo);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_transaction(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_remove */
/* sha: 79d8e5c3ceefdbd846c046c09bd39a051cf1c28af92e060c256318000ef54e24 */
#if BIND_git_transaction_remove_FUNCTION
#define git_transaction_remove_REQUIRED_ARGC 2
#define git_transaction_remove_OPTIONAL_ARGC 0
/* git_transaction_remove
 *
 * Parameters:
 * - tx: git_transaction *
 * - refname: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_transaction_remove(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value tx;
  char * native_refname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &tx, &native_refname);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tx, Transaction_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Transaction expected");
    return mrb_nil_value();
  }

  /* Unbox param: tx */
  git_transaction * native_tx = (mrb_nil_p(tx) ? NULL : mruby_unbox_git_transaction(tx));

  /* Invocation */
  int native_return_value = git_transaction_remove(native_tx, native_refname);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_set_reflog */
/* sha: e9f13a44c80641054a0480037045a90865a892d049937cb0a33c48432f1ed018 */
#if BIND_git_transaction_set_reflog_FUNCTION
#define git_transaction_set_reflog_REQUIRED_ARGC 3
#define git_transaction_set_reflog_OPTIONAL_ARGC 0
/* git_transaction_set_reflog
 *
 * Parameters:
 * - tx: git_transaction *
 * - refname: const char *
 * - reflog: const git_reflog *
 * Return Type: int
 */
mrb_value
mrb_Git_git_transaction_set_reflog(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value tx;
  char * native_refname = NULL;
  mrb_value reflog;

  /* Fetch the args */
  mrb_get_args(mrb, "ozo", &tx, &native_refname, &reflog);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tx, Transaction_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Transaction expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, reflog, Reflog_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Reflog expected");
    return mrb_nil_value();
  }

  /* Unbox param: tx */
  git_transaction * native_tx = (mrb_nil_p(tx) ? NULL : mruby_unbox_git_transaction(tx));

  /* Unbox param: reflog */
  const git_reflog * native_reflog = (mrb_nil_p(reflog) ? NULL : mruby_unbox_git_reflog(reflog));

  /* Invocation */
  int native_return_value = git_transaction_set_reflog(native_tx, native_refname, native_reflog);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_set_symbolic_target */
/* sha: 3535e7b86d7a83ac7c2381daf2b7a091b3ab42928b3be2f2f8f0d17dbf50177c */
#if BIND_git_transaction_set_symbolic_target_FUNCTION
#define git_transaction_set_symbolic_target_REQUIRED_ARGC 5
#define git_transaction_set_symbolic_target_OPTIONAL_ARGC 0
/* git_transaction_set_symbolic_target
 *
 * Parameters:
 * - tx: git_transaction *
 * - refname: const char *
 * - target: const char *
 * - sig: const git_signature *
 * - msg: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_transaction_set_symbolic_target(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value tx;
  char * native_refname = NULL;
  char * native_target = NULL;
  mrb_value sig;
  char * native_msg = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozzoz", &tx, &native_refname, &native_target, &sig, &native_msg);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tx, Transaction_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Transaction expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, sig, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: tx */
  git_transaction * native_tx = (mrb_nil_p(tx) ? NULL : mruby_unbox_git_transaction(tx));

  /* Unbox param: sig */
  const git_signature * native_sig = (mrb_nil_p(sig) ? NULL : mruby_unbox_git_signature(sig));

  /* Invocation */
  int native_return_value = git_transaction_set_symbolic_target(native_tx, native_refname, native_target, native_sig, native_msg);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_transaction_set_target */
/* sha: 9e648cc0175329b2e34562eb10cd2dcca5b91b43d479b6696a61a161935de687 */
#if BIND_git_transaction_set_target_FUNCTION
#define git_transaction_set_target_REQUIRED_ARGC 5
#define git_transaction_set_target_OPTIONAL_ARGC 0
/* git_transaction_set_target
 *
 * Parameters:
 * - tx: git_transaction *
 * - refname: const char *
 * - target: const git_oid *
 * - sig: const git_signature *
 * - msg: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_transaction_set_target(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value tx;
  char * native_refname = NULL;
  mrb_value target;
  mrb_value sig;
  char * native_msg = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ozooz", &tx, &native_refname, &target, &sig, &native_msg);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tx, Transaction_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Transaction expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, target, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, sig, Signature_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Signature expected");
    return mrb_nil_value();
  }

  /* Unbox param: tx */
  git_transaction * native_tx = (mrb_nil_p(tx) ? NULL : mruby_unbox_git_transaction(tx));

  /* Unbox param: target */
  const git_oid * native_target = (mrb_nil_p(target) ? NULL : mruby_unbox_git_oid(target));

  /* Unbox param: sig */
  const git_signature * native_sig = (mrb_nil_p(sig) ? NULL : mruby_unbox_git_signature(sig));

  /* Invocation */
  int native_return_value = git_transaction_set_target(native_tx, native_refname, native_target, native_sig, native_msg);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_byid */
/* sha: 8c9e6eef07d1cfaff3f1ab51953d666f17eeff46a863af28b0ef80685a79c74d */
#if BIND_git_tree_entry_byid_FUNCTION
#define git_tree_entry_byid_REQUIRED_ARGC 2
#define git_tree_entry_byid_OPTIONAL_ARGC 0
/* git_tree_entry_byid
 *
 * Parameters:
 * - tree: const git_tree *
 * - id: const git_oid *
 * Return Type: const git_tree_entry *
 */
mrb_value
mrb_Git_git_tree_entry_byid(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &tree, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  const git_tree_entry * native_return_value = git_tree_entry_byid(native_tree, native_id);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_tree_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_byindex */
/* sha: 6b7931048fe5ad835e635f6830b956577abdb67f11ca10bc2cfaf5a96f071236 */
#if BIND_git_tree_entry_byindex_FUNCTION
#define git_tree_entry_byindex_REQUIRED_ARGC 2
#define git_tree_entry_byindex_OPTIONAL_ARGC 0
/* git_tree_entry_byindex
 *
 * Parameters:
 * - tree: const git_tree *
 * - idx: size_t
 * Return Type: const git_tree_entry *
 */
mrb_value
mrb_Git_git_tree_entry_byindex(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  mrb_int native_idx;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &tree, &native_idx);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  const git_tree_entry * native_return_value = git_tree_entry_byindex(native_tree, native_idx);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_tree_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_byname */
/* sha: e2897318c4af374cddf92afaad1877b4431c29305ad7a3ab31cdafddfee68c25 */
#if BIND_git_tree_entry_byname_FUNCTION
#define git_tree_entry_byname_REQUIRED_ARGC 2
#define git_tree_entry_byname_OPTIONAL_ARGC 0
/* git_tree_entry_byname
 *
 * Parameters:
 * - tree: const git_tree *
 * - filename: const char *
 * Return Type: const git_tree_entry *
 */
mrb_value
mrb_Git_git_tree_entry_byname(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  char * native_filename = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &tree, &native_filename);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  const git_tree_entry * native_return_value = git_tree_entry_byname(native_tree, native_filename);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_tree_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_bypath */
/* sha: cb040479365486572a11a2e7201fc471c9300c9da572a8b267f16f4523dab268 */
#if BIND_git_tree_entry_bypath_FUNCTION
#define git_tree_entry_bypath_REQUIRED_ARGC 2
#define git_tree_entry_bypath_OPTIONAL_ARGC 0
/* git_tree_entry_bypath
 *
 * Parameters:
 * - root: const git_tree *
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tree_entry_bypath(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_tree_entry * native_out = NULL;
  mrb_value root;
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &root, &native_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, root, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: root */
  const git_tree * native_root = (mrb_nil_p(root) ? NULL : mruby_unbox_git_tree(root));

  /* Invocation */
  int native_return_value = git_tree_entry_bypath(&native_out, native_root, native_path);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_tree_entry(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_cmp */
/* sha: 2804fd727f9b2116638292104ce200dd65504f8f6c0ba43e3004c7f518d63877 */
#if BIND_git_tree_entry_cmp_FUNCTION
#define git_tree_entry_cmp_REQUIRED_ARGC 2
#define git_tree_entry_cmp_OPTIONAL_ARGC 0
/* git_tree_entry_cmp
 *
 * Parameters:
 * - e1: const git_tree_entry *
 * - e2: const git_tree_entry *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tree_entry_cmp(mrb_state* mrb, mrb_value self) {
  mrb_value e1;
  mrb_value e2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &e1, &e2);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, e1, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, e2, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: e1 */
  const git_tree_entry * native_e1 = (mrb_nil_p(e1) ? NULL : mruby_unbox_git_tree_entry(e1));

  /* Unbox param: e2 */
  const git_tree_entry * native_e2 = (mrb_nil_p(e2) ? NULL : mruby_unbox_git_tree_entry(e2));

  /* Invocation */
  int native_return_value = git_tree_entry_cmp(native_e1, native_e2);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_dup */
/* sha: 51d41c64f3d3c55a75d85fd665f1220eb6d796b171d87dedd1de1d29b005bd7c */
#if BIND_git_tree_entry_dup_FUNCTION
#define git_tree_entry_dup_REQUIRED_ARGC 1
#define git_tree_entry_dup_OPTIONAL_ARGC 0
/* git_tree_entry_dup
 *
 * Parameters:
 * - source: const git_tree_entry *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tree_entry_dup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_tree_entry * native_dest = NULL;
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: source */
  const git_tree_entry * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox_git_tree_entry(source));

  /* Invocation */
  int native_return_value = git_tree_entry_dup(&native_dest, native_source);

  /* Box out param: dest */
  mrb_value dest = native_dest == NULL ? mrb_nil_value() : mruby_giftwrap_git_tree_entry(mrb, native_dest);

  RAISE_GIT_ERROR(native_return_value);

  return dest;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_filemode */
/* sha: 44ab0724911e8a41c53791713ecc3102374a417649ead6394b3b98856e9e3b10 */
#if BIND_git_tree_entry_filemode_FUNCTION
#define git_tree_entry_filemode_REQUIRED_ARGC 1
#define git_tree_entry_filemode_OPTIONAL_ARGC 0
/* git_tree_entry_filemode
 *
 * Parameters:
 * - entry: const git_tree_entry *
 * Return Type: git_filemode_t
 */
mrb_value
mrb_Git_git_tree_entry_filemode(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_tree_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_tree_entry(entry));

  /* Invocation */
  git_filemode_t native_return_value = git_tree_entry_filemode(native_entry);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_filemode_raw */
/* sha: 549701e385b7862e3ae4ec8ca17182d1289957c9293d3491aa424f985f1d96ef */
#if BIND_git_tree_entry_filemode_raw_FUNCTION
#define git_tree_entry_filemode_raw_REQUIRED_ARGC 1
#define git_tree_entry_filemode_raw_OPTIONAL_ARGC 0
/* git_tree_entry_filemode_raw
 *
 * Parameters:
 * - entry: const git_tree_entry *
 * Return Type: git_filemode_t
 */
mrb_value
mrb_Git_git_tree_entry_filemode_raw(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_tree_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_tree_entry(entry));

  /* Invocation */
  git_filemode_t native_return_value = git_tree_entry_filemode_raw(native_entry);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_free */
/* sha: 5e6cce9df0f46a0c5936b884fb061c69518df362f4d972f4ab050d874241b60b */
#if BIND_git_tree_entry_free_FUNCTION
#define git_tree_entry_free_REQUIRED_ARGC 1
#define git_tree_entry_free_OPTIONAL_ARGC 0
/* git_tree_entry_free
 *
 * Parameters:
 * - entry: git_tree_entry *
 * Return Type: void
 */
mrb_value
mrb_Git_git_tree_entry_free(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  git_tree_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_tree_entry(entry));

  /* Invocation */
  git_tree_entry_free(native_entry);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_id */
/* sha: 08a2fed5a60e489c1af03cac778d5dcb423e0a4f324cb0eb5d413161a4e0f7a5 */
#if BIND_git_tree_entry_id_FUNCTION
#define git_tree_entry_id_REQUIRED_ARGC 1
#define git_tree_entry_id_OPTIONAL_ARGC 0
/* git_tree_entry_id
 *
 * Parameters:
 * - entry: const git_tree_entry *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_tree_entry_id(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_tree_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_tree_entry(entry));

  /* Invocation */
  const git_oid * native_return_value = git_tree_entry_id(native_entry);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_name */
/* sha: 86e7cc1296775d3be0b9f9357f49d038d1f6942afa3c5f2cc7bc82b284fee038 */
#if BIND_git_tree_entry_name_FUNCTION
#define git_tree_entry_name_REQUIRED_ARGC 1
#define git_tree_entry_name_OPTIONAL_ARGC 0
/* git_tree_entry_name
 *
 * Parameters:
 * - entry: const git_tree_entry *
 * Return Type: const char *
 */
mrb_value
mrb_Git_git_tree_entry_name(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_tree_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_tree_entry(entry));

  /* Invocation */
  const char * native_return_value = git_tree_entry_name(native_entry);

  /* Box the return value */
  mrb_value return_value = native_return_value == NULL ? mrb_nil_value() : mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_to_object */
/* sha: 86e292ba68f3e2f43f07ff66c5a6fd9bc7e15a6843cb605b972ffda87d992d22 */
#if BIND_git_tree_entry_to_object_FUNCTION
#define git_tree_entry_to_object_REQUIRED_ARGC 2
#define git_tree_entry_to_object_OPTIONAL_ARGC 0
/* git_tree_entry_to_object
 *
 * Parameters:
 * - repo: git_repository *
 * - entry: const git_tree_entry *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tree_entry_to_object(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_object * native_object_out = NULL;
  mrb_value repo;
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, entry, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: entry */
  const git_tree_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_tree_entry(entry));

  /* Invocation */
  int native_return_value = git_tree_entry_to_object(&native_object_out, native_repo, native_entry);

  /* Box out param: object_out */
  mrb_value object_out = native_object_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_object(mrb, native_object_out);

  RAISE_GIT_ERROR(native_return_value);

  return object_out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entry_type */
/* sha: 67f8b7b3660fe5268110cef6370c2d10800e7682123db8a8a5d8f1c894c3aa7f */
#if BIND_git_tree_entry_type_FUNCTION
#define git_tree_entry_type_REQUIRED_ARGC 1
#define git_tree_entry_type_OPTIONAL_ARGC 0
/* git_tree_entry_type
 *
 * Parameters:
 * - entry: const git_tree_entry *
 * Return Type: git_otype
 */
mrb_value
mrb_Git_git_tree_entry_type(mrb_state* mrb, mrb_value self) {
  mrb_value entry;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &entry);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, entry, TreeEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "TreeEntry expected");
    return mrb_nil_value();
  }

  /* Unbox param: entry */
  const git_tree_entry * native_entry = (mrb_nil_p(entry) ? NULL : mruby_unbox_git_tree_entry(entry));

  /* Invocation */
  git_otype native_return_value = git_tree_entry_type(native_entry);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_entrycount */
/* sha: 0f137dd434ebc8185fbf3610b10df1b91531e9348ad74980fba524f7aa49b2c9 */
#if BIND_git_tree_entrycount_FUNCTION
#define git_tree_entrycount_REQUIRED_ARGC 1
#define git_tree_entrycount_OPTIONAL_ARGC 0
/* git_tree_entrycount
 *
 * Parameters:
 * - tree: const git_tree *
 * Return Type: size_t
 */
mrb_value
mrb_Git_git_tree_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  size_t native_return_value = git_tree_entrycount(native_tree);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_free */
/* sha: 589d938eaecbb0439e8104c8b80e67c68741926e0805c495aff47b7932fd6438 */
#if BIND_git_tree_free_FUNCTION
#define git_tree_free_REQUIRED_ARGC 1
#define git_tree_free_OPTIONAL_ARGC 0
/* git_tree_free
 *
 * Parameters:
 * - tree: git_tree *
 * Return Type: void
 */
mrb_value
mrb_Git_git_tree_free(mrb_state* mrb, mrb_value self) {
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  git_tree_free(native_tree);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_id */
/* sha: 5c1fda02a429607a74b957ee496f403f9015a9bdb40388b4f074cb871a2a093c */
#if BIND_git_tree_id_FUNCTION
#define git_tree_id_REQUIRED_ARGC 1
#define git_tree_id_OPTIONAL_ARGC 0
/* git_tree_id
 *
 * Parameters:
 * - tree: const git_tree *
 * Return Type: const git_oid *
 */
mrb_value
mrb_Git_git_tree_id(mrb_state* mrb, mrb_value self) {
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  const git_oid * native_return_value = git_tree_id(native_tree);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_oid(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_lookup */
/* sha: 37c009b1601f1002011871cbd481a76eb5d506a0191e47e7fb460bcc0f1a5228 */
#if BIND_git_tree_lookup_FUNCTION
#define git_tree_lookup_REQUIRED_ARGC 2
#define git_tree_lookup_OPTIONAL_ARGC 0
/* git_tree_lookup
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tree_lookup(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_tree * native_out = NULL;
  mrb_value repo;
  mrb_value id;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &repo, &id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_tree_lookup(&native_out, native_repo, native_id);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_tree(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_lookup_prefix */
/* sha: c44e790bdb32a193d3bbc905d767490515a1faeef2bd9fa699b139478fa88a14 */
#if BIND_git_tree_lookup_prefix_FUNCTION
#define git_tree_lookup_prefix_REQUIRED_ARGC 3
#define git_tree_lookup_prefix_OPTIONAL_ARGC 0
/* git_tree_lookup_prefix
 *
 * Parameters:
 * - repo: git_repository *
 * - id: const git_oid *
 * - len: size_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_tree_lookup_prefix(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_tree * native_out = NULL;
  mrb_value repo;
  mrb_value id;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &repo, &id, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_tree_lookup_prefix(&native_out, native_repo, native_id, native_len);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_tree(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_owner */
/* sha: 6f022cbaa2c4812e98987ac81685e04ce87b3be89b41f1d9e288cd0bcffc88c3 */
#if BIND_git_tree_owner_FUNCTION
#define git_tree_owner_REQUIRED_ARGC 1
#define git_tree_owner_OPTIONAL_ARGC 0
/* git_tree_owner
 *
 * Parameters:
 * - tree: const git_tree *
 * Return Type: git_repository *
 */
mrb_value
mrb_Git_git_tree_owner(mrb_state* mrb, mrb_value self) {
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Invocation */
  git_repository * native_return_value = git_tree_owner(native_tree);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_repository(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_tree_walk */
/* sha: 671497b84fbdf20861527e833fc782acb3ac8ae21375e16a2a41f6040b7bef01 */
#if BIND_git_tree_walk_FUNCTION
#define git_tree_walk_REQUIRED_ARGC 4
#define git_tree_walk_OPTIONAL_ARGC 0
/* git_tree_walk
 *
 * Parameters:
 * - tree: const git_tree *
 * - mode: git_treewalk_mode
 * - callback: git_treewalk_cb
 * - payload: void *
 * Return Type: int
 */
mrb_value
mrb_Git_git_tree_walk(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value tree;
  mrb_int native_mode;
  mrb_value callback;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &tree, &native_mode, &callback, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, Tree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_treewalk_cb(callback);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: tree */
  const git_tree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox_git_tree(tree));

  /* Unbox param: callback */
  git_treewalk_cb native_callback = TODO_mruby_unbox_git_treewalk_cb(callback);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  int native_return_value = git_tree_walk(native_tree, native_mode, native_callback, native_payload);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_clear */
/* sha: 3fe286f018467237aac6ba902b27cf542eab63b1dbb1936947421fb6668946e1 */
#if BIND_git_treebuilder_clear_FUNCTION
#define git_treebuilder_clear_REQUIRED_ARGC 1
#define git_treebuilder_clear_OPTIONAL_ARGC 0
/* git_treebuilder_clear
 *
 * Parameters:
 * - bld: git_treebuilder *
 * Return Type: void
 */
mrb_value
mrb_Git_git_treebuilder_clear(mrb_state* mrb, mrb_value self) {
  mrb_value bld;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &bld);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Invocation */
  git_treebuilder_clear(native_bld);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_entrycount */
/* sha: 43b6e9896bcae861f69a294ab6f4e6a82c69bd3aff3a0a128b256d8619442f52 */
#if BIND_git_treebuilder_entrycount_FUNCTION
#define git_treebuilder_entrycount_REQUIRED_ARGC 1
#define git_treebuilder_entrycount_OPTIONAL_ARGC 0
/* git_treebuilder_entrycount
 *
 * Parameters:
 * - bld: git_treebuilder *
 * Return Type: unsigned int
 */
mrb_value
mrb_Git_git_treebuilder_entrycount(mrb_state* mrb, mrb_value self) {
  mrb_value bld;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &bld);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Invocation */
  unsigned int native_return_value = git_treebuilder_entrycount(native_bld);

  /* Box the return value */
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_filter */
/* sha: 722b45e83c9685f6055bc616faf69da775be2ab0179352c34c42078cd7f680e0 */
#if BIND_git_treebuilder_filter_FUNCTION
#define git_treebuilder_filter_REQUIRED_ARGC 3
#define git_treebuilder_filter_OPTIONAL_ARGC 0
/* git_treebuilder_filter
 *
 * Parameters:
 * - bld: git_treebuilder *
 * - filter: git_treebuilder_filter_cb
 * - payload: void *
 * Return Type: void
 */
mrb_value
mrb_Git_git_treebuilder_filter(mrb_state* mrb, mrb_value self) {
  mrb_value bld;
  mrb_value filter;
  mrb_value payload;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &bld, &filter, &payload);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }
  TODO_type_check_git_treebuilder_filter_cb(filter);
  TODO_type_check_void_PTR(payload);

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Unbox param: filter */
  git_treebuilder_filter_cb native_filter = TODO_mruby_unbox_git_treebuilder_filter_cb(filter);

  /* Unbox param: payload */
  void * native_payload = TODO_mruby_unbox_void_PTR(payload);

  /* Invocation */
  git_treebuilder_filter(native_bld, native_filter, native_payload);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_free */
/* sha: c101f519dc85a10026fc4a2f3dd097d538550a4465257076886c38133fcf922b */
#if BIND_git_treebuilder_free_FUNCTION
#define git_treebuilder_free_REQUIRED_ARGC 1
#define git_treebuilder_free_OPTIONAL_ARGC 0
/* git_treebuilder_free
 *
 * Parameters:
 * - bld: git_treebuilder *
 * Return Type: void
 */
mrb_value
mrb_Git_git_treebuilder_free(mrb_state* mrb, mrb_value self) {
  mrb_value bld;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &bld);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Invocation */
  git_treebuilder_free(native_bld);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_get */
/* sha: 505e47f26d0f8c1fc1bce13e885bfe5467025e33cb20a16707e79473d15dce0a */
#if BIND_git_treebuilder_get_FUNCTION
#define git_treebuilder_get_REQUIRED_ARGC 2
#define git_treebuilder_get_OPTIONAL_ARGC 0
/* git_treebuilder_get
 *
 * Parameters:
 * - bld: git_treebuilder *
 * - filename: const char *
 * Return Type: const git_tree_entry *
 */
mrb_value
mrb_Git_git_treebuilder_get(mrb_state* mrb, mrb_value self) {
  mrb_value bld;
  char * native_filename = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &bld, &native_filename);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Invocation */
  const git_tree_entry * native_return_value = git_treebuilder_get(native_bld, native_filename);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_git_tree_entry(mrb, native_return_value));
  
  return return_value;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_insert */
/* sha: d3ab4998d2a0b60cb3f8fb138b576637265a23da25271bc6abc2ed79c2f1df11 */
#if BIND_git_treebuilder_insert_FUNCTION
#define git_treebuilder_insert_REQUIRED_ARGC 4
#define git_treebuilder_insert_OPTIONAL_ARGC 0
/* git_treebuilder_insert
 *
 * Parameters:
 * - bld: git_treebuilder *
 * - filename: const char *
 * - id: const git_oid *
 * - filemode: git_filemode_t
 * Return Type: int
 */
mrb_value
mrb_Git_git_treebuilder_insert(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_tree_entry * native_out = NULL;
  mrb_value bld;
  char * native_filename = NULL;
  mrb_value id;
  mrb_int native_filemode;

  /* Fetch the args */
  mrb_get_args(mrb, "ozoi", &bld, &native_filename, &id, &native_filemode);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, id, Oid_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Oid expected");
    return mrb_nil_value();
  }

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Unbox param: id */
  const git_oid * native_id = (mrb_nil_p(id) ? NULL : mruby_unbox_git_oid(id));

  /* Invocation */
  int native_return_value = git_treebuilder_insert(&native_out, native_bld, native_filename, native_id, native_filemode);

  /* Box out param: out */
  git_tree_entry * out_entry_dup = NULL;
  git_tree_entry_dup(&out_entry_dup, native_out);
  mrb_value out = mruby_giftwrap_git_tree_entry(mrb, out_entry_dup);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_new */
/* sha: f5b28c89081ccd78cf692b12961c22fc4e3f170465004d926752906746973342 */
#if BIND_git_treebuilder_new_FUNCTION
#define git_treebuilder_new_REQUIRED_ARGC 1
#define git_treebuilder_new_OPTIONAL_ARGC 1
/* git_treebuilder_new
 *
 * Parameters:
 * - repo: git_repository *
 * - source: const git_tree *
 * Return Type: int
 */
mrb_value
mrb_Git_git_treebuilder_new(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_treebuilder * native_out = NULL;
  mrb_value repo;
  mrb_value source = mrb_nil_value();

  /* Fetch the args */
  mrb_get_args(mrb, "o|o", &repo, &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, repo, Repository_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Repository expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, source, Tree_class(mrb)) && !mrb_nil_p(source)) {
    mrb_raise(mrb, E_TYPE_ERROR, "Tree expected");
    return mrb_nil_value();
  }

  /* Unbox param: repo */
  git_repository * native_repo = (mrb_nil_p(repo) ? NULL : mruby_unbox_git_repository(repo));

  /* Unbox param: source */
  const git_tree * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox_git_tree(source));

  /* Invocation */
  int native_return_value = git_treebuilder_new(&native_out, native_repo, native_source);

  /* Box out param: out */
  mrb_value out = native_out == NULL ? mrb_nil_value() : mruby_giftwrap_git_treebuilder(mrb, native_out);

  RAISE_GIT_ERROR(native_return_value);

  return out;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_remove */
/* sha: 650520ca33e3465f98ad72ec25dc40e2959cc28ca4deae9e6c989e967c887d2b */
#if BIND_git_treebuilder_remove_FUNCTION
#define git_treebuilder_remove_REQUIRED_ARGC 2
#define git_treebuilder_remove_OPTIONAL_ARGC 0
/* git_treebuilder_remove
 *
 * Parameters:
 * - bld: git_treebuilder *
 * - filename: const char *
 * Return Type: int
 */
mrb_value
mrb_Git_git_treebuilder_remove(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  mrb_value bld;
  char * native_filename = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz", &bld, &native_filename);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Invocation */
  int native_return_value = git_treebuilder_remove(native_bld, native_filename);

  RAISE_GIT_ERROR(native_return_value);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: git_treebuilder_write */
/* sha: 180d48db965821303b411a22fc494554724a4106eb2d4a287f69ee00c28c2918 */
#if BIND_git_treebuilder_write_FUNCTION
#define git_treebuilder_write_REQUIRED_ARGC 1
#define git_treebuilder_write_OPTIONAL_ARGC 0
/* git_treebuilder_write
 *
 * Parameters:
 * - bld: git_treebuilder *
 * Return Type: int
 */
mrb_value
mrb_Git_git_treebuilder_write(mrb_state* mrb, mrb_value self) {
  CLEAR_GIT_ERROR();

  git_oid * native_id = (git_oid*)calloc(1, sizeof(git_oid));
  mrb_value bld;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &bld);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bld, Treebuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "Treebuilder expected");
    return mrb_nil_value();
  }

  /* Unbox param: bld */
  git_treebuilder * native_bld = (mrb_nil_p(bld) ? NULL : mruby_unbox_git_treebuilder(bld));

  /* Invocation */
  int native_return_value = git_treebuilder_write(native_id, native_bld);

  /* Box out param: id */
  mrb_value id = native_id == NULL ? mrb_nil_value() : mruby_giftwrap_git_oid(mrb, native_id);

  RAISE_GIT_ERROR(native_return_value);

  return id;
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: giterr_clear */
/* sha: f88efdc3ef04738822b48b7aa8af4c5f2040c2b9e1953ee98ae0390680f42e3a */
#if BIND_giterr_clear_FUNCTION
#define giterr_clear_REQUIRED_ARGC 0
#define giterr_clear_OPTIONAL_ARGC 0
/* giterr_clear
 *
 * Parameters: None
 * Return Type: void
 */
mrb_value
mrb_Git_giterr_clear(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  giterr_clear();

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: giterr_last */
/* sha: dcaf1211d8add052895d879e9ad87fa09aceb0a31ecdc6a53aa6e615faf19217 */
#if BIND_giterr_last_FUNCTION
#define giterr_last_REQUIRED_ARGC 0
#define giterr_last_OPTIONAL_ARGC 0
/* giterr_last
 *
 * Parameters: None
 * Return Type: const git_error *
 */
mrb_value
mrb_Git_giterr_last(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  return mruby_git_last_error(mrb);
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: giterr_set_oom */
/* sha: d9aa95593a2e7e9fc83ee2ef2e99d484dfbc03ef4c309988b095ea68725bbc8b */
#if BIND_giterr_set_oom_FUNCTION
#define giterr_set_oom_REQUIRED_ARGC 0
#define giterr_set_oom_OPTIONAL_ARGC 0
/* giterr_set_oom
 *
 * Parameters: None
 * Return Type: void
 */
mrb_value
mrb_Git_giterr_set_oom(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  giterr_set_oom();

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: giterr_set_str */
/* sha: 75b90fea1ffef69b929a521c6a47187fb536ab5290c48bda2d8f3a9e703573f9 */
#if BIND_giterr_set_str_FUNCTION
#define giterr_set_str_REQUIRED_ARGC 2
#define giterr_set_str_OPTIONAL_ARGC 0
/* giterr_set_str
 *
 * Parameters:
 * - error_class: int
 * - string: const char *
 * Return Type: void
 */
mrb_value
mrb_Git_giterr_set_str(mrb_state* mrb, mrb_value self) {
  mrb_int native_error_class;
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "iz", &native_error_class, &native_string);

  /* Invocation */
  giterr_set_str(native_error_class, native_string);

  return mrb_nil_value();
}
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: imaxdiv */
/* sha: ddb792afe5b5fd82a0a55acc5708adf28546d069d99d56d5718f0ce773017319 */
#if BIND_imaxdiv_FUNCTION
#define imaxdiv_REQUIRED_ARGC 2
#define imaxdiv_OPTIONAL_ARGC 0
/* imaxdiv
 *
 * Parameters:
 * - numer: intmax_t
 * - denom: intmax_t
 * Return Type: int
 */
mrb_value
mrb_Git_imaxdiv(mrb_state* mrb, mrb_value self) {
  mrb_int native_numer;
  mrb_int native_denom;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_numer, &native_denom);

  /* Invocation */
  imaxdiv_t native_return_value = imaxdiv(native_numer, native_denom);
  
  /* TODO: box & return */
}
#endif
/* MRUBY_BINDING_END */


void mrb_mruby_git_gem_init(mrb_state* mrb) {
/* MRUBY_BINDING: pre_module_definition */
/* sha: user_defined */
  git_libgit2_init();
/* MRUBY_BINDING_END */
  
  struct RClass* Git_module = mrb_define_module(mrb, "Git");
  mruby_Git_define_macro_constants(mrb);
  mruby_Git_define_enum_constants(mrb);

/* MRUBY_BINDING: pre_class_initializations */
/* sha: user_defined */

  /* Get this initialized first so subclasses can inherit */
  mrb_Git_Object_init(mrb);

/* MRUBY_BINDING_END */

/* MRUBY_BINDING: class_initializations */
/* sha: 3bc4c761a5fe8b8ef2822567ea860258a93c5c8650c2090060c1bb1353ed5655 */
#if BIND_AnnotatedCommit_TYPE
  mrb_Git_AnnotatedCommit_init(mrb);
#endif
#if BIND_Blame_TYPE
  mrb_Git_Blame_init(mrb);
#endif
#if BIND_BlameHunk_TYPE
  mrb_Git_BlameHunk_init(mrb);
#endif
#if BIND_BlameOptions_TYPE
  mrb_Git_BlameOptions_init(mrb);
#endif
#if BIND_Blob_TYPE
  mrb_Git_Blob_init(mrb);
#endif
#if BIND_BranchIterator_TYPE
  mrb_Git_BranchIterator_init(mrb);
#endif
#if BIND_Buf_TYPE
  mrb_Git_Buf_init(mrb);
#endif
#if BIND_Cert_TYPE
  mrb_Git_Cert_init(mrb);
#endif
#if BIND_CertHostkey_TYPE
  mrb_Git_CertHostkey_init(mrb);
#endif
#if BIND_CertX509_TYPE
  mrb_Git_CertX509_init(mrb);
#endif
#if BIND_CheckoutOptions_TYPE
  mrb_Git_CheckoutOptions_init(mrb);
#endif
#if BIND_CheckoutPerfdata_TYPE
  mrb_Git_CheckoutPerfdata_init(mrb);
#endif
#if BIND_CherrypickOptions_TYPE
  mrb_Git_CherrypickOptions_init(mrb);
#endif
#if BIND_CloneOptions_TYPE
  mrb_Git_CloneOptions_init(mrb);
#endif
#if BIND_Commit_TYPE
  mrb_Git_Commit_init(mrb);
#endif
#if BIND_Config_TYPE
  mrb_Git_Config_init(mrb);
#endif
#if BIND_ConfigBackend_TYPE
  mrb_Git_ConfigBackend_init(mrb);
#endif
#if BIND_ConfigEntry_TYPE
  mrb_Git_ConfigEntry_init(mrb);
#endif
#if BIND_ConfigIterator_TYPE
  mrb_Git_ConfigIterator_init(mrb);
#endif
#if BIND_Cred_TYPE
  mrb_Git_Cred_init(mrb);
#endif
#if BIND_CredSshCustom_TYPE
  mrb_Git_CredSshCustom_init(mrb);
#endif
#if BIND_CredSshInteractive_TYPE
  mrb_Git_CredSshInteractive_init(mrb);
#endif
#if BIND_CredSshKey_TYPE
  mrb_Git_CredSshKey_init(mrb);
#endif
#if BIND_CredUsername_TYPE
  mrb_Git_CredUsername_init(mrb);
#endif
#if BIND_CredUserpassPayload_TYPE
  mrb_Git_CredUserpassPayload_init(mrb);
#endif
#if BIND_CredUserpassPlaintext_TYPE
  mrb_Git_CredUserpassPlaintext_init(mrb);
#endif
#if BIND_CvarMap_TYPE
  mrb_Git_CvarMap_init(mrb);
#endif
#if BIND_DescribeFormatOptions_TYPE
  mrb_Git_DescribeFormatOptions_init(mrb);
#endif
#if BIND_DescribeOptions_TYPE
  mrb_Git_DescribeOptions_init(mrb);
#endif
#if BIND_DescribeResult_TYPE
  mrb_Git_DescribeResult_init(mrb);
#endif
#if BIND_Diff_TYPE
  mrb_Git_Diff_init(mrb);
#endif
#if BIND_DiffBinary_TYPE
  mrb_Git_DiffBinary_init(mrb);
#endif
#if BIND_DiffBinaryFile_TYPE
  mrb_Git_DiffBinaryFile_init(mrb);
#endif
#if BIND_DiffDelta_TYPE
  mrb_Git_DiffDelta_init(mrb);
#endif
#if BIND_DiffFile_TYPE
  mrb_Git_DiffFile_init(mrb);
#endif
#if BIND_DiffFindOptions_TYPE
  mrb_Git_DiffFindOptions_init(mrb);
#endif
#if BIND_DiffFormatEmailOptions_TYPE
  mrb_Git_DiffFormatEmailOptions_init(mrb);
#endif
#if BIND_DiffHunk_TYPE
  mrb_Git_DiffHunk_init(mrb);
#endif
#if BIND_DiffLine_TYPE
  mrb_Git_DiffLine_init(mrb);
#endif
#if BIND_DiffOptions_TYPE
  mrb_Git_DiffOptions_init(mrb);
#endif
#if BIND_DiffSimilarityMetric_TYPE
  mrb_Git_DiffSimilarityMetric_init(mrb);
#endif
#if BIND_DiffStats_TYPE
  mrb_Git_DiffStats_init(mrb);
#endif
#if BIND_Error_TYPE
  mrb_Git_Error_init(mrb);
#endif
#if BIND_FetchOptions_TYPE
  mrb_Git_FetchOptions_init(mrb);
#endif
#if BIND_Filter_TYPE
  mrb_Git_Filter_init(mrb);
#endif
#if BIND_FilterList_TYPE
  mrb_Git_FilterList_init(mrb);
#endif
#if BIND_ImaxdivT_TYPE
  mrb_Git_ImaxdivT_init(mrb);
#endif
#if BIND_Index_TYPE
  mrb_Git_Index_init(mrb);
#endif
#if BIND_IndexConflictIterator_TYPE
  mrb_Git_IndexConflictIterator_init(mrb);
#endif
#if BIND_IndexEntry_TYPE
  mrb_Git_IndexEntry_init(mrb);
#endif
#if BIND_Indexer_TYPE
  mrb_Git_Indexer_init(mrb);
#endif
#if BIND_IndexTime_TYPE
  mrb_Git_IndexTime_init(mrb);
#endif
#if BIND_LIBSSH2SESSION_TYPE
  mrb_Git_LIBSSH2SESSION_init(mrb);
#endif
#if BIND_LIBSSH2USERAUTHKBDINTPROMPT_TYPE
  mrb_Git_LIBSSH2USERAUTHKBDINTPROMPT_init(mrb);
#endif
#if BIND_LIBSSH2USERAUTHKBDINTRESPONSE_TYPE
  mrb_Git_LIBSSH2USERAUTHKBDINTRESPONSE_init(mrb);
#endif
#if BIND_MergeFileInput_TYPE
  mrb_Git_MergeFileInput_init(mrb);
#endif
#if BIND_MergeFileOptions_TYPE
  mrb_Git_MergeFileOptions_init(mrb);
#endif
#if BIND_MergeFileResult_TYPE
  mrb_Git_MergeFileResult_init(mrb);
#endif
#if BIND_MergeOptions_TYPE
  mrb_Git_MergeOptions_init(mrb);
#endif
#if BIND_MergeResult_TYPE
  mrb_Git_MergeResult_init(mrb);
#endif
#if BIND_Note_TYPE
  mrb_Git_Note_init(mrb);
#endif
#if BIND_NoteIterator_TYPE
  mrb_Git_NoteIterator_init(mrb);
#endif
#if BIND_Object_TYPE
  mrb_Git_Object_init(mrb);
#endif
#if BIND_Odb_TYPE
  mrb_Git_Odb_init(mrb);
#endif
#if BIND_OdbBackend_TYPE
  mrb_Git_OdbBackend_init(mrb);
#endif
#if BIND_OdbObject_TYPE
  mrb_Git_OdbObject_init(mrb);
#endif
#if BIND_OdbStream_TYPE
  mrb_Git_OdbStream_init(mrb);
#endif
#if BIND_OdbWritepack_TYPE
  mrb_Git_OdbWritepack_init(mrb);
#endif
#if BIND_Oid_TYPE
  mrb_Git_Oid_init(mrb);
#endif
#if BIND_Oidarray_TYPE
  mrb_Git_Oidarray_init(mrb);
#endif
#if BIND_OidShorten_TYPE
  mrb_Git_OidShorten_init(mrb);
#endif
#if BIND_Packbuilder_TYPE
  mrb_Git_Packbuilder_init(mrb);
#endif
#if BIND_Patch_TYPE
  mrb_Git_Patch_init(mrb);
#endif
#if BIND_Pathspec_TYPE
  mrb_Git_Pathspec_init(mrb);
#endif
#if BIND_PathspecMatchList_TYPE
  mrb_Git_PathspecMatchList_init(mrb);
#endif
#if BIND_Push_TYPE
  mrb_Git_Push_init(mrb);
#endif
#if BIND_PushOptions_TYPE
  mrb_Git_PushOptions_init(mrb);
#endif
#if BIND_PushUpdate_TYPE
  mrb_Git_PushUpdate_init(mrb);
#endif
#if BIND_Rebase_TYPE
  mrb_Git_Rebase_init(mrb);
#endif
#if BIND_RebaseOperation_TYPE
  mrb_Git_RebaseOperation_init(mrb);
#endif
#if BIND_RebaseOptions_TYPE
  mrb_Git_RebaseOptions_init(mrb);
#endif
#if BIND_Refdb_TYPE
  mrb_Git_Refdb_init(mrb);
#endif
#if BIND_RefdbBackend_TYPE
  mrb_Git_RefdbBackend_init(mrb);
#endif
#if BIND_Reference_TYPE
  mrb_Git_Reference_init(mrb);
#endif
#if BIND_ReferenceIterator_TYPE
  mrb_Git_ReferenceIterator_init(mrb);
#endif
#if BIND_Reflog_TYPE
  mrb_Git_Reflog_init(mrb);
#endif
#if BIND_ReflogEntry_TYPE
  mrb_Git_ReflogEntry_init(mrb);
#endif
#if BIND_Refspec_TYPE
  mrb_Git_Refspec_init(mrb);
#endif
#if BIND_Remote_TYPE
  mrb_Git_Remote_init(mrb);
#endif
#if BIND_RemoteCallbacks_TYPE
  mrb_Git_RemoteCallbacks_init(mrb);
#endif
#if BIND_RemoteHead_TYPE
  mrb_Git_RemoteHead_init(mrb);
#endif
#if BIND_Repository_TYPE
  mrb_Git_Repository_init(mrb);
#endif
#if BIND_RepositoryInitOptions_TYPE
  mrb_Git_RepositoryInitOptions_init(mrb);
#endif
#if BIND_RevertOptions_TYPE
  mrb_Git_RevertOptions_init(mrb);
#endif
#if BIND_Revspec_TYPE
  mrb_Git_Revspec_init(mrb);
#endif
#if BIND_Revwalk_TYPE
  mrb_Git_Revwalk_init(mrb);
#endif
#if BIND_Signature_TYPE
  mrb_Git_Signature_init(mrb);
#endif
#if BIND_StashApplyOptions_TYPE
  mrb_Git_StashApplyOptions_init(mrb);
#endif
#if BIND_StatusEntry_TYPE
  mrb_Git_StatusEntry_init(mrb);
#endif
#if BIND_StatusList_TYPE
  mrb_Git_StatusList_init(mrb);
#endif
#if BIND_StatusOptions_TYPE
  mrb_Git_StatusOptions_init(mrb);
#endif
#if BIND_Strarray_TYPE
  mrb_Git_Strarray_init(mrb);
#endif
#if BIND_Submodule_TYPE
  mrb_Git_Submodule_init(mrb);
#endif
#if BIND_SubmoduleUpdateOptions_TYPE
  mrb_Git_SubmoduleUpdateOptions_init(mrb);
#endif
#if BIND_Tag_TYPE
  mrb_Git_Tag_init(mrb);
#endif
#if BIND_Time_TYPE
  mrb_Git_Time_init(mrb);
#endif
#if BIND_Transaction_TYPE
  mrb_Git_Transaction_init(mrb);
#endif
#if BIND_TransferProgress_TYPE
  mrb_Git_TransferProgress_init(mrb);
#endif
#if BIND_Transport_TYPE
  mrb_Git_Transport_init(mrb);
#endif
#if BIND_Tree_TYPE
  mrb_Git_Tree_init(mrb);
#endif
#if BIND_Treebuilder_TYPE
  mrb_Git_Treebuilder_init(mrb);
#endif
#if BIND_TreeEntry_TYPE
  mrb_Git_TreeEntry_init(mrb);
#endif
#if BIND_Writestream_TYPE
  mrb_Git_Writestream_init(mrb);
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: pre_global_function_initializations */
/* sha: user_defined */

/* MRUBY_BINDING_END */

/* MRUBY_BINDING: global_function_definitions */
/* sha: 402b5b64f2deed15d276bc184deef0adbc24147ec0ad3d39d6e577b0266fdabf */
  /*
   * Global Functions
   */
#if BIND_git_annotated_commit_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "annotated_commit_free", mrb_Git_git_annotated_commit_free, MRB_ARGS_ARG(git_annotated_commit_free_REQUIRED_ARGC, git_annotated_commit_free_OPTIONAL_ARGC));
#endif
#if BIND_git_annotated_commit_from_fetchhead_FUNCTION
  mrb_define_class_method(mrb, Git_module, "annotated_commit_from_fetchhead", mrb_Git_git_annotated_commit_from_fetchhead, MRB_ARGS_ARG(git_annotated_commit_from_fetchhead_REQUIRED_ARGC, git_annotated_commit_from_fetchhead_OPTIONAL_ARGC));
#endif
#if BIND_git_annotated_commit_from_ref_FUNCTION
  mrb_define_class_method(mrb, Git_module, "annotated_commit_from_ref", mrb_Git_git_annotated_commit_from_ref, MRB_ARGS_ARG(git_annotated_commit_from_ref_REQUIRED_ARGC, git_annotated_commit_from_ref_OPTIONAL_ARGC));
#endif
#if BIND_git_annotated_commit_from_revspec_FUNCTION
  mrb_define_class_method(mrb, Git_module, "annotated_commit_from_revspec", mrb_Git_git_annotated_commit_from_revspec, MRB_ARGS_ARG(git_annotated_commit_from_revspec_REQUIRED_ARGC, git_annotated_commit_from_revspec_OPTIONAL_ARGC));
#endif
#if BIND_git_annotated_commit_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "annotated_commit_id", mrb_Git_git_annotated_commit_id, MRB_ARGS_ARG(git_annotated_commit_id_REQUIRED_ARGC, git_annotated_commit_id_OPTIONAL_ARGC));
#endif
#if BIND_git_annotated_commit_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "annotated_commit_lookup", mrb_Git_git_annotated_commit_lookup, MRB_ARGS_ARG(git_annotated_commit_lookup_REQUIRED_ARGC, git_annotated_commit_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_attr_add_macro_FUNCTION
  mrb_define_class_method(mrb, Git_module, "attr_add_macro", mrb_Git_git_attr_add_macro, MRB_ARGS_ARG(git_attr_add_macro_REQUIRED_ARGC, git_attr_add_macro_OPTIONAL_ARGC));
#endif
#if BIND_git_attr_cache_flush_FUNCTION
  mrb_define_class_method(mrb, Git_module, "attr_cache_flush", mrb_Git_git_attr_cache_flush, MRB_ARGS_ARG(git_attr_cache_flush_REQUIRED_ARGC, git_attr_cache_flush_OPTIONAL_ARGC));
#endif
#if BIND_git_attr_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "attr_foreach", mrb_Git_git_attr_foreach, MRB_ARGS_ARG(git_attr_foreach_REQUIRED_ARGC, git_attr_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_attr_get_FUNCTION
  mrb_define_class_method(mrb, Git_module, "attr_get", mrb_Git_git_attr_get, MRB_ARGS_ARG(git_attr_get_REQUIRED_ARGC, git_attr_get_OPTIONAL_ARGC));
#endif
#if BIND_git_attr_get_many_FUNCTION
  mrb_define_class_method(mrb, Git_module, "attr_get_many", mrb_Git_git_attr_get_many, MRB_ARGS_ARG(git_attr_get_many_REQUIRED_ARGC, git_attr_get_many_OPTIONAL_ARGC));
#endif
#if BIND_git_attr_value_FUNCTION
  mrb_define_class_method(mrb, Git_module, "attr_value", mrb_Git_git_attr_value, MRB_ARGS_ARG(git_attr_value_REQUIRED_ARGC, git_attr_value_OPTIONAL_ARGC));
#endif
#if BIND_git_blame_buffer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blame_buffer", mrb_Git_git_blame_buffer, MRB_ARGS_ARG(git_blame_buffer_REQUIRED_ARGC, git_blame_buffer_OPTIONAL_ARGC));
#endif
#if BIND_git_blame_file_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blame_file", mrb_Git_git_blame_file, MRB_ARGS_ARG(git_blame_file_REQUIRED_ARGC, git_blame_file_OPTIONAL_ARGC));
#endif
#if BIND_git_blame_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blame_free", mrb_Git_git_blame_free, MRB_ARGS_ARG(git_blame_free_REQUIRED_ARGC, git_blame_free_OPTIONAL_ARGC));
#endif
#if BIND_git_blame_get_hunk_byindex_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blame_get_hunk_byindex", mrb_Git_git_blame_get_hunk_byindex, MRB_ARGS_ARG(git_blame_get_hunk_byindex_REQUIRED_ARGC, git_blame_get_hunk_byindex_OPTIONAL_ARGC));
#endif
#if BIND_git_blame_get_hunk_byline_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blame_get_hunk_byline", mrb_Git_git_blame_get_hunk_byline, MRB_ARGS_ARG(git_blame_get_hunk_byline_REQUIRED_ARGC, git_blame_get_hunk_byline_OPTIONAL_ARGC));
#endif
#if BIND_git_blame_get_hunk_count_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blame_get_hunk_count", mrb_Git_git_blame_get_hunk_count, MRB_ARGS_ARG(git_blame_get_hunk_count_REQUIRED_ARGC, git_blame_get_hunk_count_OPTIONAL_ARGC));
#endif
#if BIND_git_blame_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blame_init_options", mrb_Git_git_blame_init_options, MRB_ARGS_ARG(git_blame_init_options_REQUIRED_ARGC, git_blame_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_create_frombuffer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_create_frombuffer", mrb_Git_git_blob_create_frombuffer, MRB_ARGS_ARG(git_blob_create_frombuffer_REQUIRED_ARGC, git_blob_create_frombuffer_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_create_fromchunks_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_create_fromchunks", mrb_Git_git_blob_create_fromchunks, MRB_ARGS_ARG(git_blob_create_fromchunks_REQUIRED_ARGC, git_blob_create_fromchunks_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_create_fromdisk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_create_fromdisk", mrb_Git_git_blob_create_fromdisk, MRB_ARGS_ARG(git_blob_create_fromdisk_REQUIRED_ARGC, git_blob_create_fromdisk_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_create_fromworkdir_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_create_fromworkdir", mrb_Git_git_blob_create_fromworkdir, MRB_ARGS_ARG(git_blob_create_fromworkdir_REQUIRED_ARGC, git_blob_create_fromworkdir_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_filtered_content_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_filtered_content", mrb_Git_git_blob_filtered_content, MRB_ARGS_ARG(git_blob_filtered_content_REQUIRED_ARGC, git_blob_filtered_content_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_free", mrb_Git_git_blob_free, MRB_ARGS_ARG(git_blob_free_REQUIRED_ARGC, git_blob_free_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_id", mrb_Git_git_blob_id, MRB_ARGS_ARG(git_blob_id_REQUIRED_ARGC, git_blob_id_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_is_binary_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_is_binary", mrb_Git_git_blob_is_binary, MRB_ARGS_ARG(git_blob_is_binary_REQUIRED_ARGC, git_blob_is_binary_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_lookup", mrb_Git_git_blob_lookup, MRB_ARGS_ARG(git_blob_lookup_REQUIRED_ARGC, git_blob_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_lookup_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_lookup_prefix", mrb_Git_git_blob_lookup_prefix, MRB_ARGS_ARG(git_blob_lookup_prefix_REQUIRED_ARGC, git_blob_lookup_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_owner", mrb_Git_git_blob_owner, MRB_ARGS_ARG(git_blob_owner_REQUIRED_ARGC, git_blob_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_rawcontent_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_rawcontent", mrb_Git_git_blob_rawcontent, MRB_ARGS_ARG(git_blob_rawcontent_REQUIRED_ARGC, git_blob_rawcontent_OPTIONAL_ARGC));
#endif
#if BIND_git_blob_rawsize_FUNCTION
  mrb_define_class_method(mrb, Git_module, "blob_rawsize", mrb_Git_git_blob_rawsize, MRB_ARGS_ARG(git_blob_rawsize_REQUIRED_ARGC, git_blob_rawsize_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_create", mrb_Git_git_branch_create, MRB_ARGS_ARG(git_branch_create_REQUIRED_ARGC, git_branch_create_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_create_from_annotated_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_create_from_annotated", mrb_Git_git_branch_create_from_annotated, MRB_ARGS_ARG(git_branch_create_from_annotated_REQUIRED_ARGC, git_branch_create_from_annotated_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_delete_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_delete", mrb_Git_git_branch_delete, MRB_ARGS_ARG(git_branch_delete_REQUIRED_ARGC, git_branch_delete_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_is_head_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_is_head", mrb_Git_git_branch_is_head, MRB_ARGS_ARG(git_branch_is_head_REQUIRED_ARGC, git_branch_is_head_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_iterator_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_iterator_free", mrb_Git_git_branch_iterator_free, MRB_ARGS_ARG(git_branch_iterator_free_REQUIRED_ARGC, git_branch_iterator_free_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_iterator_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_iterator_new", mrb_Git_git_branch_iterator_new, MRB_ARGS_ARG(git_branch_iterator_new_REQUIRED_ARGC, git_branch_iterator_new_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_lookup", mrb_Git_git_branch_lookup, MRB_ARGS_ARG(git_branch_lookup_REQUIRED_ARGC, git_branch_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_move_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_move", mrb_Git_git_branch_move, MRB_ARGS_ARG(git_branch_move_REQUIRED_ARGC, git_branch_move_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_name", mrb_Git_git_branch_name, MRB_ARGS_ARG(git_branch_name_REQUIRED_ARGC, git_branch_name_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_next_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_next", mrb_Git_git_branch_next, MRB_ARGS_ARG(git_branch_next_REQUIRED_ARGC, git_branch_next_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_remote_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_remote_name", mrb_Git_git_branch_remote_name, MRB_ARGS_ARG(git_branch_remote_name_REQUIRED_ARGC, git_branch_remote_name_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_set_upstream_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_set_upstream", mrb_Git_git_branch_set_upstream, MRB_ARGS_ARG(git_branch_set_upstream_REQUIRED_ARGC, git_branch_set_upstream_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_upstream_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_upstream", mrb_Git_git_branch_upstream, MRB_ARGS_ARG(git_branch_upstream_REQUIRED_ARGC, git_branch_upstream_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_upstream_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_upstream_name", mrb_Git_git_branch_upstream_name, MRB_ARGS_ARG(git_branch_upstream_name_REQUIRED_ARGC, git_branch_upstream_name_OPTIONAL_ARGC));
#endif
#if BIND_git_branch_upstream_remote_FUNCTION
  mrb_define_class_method(mrb, Git_module, "branch_upstream_remote", mrb_Git_git_branch_upstream_remote, MRB_ARGS_ARG(git_branch_upstream_remote_REQUIRED_ARGC, git_branch_upstream_remote_OPTIONAL_ARGC));
#endif
#if BIND_git_buf_contains_nul_FUNCTION
  mrb_define_class_method(mrb, Git_module, "buf_contains_nul", mrb_Git_git_buf_contains_nul, MRB_ARGS_ARG(git_buf_contains_nul_REQUIRED_ARGC, git_buf_contains_nul_OPTIONAL_ARGC));
#endif
#if BIND_git_buf_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "buf_free", mrb_Git_git_buf_free, MRB_ARGS_ARG(git_buf_free_REQUIRED_ARGC, git_buf_free_OPTIONAL_ARGC));
#endif
#if BIND_git_buf_grow_FUNCTION
  mrb_define_class_method(mrb, Git_module, "buf_grow", mrb_Git_git_buf_grow, MRB_ARGS_ARG(git_buf_grow_REQUIRED_ARGC, git_buf_grow_OPTIONAL_ARGC));
#endif
#if BIND_git_buf_is_binary_FUNCTION
  mrb_define_class_method(mrb, Git_module, "buf_is_binary", mrb_Git_git_buf_is_binary, MRB_ARGS_ARG(git_buf_is_binary_REQUIRED_ARGC, git_buf_is_binary_OPTIONAL_ARGC));
#endif
#if BIND_git_buf_set_FUNCTION
  mrb_define_class_method(mrb, Git_module, "buf_set", mrb_Git_git_buf_set, MRB_ARGS_ARG(git_buf_set_REQUIRED_ARGC, git_buf_set_OPTIONAL_ARGC));
#endif
#if BIND_git_checkout_head_FUNCTION
  mrb_define_class_method(mrb, Git_module, "checkout_head", mrb_Git_git_checkout_head, MRB_ARGS_ARG(git_checkout_head_REQUIRED_ARGC, git_checkout_head_OPTIONAL_ARGC));
#endif
#if BIND_git_checkout_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "checkout_index", mrb_Git_git_checkout_index, MRB_ARGS_ARG(git_checkout_index_REQUIRED_ARGC, git_checkout_index_OPTIONAL_ARGC));
#endif
#if BIND_git_checkout_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "checkout_init_options", mrb_Git_git_checkout_init_options, MRB_ARGS_ARG(git_checkout_init_options_REQUIRED_ARGC, git_checkout_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_checkout_tree_FUNCTION
  mrb_define_class_method(mrb, Git_module, "checkout_tree", mrb_Git_git_checkout_tree, MRB_ARGS_ARG(git_checkout_tree_REQUIRED_ARGC, git_checkout_tree_OPTIONAL_ARGC));
#endif
#if BIND_git_cherrypick_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cherrypick", mrb_Git_git_cherrypick, MRB_ARGS_ARG(git_cherrypick_REQUIRED_ARGC, git_cherrypick_OPTIONAL_ARGC));
#endif
#if BIND_git_cherrypick_commit_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cherrypick_commit", mrb_Git_git_cherrypick_commit, MRB_ARGS_ARG(git_cherrypick_commit_REQUIRED_ARGC, git_cherrypick_commit_OPTIONAL_ARGC));
#endif
#if BIND_git_cherrypick_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cherrypick_init_options", mrb_Git_git_cherrypick_init_options, MRB_ARGS_ARG(git_cherrypick_init_options_REQUIRED_ARGC, git_cherrypick_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_clone_FUNCTION
  mrb_define_class_method(mrb, Git_module, "clone", mrb_Git_git_clone, MRB_ARGS_ARG(git_clone_REQUIRED_ARGC, git_clone_OPTIONAL_ARGC));
#endif
#if BIND_git_clone_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "clone_init_options", mrb_Git_git_clone_init_options, MRB_ARGS_ARG(git_clone_init_options_REQUIRED_ARGC, git_clone_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_amend_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_amend", mrb_Git_git_commit_amend, MRB_ARGS_ARG(git_commit_amend_REQUIRED_ARGC, git_commit_amend_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_author_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_author", mrb_Git_git_commit_author, MRB_ARGS_ARG(git_commit_author_REQUIRED_ARGC, git_commit_author_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_body_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_body", mrb_Git_git_commit_body, MRB_ARGS_ARG(git_commit_body_REQUIRED_ARGC, git_commit_body_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_committer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_committer", mrb_Git_git_commit_committer, MRB_ARGS_ARG(git_commit_committer_REQUIRED_ARGC, git_commit_committer_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_create", mrb_Git_git_commit_create, MRB_ARGS_ARG(git_commit_create_REQUIRED_ARGC, git_commit_create_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_create_v_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_create_v", mrb_Git_git_commit_create_v, MRB_ARGS_ARG(git_commit_create_v_REQUIRED_ARGC, git_commit_create_v_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_free", mrb_Git_git_commit_free, MRB_ARGS_ARG(git_commit_free_REQUIRED_ARGC, git_commit_free_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_header_field_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_header_field", mrb_Git_git_commit_header_field, MRB_ARGS_ARG(git_commit_header_field_REQUIRED_ARGC, git_commit_header_field_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_id", mrb_Git_git_commit_id, MRB_ARGS_ARG(git_commit_id_REQUIRED_ARGC, git_commit_id_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_lookup", mrb_Git_git_commit_lookup, MRB_ARGS_ARG(git_commit_lookup_REQUIRED_ARGC, git_commit_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_lookup_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_lookup_prefix", mrb_Git_git_commit_lookup_prefix, MRB_ARGS_ARG(git_commit_lookup_prefix_REQUIRED_ARGC, git_commit_lookup_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_message_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_message", mrb_Git_git_commit_message, MRB_ARGS_ARG(git_commit_message_REQUIRED_ARGC, git_commit_message_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_message_encoding_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_message_encoding", mrb_Git_git_commit_message_encoding, MRB_ARGS_ARG(git_commit_message_encoding_REQUIRED_ARGC, git_commit_message_encoding_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_message_raw_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_message_raw", mrb_Git_git_commit_message_raw, MRB_ARGS_ARG(git_commit_message_raw_REQUIRED_ARGC, git_commit_message_raw_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_nth_gen_ancestor_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_nth_gen_ancestor", mrb_Git_git_commit_nth_gen_ancestor, MRB_ARGS_ARG(git_commit_nth_gen_ancestor_REQUIRED_ARGC, git_commit_nth_gen_ancestor_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_owner", mrb_Git_git_commit_owner, MRB_ARGS_ARG(git_commit_owner_REQUIRED_ARGC, git_commit_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_parent_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_parent", mrb_Git_git_commit_parent, MRB_ARGS_ARG(git_commit_parent_REQUIRED_ARGC, git_commit_parent_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_parent_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_parent_id", mrb_Git_git_commit_parent_id, MRB_ARGS_ARG(git_commit_parent_id_REQUIRED_ARGC, git_commit_parent_id_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_parentcount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_parentcount", mrb_Git_git_commit_parentcount, MRB_ARGS_ARG(git_commit_parentcount_REQUIRED_ARGC, git_commit_parentcount_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_raw_header_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_raw_header", mrb_Git_git_commit_raw_header, MRB_ARGS_ARG(git_commit_raw_header_REQUIRED_ARGC, git_commit_raw_header_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_summary_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_summary", mrb_Git_git_commit_summary, MRB_ARGS_ARG(git_commit_summary_REQUIRED_ARGC, git_commit_summary_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_time_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_time", mrb_Git_git_commit_time, MRB_ARGS_ARG(git_commit_time_REQUIRED_ARGC, git_commit_time_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_time_offset_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_time_offset", mrb_Git_git_commit_time_offset, MRB_ARGS_ARG(git_commit_time_offset_REQUIRED_ARGC, git_commit_time_offset_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_tree_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_tree", mrb_Git_git_commit_tree, MRB_ARGS_ARG(git_commit_tree_REQUIRED_ARGC, git_commit_tree_OPTIONAL_ARGC));
#endif
#if BIND_git_commit_tree_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "commit_tree_id", mrb_Git_git_commit_tree_id, MRB_ARGS_ARG(git_commit_tree_id_REQUIRED_ARGC, git_commit_tree_id_OPTIONAL_ARGC));
#endif
#if BIND_git_config_add_file_ondisk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_add_file_ondisk", mrb_Git_git_config_add_file_ondisk, MRB_ARGS_ARG(git_config_add_file_ondisk_REQUIRED_ARGC, git_config_add_file_ondisk_OPTIONAL_ARGC));
#endif
#if BIND_git_config_backend_foreach_match_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_backend_foreach_match", mrb_Git_git_config_backend_foreach_match, MRB_ARGS_ARG(git_config_backend_foreach_match_REQUIRED_ARGC, git_config_backend_foreach_match_OPTIONAL_ARGC));
#endif
#if BIND_git_config_delete_entry_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_delete_entry", mrb_Git_git_config_delete_entry, MRB_ARGS_ARG(git_config_delete_entry_REQUIRED_ARGC, git_config_delete_entry_OPTIONAL_ARGC));
#endif
#if BIND_git_config_delete_multivar_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_delete_multivar", mrb_Git_git_config_delete_multivar, MRB_ARGS_ARG(git_config_delete_multivar_REQUIRED_ARGC, git_config_delete_multivar_OPTIONAL_ARGC));
#endif
#if BIND_git_config_entry_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_entry_free", mrb_Git_git_config_entry_free, MRB_ARGS_ARG(git_config_entry_free_REQUIRED_ARGC, git_config_entry_free_OPTIONAL_ARGC));
#endif
#if BIND_git_config_find_global_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_find_global", mrb_Git_git_config_find_global, MRB_ARGS_ARG(git_config_find_global_REQUIRED_ARGC, git_config_find_global_OPTIONAL_ARGC));
#endif
#if BIND_git_config_find_programdata_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_find_programdata", mrb_Git_git_config_find_programdata, MRB_ARGS_ARG(git_config_find_programdata_REQUIRED_ARGC, git_config_find_programdata_OPTIONAL_ARGC));
#endif
#if BIND_git_config_find_system_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_find_system", mrb_Git_git_config_find_system, MRB_ARGS_ARG(git_config_find_system_REQUIRED_ARGC, git_config_find_system_OPTIONAL_ARGC));
#endif
#if BIND_git_config_find_xdg_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_find_xdg", mrb_Git_git_config_find_xdg, MRB_ARGS_ARG(git_config_find_xdg_REQUIRED_ARGC, git_config_find_xdg_OPTIONAL_ARGC));
#endif
#if BIND_git_config_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_foreach", mrb_Git_git_config_foreach, MRB_ARGS_ARG(git_config_foreach_REQUIRED_ARGC, git_config_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_config_foreach_match_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_foreach_match", mrb_Git_git_config_foreach_match, MRB_ARGS_ARG(git_config_foreach_match_REQUIRED_ARGC, git_config_foreach_match_OPTIONAL_ARGC));
#endif
#if BIND_git_config_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_free", mrb_Git_git_config_free, MRB_ARGS_ARG(git_config_free_REQUIRED_ARGC, git_config_free_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_bool_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_bool", mrb_Git_git_config_get_bool, MRB_ARGS_ARG(git_config_get_bool_REQUIRED_ARGC, git_config_get_bool_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_entry_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_entry", mrb_Git_git_config_get_entry, MRB_ARGS_ARG(git_config_get_entry_REQUIRED_ARGC, git_config_get_entry_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_int32_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_int32", mrb_Git_git_config_get_int32, MRB_ARGS_ARG(git_config_get_int32_REQUIRED_ARGC, git_config_get_int32_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_int64_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_int64", mrb_Git_git_config_get_int64, MRB_ARGS_ARG(git_config_get_int64_REQUIRED_ARGC, git_config_get_int64_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_mapped_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_mapped", mrb_Git_git_config_get_mapped, MRB_ARGS_ARG(git_config_get_mapped_REQUIRED_ARGC, git_config_get_mapped_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_multivar_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_multivar_foreach", mrb_Git_git_config_get_multivar_foreach, MRB_ARGS_ARG(git_config_get_multivar_foreach_REQUIRED_ARGC, git_config_get_multivar_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_path_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_path", mrb_Git_git_config_get_path, MRB_ARGS_ARG(git_config_get_path_REQUIRED_ARGC, git_config_get_path_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_string_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_string", mrb_Git_git_config_get_string, MRB_ARGS_ARG(git_config_get_string_REQUIRED_ARGC, git_config_get_string_OPTIONAL_ARGC));
#endif
#if BIND_git_config_get_string_buf_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_get_string_buf", mrb_Git_git_config_get_string_buf, MRB_ARGS_ARG(git_config_get_string_buf_REQUIRED_ARGC, git_config_get_string_buf_OPTIONAL_ARGC));
#endif
#if BIND_git_config_iterator_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_iterator_free", mrb_Git_git_config_iterator_free, MRB_ARGS_ARG(git_config_iterator_free_REQUIRED_ARGC, git_config_iterator_free_OPTIONAL_ARGC));
#endif
#if BIND_git_config_iterator_glob_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_iterator_glob_new", mrb_Git_git_config_iterator_glob_new, MRB_ARGS_ARG(git_config_iterator_glob_new_REQUIRED_ARGC, git_config_iterator_glob_new_OPTIONAL_ARGC));
#endif
#if BIND_git_config_iterator_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_iterator_new", mrb_Git_git_config_iterator_new, MRB_ARGS_ARG(git_config_iterator_new_REQUIRED_ARGC, git_config_iterator_new_OPTIONAL_ARGC));
#endif
#if BIND_git_config_lock_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_lock", mrb_Git_git_config_lock, MRB_ARGS_ARG(git_config_lock_REQUIRED_ARGC, git_config_lock_OPTIONAL_ARGC));
#endif
#if BIND_git_config_lookup_map_value_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_lookup_map_value", mrb_Git_git_config_lookup_map_value, MRB_ARGS_ARG(git_config_lookup_map_value_REQUIRED_ARGC, git_config_lookup_map_value_OPTIONAL_ARGC));
#endif
#if BIND_git_config_multivar_iterator_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_multivar_iterator_new", mrb_Git_git_config_multivar_iterator_new, MRB_ARGS_ARG(git_config_multivar_iterator_new_REQUIRED_ARGC, git_config_multivar_iterator_new_OPTIONAL_ARGC));
#endif
#if BIND_git_config_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_new", mrb_Git_git_config_new, MRB_ARGS_ARG(git_config_new_REQUIRED_ARGC, git_config_new_OPTIONAL_ARGC));
#endif
#if BIND_git_config_next_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_next", mrb_Git_git_config_next, MRB_ARGS_ARG(git_config_next_REQUIRED_ARGC, git_config_next_OPTIONAL_ARGC));
#endif
#if BIND_git_config_open_default_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_open_default", mrb_Git_git_config_open_default, MRB_ARGS_ARG(git_config_open_default_REQUIRED_ARGC, git_config_open_default_OPTIONAL_ARGC));
#endif
#if BIND_git_config_open_global_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_open_global", mrb_Git_git_config_open_global, MRB_ARGS_ARG(git_config_open_global_REQUIRED_ARGC, git_config_open_global_OPTIONAL_ARGC));
#endif
#if BIND_git_config_open_level_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_open_level", mrb_Git_git_config_open_level, MRB_ARGS_ARG(git_config_open_level_REQUIRED_ARGC, git_config_open_level_OPTIONAL_ARGC));
#endif
#if BIND_git_config_open_ondisk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_open_ondisk", mrb_Git_git_config_open_ondisk, MRB_ARGS_ARG(git_config_open_ondisk_REQUIRED_ARGC, git_config_open_ondisk_OPTIONAL_ARGC));
#endif
#if BIND_git_config_parse_bool_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_parse_bool", mrb_Git_git_config_parse_bool, MRB_ARGS_ARG(git_config_parse_bool_REQUIRED_ARGC, git_config_parse_bool_OPTIONAL_ARGC));
#endif
#if BIND_git_config_parse_int32_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_parse_int32", mrb_Git_git_config_parse_int32, MRB_ARGS_ARG(git_config_parse_int32_REQUIRED_ARGC, git_config_parse_int32_OPTIONAL_ARGC));
#endif
#if BIND_git_config_parse_int64_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_parse_int64", mrb_Git_git_config_parse_int64, MRB_ARGS_ARG(git_config_parse_int64_REQUIRED_ARGC, git_config_parse_int64_OPTIONAL_ARGC));
#endif
#if BIND_git_config_parse_path_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_parse_path", mrb_Git_git_config_parse_path, MRB_ARGS_ARG(git_config_parse_path_REQUIRED_ARGC, git_config_parse_path_OPTIONAL_ARGC));
#endif
#if BIND_git_config_set_bool_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_set_bool", mrb_Git_git_config_set_bool, MRB_ARGS_ARG(git_config_set_bool_REQUIRED_ARGC, git_config_set_bool_OPTIONAL_ARGC));
#endif
#if BIND_git_config_set_int32_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_set_int32", mrb_Git_git_config_set_int32, MRB_ARGS_ARG(git_config_set_int32_REQUIRED_ARGC, git_config_set_int32_OPTIONAL_ARGC));
#endif
#if BIND_git_config_set_int64_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_set_int64", mrb_Git_git_config_set_int64, MRB_ARGS_ARG(git_config_set_int64_REQUIRED_ARGC, git_config_set_int64_OPTIONAL_ARGC));
#endif
#if BIND_git_config_set_multivar_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_set_multivar", mrb_Git_git_config_set_multivar, MRB_ARGS_ARG(git_config_set_multivar_REQUIRED_ARGC, git_config_set_multivar_OPTIONAL_ARGC));
#endif
#if BIND_git_config_set_string_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_set_string", mrb_Git_git_config_set_string, MRB_ARGS_ARG(git_config_set_string_REQUIRED_ARGC, git_config_set_string_OPTIONAL_ARGC));
#endif
#if BIND_git_config_snapshot_FUNCTION
  mrb_define_class_method(mrb, Git_module, "config_snapshot", mrb_Git_git_config_snapshot, MRB_ARGS_ARG(git_config_snapshot_REQUIRED_ARGC, git_config_snapshot_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_default_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_default_new", mrb_Git_git_cred_default_new, MRB_ARGS_ARG(git_cred_default_new_REQUIRED_ARGC, git_cred_default_new_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_free", mrb_Git_git_cred_free, MRB_ARGS_ARG(git_cred_free_REQUIRED_ARGC, git_cred_free_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_has_username_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_has_username", mrb_Git_git_cred_has_username, MRB_ARGS_ARG(git_cred_has_username_REQUIRED_ARGC, git_cred_has_username_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_ssh_custom_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_ssh_custom_new", mrb_Git_git_cred_ssh_custom_new, MRB_ARGS_ARG(git_cred_ssh_custom_new_REQUIRED_ARGC, git_cred_ssh_custom_new_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_ssh_interactive_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_ssh_interactive_new", mrb_Git_git_cred_ssh_interactive_new, MRB_ARGS_ARG(git_cred_ssh_interactive_new_REQUIRED_ARGC, git_cred_ssh_interactive_new_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_ssh_key_from_agent_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_ssh_key_from_agent", mrb_Git_git_cred_ssh_key_from_agent, MRB_ARGS_ARG(git_cred_ssh_key_from_agent_REQUIRED_ARGC, git_cred_ssh_key_from_agent_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_ssh_key_memory_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_ssh_key_memory_new", mrb_Git_git_cred_ssh_key_memory_new, MRB_ARGS_ARG(git_cred_ssh_key_memory_new_REQUIRED_ARGC, git_cred_ssh_key_memory_new_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_ssh_key_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_ssh_key_new", mrb_Git_git_cred_ssh_key_new, MRB_ARGS_ARG(git_cred_ssh_key_new_REQUIRED_ARGC, git_cred_ssh_key_new_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_username_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_username_new", mrb_Git_git_cred_username_new, MRB_ARGS_ARG(git_cred_username_new_REQUIRED_ARGC, git_cred_username_new_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_userpass_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_userpass", mrb_Git_git_cred_userpass, MRB_ARGS_ARG(git_cred_userpass_REQUIRED_ARGC, git_cred_userpass_OPTIONAL_ARGC));
#endif
#if BIND_git_cred_userpass_plaintext_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "cred_userpass_plaintext_new", mrb_Git_git_cred_userpass_plaintext_new, MRB_ARGS_ARG(git_cred_userpass_plaintext_new_REQUIRED_ARGC, git_cred_userpass_plaintext_new_OPTIONAL_ARGC));
#endif
#if BIND_git_describe_commit_FUNCTION
  mrb_define_class_method(mrb, Git_module, "describe_commit", mrb_Git_git_describe_commit, MRB_ARGS_ARG(git_describe_commit_REQUIRED_ARGC, git_describe_commit_OPTIONAL_ARGC));
#endif
#if BIND_git_describe_format_FUNCTION
  mrb_define_class_method(mrb, Git_module, "describe_format", mrb_Git_git_describe_format, MRB_ARGS_ARG(git_describe_format_REQUIRED_ARGC, git_describe_format_OPTIONAL_ARGC));
#endif
#if BIND_git_describe_init_format_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "describe_init_format_options", mrb_Git_git_describe_init_format_options, MRB_ARGS_ARG(git_describe_init_format_options_REQUIRED_ARGC, git_describe_init_format_options_OPTIONAL_ARGC));
#endif
#if BIND_git_describe_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "describe_init_options", mrb_Git_git_describe_init_options, MRB_ARGS_ARG(git_describe_init_options_REQUIRED_ARGC, git_describe_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_describe_result_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "describe_result_free", mrb_Git_git_describe_result_free, MRB_ARGS_ARG(git_describe_result_free_REQUIRED_ARGC, git_describe_result_free_OPTIONAL_ARGC));
#endif
#if BIND_git_describe_workdir_FUNCTION
  mrb_define_class_method(mrb, Git_module, "describe_workdir", mrb_Git_git_describe_workdir, MRB_ARGS_ARG(git_describe_workdir_REQUIRED_ARGC, git_describe_workdir_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_blob_to_buffer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_blob_to_buffer", mrb_Git_git_diff_blob_to_buffer, MRB_ARGS_ARG(git_diff_blob_to_buffer_REQUIRED_ARGC, git_diff_blob_to_buffer_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_blobs_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_blobs", mrb_Git_git_diff_blobs, MRB_ARGS_ARG(git_diff_blobs_REQUIRED_ARGC, git_diff_blobs_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_buffers_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_buffers", mrb_Git_git_diff_buffers, MRB_ARGS_ARG(git_diff_buffers_REQUIRED_ARGC, git_diff_buffers_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_commit_as_email_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_commit_as_email", mrb_Git_git_diff_commit_as_email, MRB_ARGS_ARG(git_diff_commit_as_email_REQUIRED_ARGC, git_diff_commit_as_email_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_find_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_find_init_options", mrb_Git_git_diff_find_init_options, MRB_ARGS_ARG(git_diff_find_init_options_REQUIRED_ARGC, git_diff_find_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_find_similar_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_find_similar", mrb_Git_git_diff_find_similar, MRB_ARGS_ARG(git_diff_find_similar_REQUIRED_ARGC, git_diff_find_similar_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_foreach", mrb_Git_git_diff_foreach, MRB_ARGS_ARG(git_diff_foreach_REQUIRED_ARGC, git_diff_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_format_email_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_format_email", mrb_Git_git_diff_format_email, MRB_ARGS_ARG(git_diff_format_email_REQUIRED_ARGC, git_diff_format_email_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_format_email_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_format_email_init_options", mrb_Git_git_diff_format_email_init_options, MRB_ARGS_ARG(git_diff_format_email_init_options_REQUIRED_ARGC, git_diff_format_email_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_free", mrb_Git_git_diff_free, MRB_ARGS_ARG(git_diff_free_REQUIRED_ARGC, git_diff_free_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_get_delta_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_get_delta", mrb_Git_git_diff_get_delta, MRB_ARGS_ARG(git_diff_get_delta_REQUIRED_ARGC, git_diff_get_delta_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_get_stats_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_get_stats", mrb_Git_git_diff_get_stats, MRB_ARGS_ARG(git_diff_get_stats_REQUIRED_ARGC, git_diff_get_stats_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_index_to_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_index_to_index", mrb_Git_git_diff_index_to_index, MRB_ARGS_ARG(git_diff_index_to_index_REQUIRED_ARGC, git_diff_index_to_index_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_index_to_workdir_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_index_to_workdir", mrb_Git_git_diff_index_to_workdir, MRB_ARGS_ARG(git_diff_index_to_workdir_REQUIRED_ARGC, git_diff_index_to_workdir_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_init_options", mrb_Git_git_diff_init_options, MRB_ARGS_ARG(git_diff_init_options_REQUIRED_ARGC, git_diff_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_is_sorted_icase_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_is_sorted_icase", mrb_Git_git_diff_is_sorted_icase, MRB_ARGS_ARG(git_diff_is_sorted_icase_REQUIRED_ARGC, git_diff_is_sorted_icase_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_merge_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_merge", mrb_Git_git_diff_merge, MRB_ARGS_ARG(git_diff_merge_REQUIRED_ARGC, git_diff_merge_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_num_deltas_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_num_deltas", mrb_Git_git_diff_num_deltas, MRB_ARGS_ARG(git_diff_num_deltas_REQUIRED_ARGC, git_diff_num_deltas_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_num_deltas_of_type_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_num_deltas_of_type", mrb_Git_git_diff_num_deltas_of_type, MRB_ARGS_ARG(git_diff_num_deltas_of_type_REQUIRED_ARGC, git_diff_num_deltas_of_type_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_print_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_print", mrb_Git_git_diff_print, MRB_ARGS_ARG(git_diff_print_REQUIRED_ARGC, git_diff_print_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_stats_deletions_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_stats_deletions", mrb_Git_git_diff_stats_deletions, MRB_ARGS_ARG(git_diff_stats_deletions_REQUIRED_ARGC, git_diff_stats_deletions_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_stats_files_changed_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_stats_files_changed", mrb_Git_git_diff_stats_files_changed, MRB_ARGS_ARG(git_diff_stats_files_changed_REQUIRED_ARGC, git_diff_stats_files_changed_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_stats_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_stats_free", mrb_Git_git_diff_stats_free, MRB_ARGS_ARG(git_diff_stats_free_REQUIRED_ARGC, git_diff_stats_free_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_stats_insertions_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_stats_insertions", mrb_Git_git_diff_stats_insertions, MRB_ARGS_ARG(git_diff_stats_insertions_REQUIRED_ARGC, git_diff_stats_insertions_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_stats_to_buf_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_stats_to_buf", mrb_Git_git_diff_stats_to_buf, MRB_ARGS_ARG(git_diff_stats_to_buf_REQUIRED_ARGC, git_diff_stats_to_buf_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_status_char_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_status_char", mrb_Git_git_diff_status_char, MRB_ARGS_ARG(git_diff_status_char_REQUIRED_ARGC, git_diff_status_char_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_tree_to_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_tree_to_index", mrb_Git_git_diff_tree_to_index, MRB_ARGS_ARG(git_diff_tree_to_index_REQUIRED_ARGC, git_diff_tree_to_index_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_tree_to_tree_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_tree_to_tree", mrb_Git_git_diff_tree_to_tree, MRB_ARGS_ARG(git_diff_tree_to_tree_REQUIRED_ARGC, git_diff_tree_to_tree_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_tree_to_workdir_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_tree_to_workdir", mrb_Git_git_diff_tree_to_workdir, MRB_ARGS_ARG(git_diff_tree_to_workdir_REQUIRED_ARGC, git_diff_tree_to_workdir_OPTIONAL_ARGC));
#endif
#if BIND_git_diff_tree_to_workdir_with_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "diff_tree_to_workdir_with_index", mrb_Git_git_diff_tree_to_workdir_with_index, MRB_ARGS_ARG(git_diff_tree_to_workdir_with_index_REQUIRED_ARGC, git_diff_tree_to_workdir_with_index_OPTIONAL_ARGC));
#endif
#if BIND_git_fetch_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "fetch_init_options", mrb_Git_git_fetch_init_options, MRB_ARGS_ARG(git_fetch_init_options_REQUIRED_ARGC, git_fetch_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_apply_to_blob_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_apply_to_blob", mrb_Git_git_filter_list_apply_to_blob, MRB_ARGS_ARG(git_filter_list_apply_to_blob_REQUIRED_ARGC, git_filter_list_apply_to_blob_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_apply_to_data_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_apply_to_data", mrb_Git_git_filter_list_apply_to_data, MRB_ARGS_ARG(git_filter_list_apply_to_data_REQUIRED_ARGC, git_filter_list_apply_to_data_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_apply_to_file_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_apply_to_file", mrb_Git_git_filter_list_apply_to_file, MRB_ARGS_ARG(git_filter_list_apply_to_file_REQUIRED_ARGC, git_filter_list_apply_to_file_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_contains_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_contains", mrb_Git_git_filter_list_contains, MRB_ARGS_ARG(git_filter_list_contains_REQUIRED_ARGC, git_filter_list_contains_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_free", mrb_Git_git_filter_list_free, MRB_ARGS_ARG(git_filter_list_free_REQUIRED_ARGC, git_filter_list_free_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_load_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_load", mrb_Git_git_filter_list_load, MRB_ARGS_ARG(git_filter_list_load_REQUIRED_ARGC, git_filter_list_load_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_stream_blob_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_stream_blob", mrb_Git_git_filter_list_stream_blob, MRB_ARGS_ARG(git_filter_list_stream_blob_REQUIRED_ARGC, git_filter_list_stream_blob_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_stream_data_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_stream_data", mrb_Git_git_filter_list_stream_data, MRB_ARGS_ARG(git_filter_list_stream_data_REQUIRED_ARGC, git_filter_list_stream_data_OPTIONAL_ARGC));
#endif
#if BIND_git_filter_list_stream_file_FUNCTION
  mrb_define_class_method(mrb, Git_module, "filter_list_stream_file", mrb_Git_git_filter_list_stream_file, MRB_ARGS_ARG(git_filter_list_stream_file_REQUIRED_ARGC, git_filter_list_stream_file_OPTIONAL_ARGC));
#endif
#if BIND_git_graph_ahead_behind_FUNCTION
  mrb_define_class_method(mrb, Git_module, "graph_ahead_behind", mrb_Git_git_graph_ahead_behind, MRB_ARGS_ARG(git_graph_ahead_behind_REQUIRED_ARGC, git_graph_ahead_behind_OPTIONAL_ARGC));
#endif
#if BIND_git_graph_descendant_of_FUNCTION
  mrb_define_class_method(mrb, Git_module, "graph_descendant_of", mrb_Git_git_graph_descendant_of, MRB_ARGS_ARG(git_graph_descendant_of_REQUIRED_ARGC, git_graph_descendant_of_OPTIONAL_ARGC));
#endif
#if BIND_git_ignore_add_rule_FUNCTION
  mrb_define_class_method(mrb, Git_module, "ignore_add_rule", mrb_Git_git_ignore_add_rule, MRB_ARGS_ARG(git_ignore_add_rule_REQUIRED_ARGC, git_ignore_add_rule_OPTIONAL_ARGC));
#endif
#if BIND_git_ignore_clear_internal_rules_FUNCTION
  mrb_define_class_method(mrb, Git_module, "ignore_clear_internal_rules", mrb_Git_git_ignore_clear_internal_rules, MRB_ARGS_ARG(git_ignore_clear_internal_rules_REQUIRED_ARGC, git_ignore_clear_internal_rules_OPTIONAL_ARGC));
#endif
#if BIND_git_ignore_path_is_ignored_FUNCTION
  mrb_define_class_method(mrb, Git_module, "ignore_path_is_ignored", mrb_Git_git_ignore_path_is_ignored, MRB_ARGS_ARG(git_ignore_path_is_ignored_REQUIRED_ARGC, git_ignore_path_is_ignored_OPTIONAL_ARGC));
#endif
#if BIND_git_index_add_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_add", mrb_Git_git_index_add, MRB_ARGS_ARG(git_index_add_REQUIRED_ARGC, git_index_add_OPTIONAL_ARGC));
#endif
#if BIND_git_index_add_all_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_add_all", mrb_Git_git_index_add_all, MRB_ARGS_ARG(git_index_add_all_REQUIRED_ARGC, git_index_add_all_OPTIONAL_ARGC));
#endif
#if BIND_git_index_add_bypath_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_add_bypath", mrb_Git_git_index_add_bypath, MRB_ARGS_ARG(git_index_add_bypath_REQUIRED_ARGC, git_index_add_bypath_OPTIONAL_ARGC));
#endif
#if BIND_git_index_add_frombuffer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_add_frombuffer", mrb_Git_git_index_add_frombuffer, MRB_ARGS_ARG(git_index_add_frombuffer_REQUIRED_ARGC, git_index_add_frombuffer_OPTIONAL_ARGC));
#endif
#if BIND_git_index_caps_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_caps", mrb_Git_git_index_caps, MRB_ARGS_ARG(git_index_caps_REQUIRED_ARGC, git_index_caps_OPTIONAL_ARGC));
#endif
#if BIND_git_index_checksum_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_checksum", mrb_Git_git_index_checksum, MRB_ARGS_ARG(git_index_checksum_REQUIRED_ARGC, git_index_checksum_OPTIONAL_ARGC));
#endif
#if BIND_git_index_clear_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_clear", mrb_Git_git_index_clear, MRB_ARGS_ARG(git_index_clear_REQUIRED_ARGC, git_index_clear_OPTIONAL_ARGC));
#endif
#if BIND_git_index_conflict_add_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_conflict_add", mrb_Git_git_index_conflict_add, MRB_ARGS_ARG(git_index_conflict_add_REQUIRED_ARGC, git_index_conflict_add_OPTIONAL_ARGC));
#endif
#if BIND_git_index_conflict_cleanup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_conflict_cleanup", mrb_Git_git_index_conflict_cleanup, MRB_ARGS_ARG(git_index_conflict_cleanup_REQUIRED_ARGC, git_index_conflict_cleanup_OPTIONAL_ARGC));
#endif
#if BIND_git_index_conflict_get_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_conflict_get", mrb_Git_git_index_conflict_get, MRB_ARGS_ARG(git_index_conflict_get_REQUIRED_ARGC, git_index_conflict_get_OPTIONAL_ARGC));
#endif
#if BIND_git_index_conflict_iterator_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_conflict_iterator_free", mrb_Git_git_index_conflict_iterator_free, MRB_ARGS_ARG(git_index_conflict_iterator_free_REQUIRED_ARGC, git_index_conflict_iterator_free_OPTIONAL_ARGC));
#endif
#if BIND_git_index_conflict_iterator_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_conflict_iterator_new", mrb_Git_git_index_conflict_iterator_new, MRB_ARGS_ARG(git_index_conflict_iterator_new_REQUIRED_ARGC, git_index_conflict_iterator_new_OPTIONAL_ARGC));
#endif
#if BIND_git_index_conflict_next_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_conflict_next", mrb_Git_git_index_conflict_next, MRB_ARGS_ARG(git_index_conflict_next_REQUIRED_ARGC, git_index_conflict_next_OPTIONAL_ARGC));
#endif
#if BIND_git_index_conflict_remove_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_conflict_remove", mrb_Git_git_index_conflict_remove, MRB_ARGS_ARG(git_index_conflict_remove_REQUIRED_ARGC, git_index_conflict_remove_OPTIONAL_ARGC));
#endif
#if BIND_git_index_entry_is_conflict_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_entry_is_conflict", mrb_Git_git_index_entry_is_conflict, MRB_ARGS_ARG(git_index_entry_is_conflict_REQUIRED_ARGC, git_index_entry_is_conflict_OPTIONAL_ARGC));
#endif
#if BIND_git_index_entry_stage_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_entry_stage", mrb_Git_git_index_entry_stage, MRB_ARGS_ARG(git_index_entry_stage_REQUIRED_ARGC, git_index_entry_stage_OPTIONAL_ARGC));
#endif
#if BIND_git_index_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_entrycount", mrb_Git_git_index_entrycount, MRB_ARGS_ARG(git_index_entrycount_REQUIRED_ARGC, git_index_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_index_find_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_find", mrb_Git_git_index_find, MRB_ARGS_ARG(git_index_find_REQUIRED_ARGC, git_index_find_OPTIONAL_ARGC));
#endif
#if BIND_git_index_find_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_find_prefix", mrb_Git_git_index_find_prefix, MRB_ARGS_ARG(git_index_find_prefix_REQUIRED_ARGC, git_index_find_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_index_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_free", mrb_Git_git_index_free, MRB_ARGS_ARG(git_index_free_REQUIRED_ARGC, git_index_free_OPTIONAL_ARGC));
#endif
#if BIND_git_index_get_byindex_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_get_byindex", mrb_Git_git_index_get_byindex, MRB_ARGS_ARG(git_index_get_byindex_REQUIRED_ARGC, git_index_get_byindex_OPTIONAL_ARGC));
#endif
#if BIND_git_index_get_bypath_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_get_bypath", mrb_Git_git_index_get_bypath, MRB_ARGS_ARG(git_index_get_bypath_REQUIRED_ARGC, git_index_get_bypath_OPTIONAL_ARGC));
#endif
#if BIND_git_index_has_conflicts_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_has_conflicts", mrb_Git_git_index_has_conflicts, MRB_ARGS_ARG(git_index_has_conflicts_REQUIRED_ARGC, git_index_has_conflicts_OPTIONAL_ARGC));
#endif
#if BIND_git_index_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_new", mrb_Git_git_index_new, MRB_ARGS_ARG(git_index_new_REQUIRED_ARGC, git_index_new_OPTIONAL_ARGC));
#endif
#if BIND_git_index_open_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_open", mrb_Git_git_index_open, MRB_ARGS_ARG(git_index_open_REQUIRED_ARGC, git_index_open_OPTIONAL_ARGC));
#endif
#if BIND_git_index_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_owner", mrb_Git_git_index_owner, MRB_ARGS_ARG(git_index_owner_REQUIRED_ARGC, git_index_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_index_path_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_path", mrb_Git_git_index_path, MRB_ARGS_ARG(git_index_path_REQUIRED_ARGC, git_index_path_OPTIONAL_ARGC));
#endif
#if BIND_git_index_read_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_read", mrb_Git_git_index_read, MRB_ARGS_ARG(git_index_read_REQUIRED_ARGC, git_index_read_OPTIONAL_ARGC));
#endif
#if BIND_git_index_read_tree_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_read_tree", mrb_Git_git_index_read_tree, MRB_ARGS_ARG(git_index_read_tree_REQUIRED_ARGC, git_index_read_tree_OPTIONAL_ARGC));
#endif
#if BIND_git_index_remove_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_remove", mrb_Git_git_index_remove, MRB_ARGS_ARG(git_index_remove_REQUIRED_ARGC, git_index_remove_OPTIONAL_ARGC));
#endif
#if BIND_git_index_remove_all_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_remove_all", mrb_Git_git_index_remove_all, MRB_ARGS_ARG(git_index_remove_all_REQUIRED_ARGC, git_index_remove_all_OPTIONAL_ARGC));
#endif
#if BIND_git_index_remove_bypath_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_remove_bypath", mrb_Git_git_index_remove_bypath, MRB_ARGS_ARG(git_index_remove_bypath_REQUIRED_ARGC, git_index_remove_bypath_OPTIONAL_ARGC));
#endif
#if BIND_git_index_remove_directory_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_remove_directory", mrb_Git_git_index_remove_directory, MRB_ARGS_ARG(git_index_remove_directory_REQUIRED_ARGC, git_index_remove_directory_OPTIONAL_ARGC));
#endif
#if BIND_git_index_set_caps_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_set_caps", mrb_Git_git_index_set_caps, MRB_ARGS_ARG(git_index_set_caps_REQUIRED_ARGC, git_index_set_caps_OPTIONAL_ARGC));
#endif
#if BIND_git_index_update_all_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_update_all", mrb_Git_git_index_update_all, MRB_ARGS_ARG(git_index_update_all_REQUIRED_ARGC, git_index_update_all_OPTIONAL_ARGC));
#endif
#if BIND_git_index_write_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_write", mrb_Git_git_index_write, MRB_ARGS_ARG(git_index_write_REQUIRED_ARGC, git_index_write_OPTIONAL_ARGC));
#endif
#if BIND_git_index_write_tree_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_write_tree", mrb_Git_git_index_write_tree, MRB_ARGS_ARG(git_index_write_tree_REQUIRED_ARGC, git_index_write_tree_OPTIONAL_ARGC));
#endif
#if BIND_git_index_write_tree_to_FUNCTION
  mrb_define_class_method(mrb, Git_module, "index_write_tree_to", mrb_Git_git_index_write_tree_to, MRB_ARGS_ARG(git_index_write_tree_to_REQUIRED_ARGC, git_index_write_tree_to_OPTIONAL_ARGC));
#endif
#if BIND_git_indexer_append_FUNCTION
  mrb_define_class_method(mrb, Git_module, "indexer_append", mrb_Git_git_indexer_append, MRB_ARGS_ARG(git_indexer_append_REQUIRED_ARGC, git_indexer_append_OPTIONAL_ARGC));
#endif
#if BIND_git_indexer_commit_FUNCTION
  mrb_define_class_method(mrb, Git_module, "indexer_commit", mrb_Git_git_indexer_commit, MRB_ARGS_ARG(git_indexer_commit_REQUIRED_ARGC, git_indexer_commit_OPTIONAL_ARGC));
#endif
#if BIND_git_indexer_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "indexer_free", mrb_Git_git_indexer_free, MRB_ARGS_ARG(git_indexer_free_REQUIRED_ARGC, git_indexer_free_OPTIONAL_ARGC));
#endif
#if BIND_git_indexer_hash_FUNCTION
  mrb_define_class_method(mrb, Git_module, "indexer_hash", mrb_Git_git_indexer_hash, MRB_ARGS_ARG(git_indexer_hash_REQUIRED_ARGC, git_indexer_hash_OPTIONAL_ARGC));
#endif
#if BIND_git_indexer_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "indexer_new", mrb_Git_git_indexer_new, MRB_ARGS_ARG(git_indexer_new_REQUIRED_ARGC, git_indexer_new_OPTIONAL_ARGC));
#endif
#if BIND_git_libgit2_features_FUNCTION
  mrb_define_class_method(mrb, Git_module, "libgit2_features", mrb_Git_git_libgit2_features, MRB_ARGS_ARG(git_libgit2_features_REQUIRED_ARGC, git_libgit2_features_OPTIONAL_ARGC));
#endif
#if BIND_git_libgit2_init_FUNCTION
  mrb_define_class_method(mrb, Git_module, "libgit2_init", mrb_Git_git_libgit2_init, MRB_ARGS_ARG(git_libgit2_init_REQUIRED_ARGC, git_libgit2_init_OPTIONAL_ARGC));
#endif
#if BIND_git_libgit2_opts_FUNCTION
  mrb_define_class_method(mrb, Git_module, "libgit2_opts", mrb_Git_git_libgit2_opts, MRB_ARGS_ARG(git_libgit2_opts_REQUIRED_ARGC, git_libgit2_opts_OPTIONAL_ARGC));
#endif
#if BIND_git_libgit2_shutdown_FUNCTION
  mrb_define_class_method(mrb, Git_module, "libgit2_shutdown", mrb_Git_git_libgit2_shutdown, MRB_ARGS_ARG(git_libgit2_shutdown_REQUIRED_ARGC, git_libgit2_shutdown_OPTIONAL_ARGC));
#endif
#if BIND_git_libgit2_version_FUNCTION
  mrb_define_class_method(mrb, Git_module, "libgit2_version", mrb_Git_git_libgit2_version, MRB_ARGS_ARG(git_libgit2_version_REQUIRED_ARGC, git_libgit2_version_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge", mrb_Git_git_merge, MRB_ARGS_ARG(git_merge_REQUIRED_ARGC, git_merge_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_analysis_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_analysis", mrb_Git_git_merge_analysis, MRB_ARGS_ARG(git_merge_analysis_REQUIRED_ARGC, git_merge_analysis_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_base_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_base", mrb_Git_git_merge_base, MRB_ARGS_ARG(git_merge_base_REQUIRED_ARGC, git_merge_base_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_base_many_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_base_many", mrb_Git_git_merge_base_many, MRB_ARGS_ARG(git_merge_base_many_REQUIRED_ARGC, git_merge_base_many_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_base_octopus_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_base_octopus", mrb_Git_git_merge_base_octopus, MRB_ARGS_ARG(git_merge_base_octopus_REQUIRED_ARGC, git_merge_base_octopus_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_bases_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_bases", mrb_Git_git_merge_bases, MRB_ARGS_ARG(git_merge_bases_REQUIRED_ARGC, git_merge_bases_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_bases_many_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_bases_many", mrb_Git_git_merge_bases_many, MRB_ARGS_ARG(git_merge_bases_many_REQUIRED_ARGC, git_merge_bases_many_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_commits_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_commits", mrb_Git_git_merge_commits, MRB_ARGS_ARG(git_merge_commits_REQUIRED_ARGC, git_merge_commits_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_file_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_file", mrb_Git_git_merge_file, MRB_ARGS_ARG(git_merge_file_REQUIRED_ARGC, git_merge_file_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_file_from_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_file_from_index", mrb_Git_git_merge_file_from_index, MRB_ARGS_ARG(git_merge_file_from_index_REQUIRED_ARGC, git_merge_file_from_index_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_file_init_input_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_file_init_input", mrb_Git_git_merge_file_init_input, MRB_ARGS_ARG(git_merge_file_init_input_REQUIRED_ARGC, git_merge_file_init_input_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_file_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_file_init_options", mrb_Git_git_merge_file_init_options, MRB_ARGS_ARG(git_merge_file_init_options_REQUIRED_ARGC, git_merge_file_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_file_result_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_file_result_free", mrb_Git_git_merge_file_result_free, MRB_ARGS_ARG(git_merge_file_result_free_REQUIRED_ARGC, git_merge_file_result_free_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_init_options", mrb_Git_git_merge_init_options, MRB_ARGS_ARG(git_merge_init_options_REQUIRED_ARGC, git_merge_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_merge_trees_FUNCTION
  mrb_define_class_method(mrb, Git_module, "merge_trees", mrb_Git_git_merge_trees, MRB_ARGS_ARG(git_merge_trees_REQUIRED_ARGC, git_merge_trees_OPTIONAL_ARGC));
#endif
#if BIND_git_message_prettify_FUNCTION
  mrb_define_class_method(mrb, Git_module, "message_prettify", mrb_Git_git_message_prettify, MRB_ARGS_ARG(git_message_prettify_REQUIRED_ARGC, git_message_prettify_OPTIONAL_ARGC));
#endif
#if BIND_git_note_author_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_author", mrb_Git_git_note_author, MRB_ARGS_ARG(git_note_author_REQUIRED_ARGC, git_note_author_OPTIONAL_ARGC));
#endif
#if BIND_git_note_committer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_committer", mrb_Git_git_note_committer, MRB_ARGS_ARG(git_note_committer_REQUIRED_ARGC, git_note_committer_OPTIONAL_ARGC));
#endif
#if BIND_git_note_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_create", mrb_Git_git_note_create, MRB_ARGS_ARG(git_note_create_REQUIRED_ARGC, git_note_create_OPTIONAL_ARGC));
#endif
#if BIND_git_note_default_ref_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_default_ref", mrb_Git_git_note_default_ref, MRB_ARGS_ARG(git_note_default_ref_REQUIRED_ARGC, git_note_default_ref_OPTIONAL_ARGC));
#endif
#if BIND_git_note_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_foreach", mrb_Git_git_note_foreach, MRB_ARGS_ARG(git_note_foreach_REQUIRED_ARGC, git_note_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_note_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_free", mrb_Git_git_note_free, MRB_ARGS_ARG(git_note_free_REQUIRED_ARGC, git_note_free_OPTIONAL_ARGC));
#endif
#if BIND_git_note_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_id", mrb_Git_git_note_id, MRB_ARGS_ARG(git_note_id_REQUIRED_ARGC, git_note_id_OPTIONAL_ARGC));
#endif
#if BIND_git_note_iterator_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_iterator_free", mrb_Git_git_note_iterator_free, MRB_ARGS_ARG(git_note_iterator_free_REQUIRED_ARGC, git_note_iterator_free_OPTIONAL_ARGC));
#endif
#if BIND_git_note_iterator_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_iterator_new", mrb_Git_git_note_iterator_new, MRB_ARGS_ARG(git_note_iterator_new_REQUIRED_ARGC, git_note_iterator_new_OPTIONAL_ARGC));
#endif
#if BIND_git_note_message_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_message", mrb_Git_git_note_message, MRB_ARGS_ARG(git_note_message_REQUIRED_ARGC, git_note_message_OPTIONAL_ARGC));
#endif
#if BIND_git_note_next_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_next", mrb_Git_git_note_next, MRB_ARGS_ARG(git_note_next_REQUIRED_ARGC, git_note_next_OPTIONAL_ARGC));
#endif
#if BIND_git_note_read_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_read", mrb_Git_git_note_read, MRB_ARGS_ARG(git_note_read_REQUIRED_ARGC, git_note_read_OPTIONAL_ARGC));
#endif
#if BIND_git_note_remove_FUNCTION
  mrb_define_class_method(mrb, Git_module, "note_remove", mrb_Git_git_note_remove, MRB_ARGS_ARG(git_note_remove_REQUIRED_ARGC, git_note_remove_OPTIONAL_ARGC));
#endif
#if BIND_git_object__size_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object__size", mrb_Git_git_object__size, MRB_ARGS_ARG(git_object__size_REQUIRED_ARGC, git_object__size_OPTIONAL_ARGC));
#endif
#if BIND_git_object_dup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_dup", mrb_Git_git_object_dup, MRB_ARGS_ARG(git_object_dup_REQUIRED_ARGC, git_object_dup_OPTIONAL_ARGC));
#endif
#if BIND_git_object_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_free", mrb_Git_git_object_free, MRB_ARGS_ARG(git_object_free_REQUIRED_ARGC, git_object_free_OPTIONAL_ARGC));
#endif
#if BIND_git_object_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_id", mrb_Git_git_object_id, MRB_ARGS_ARG(git_object_id_REQUIRED_ARGC, git_object_id_OPTIONAL_ARGC));
#endif
#if BIND_git_object_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_lookup", mrb_Git_git_object_lookup, MRB_ARGS_ARG(git_object_lookup_REQUIRED_ARGC, git_object_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_object_lookup_bypath_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_lookup_bypath", mrb_Git_git_object_lookup_bypath, MRB_ARGS_ARG(git_object_lookup_bypath_REQUIRED_ARGC, git_object_lookup_bypath_OPTIONAL_ARGC));
#endif
#if BIND_git_object_lookup_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_lookup_prefix", mrb_Git_git_object_lookup_prefix, MRB_ARGS_ARG(git_object_lookup_prefix_REQUIRED_ARGC, git_object_lookup_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_object_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_owner", mrb_Git_git_object_owner, MRB_ARGS_ARG(git_object_owner_REQUIRED_ARGC, git_object_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_object_peel_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_peel", mrb_Git_git_object_peel, MRB_ARGS_ARG(git_object_peel_REQUIRED_ARGC, git_object_peel_OPTIONAL_ARGC));
#endif
#if BIND_git_object_short_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_short_id", mrb_Git_git_object_short_id, MRB_ARGS_ARG(git_object_short_id_REQUIRED_ARGC, git_object_short_id_OPTIONAL_ARGC));
#endif
#if BIND_git_object_string2type_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_string2type", mrb_Git_git_object_string2type, MRB_ARGS_ARG(git_object_string2type_REQUIRED_ARGC, git_object_string2type_OPTIONAL_ARGC));
#endif
#if BIND_git_object_type_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_type", mrb_Git_git_object_type, MRB_ARGS_ARG(git_object_type_REQUIRED_ARGC, git_object_type_OPTIONAL_ARGC));
#endif
#if BIND_git_object_type2string_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_type2string", mrb_Git_git_object_type2string, MRB_ARGS_ARG(git_object_type2string_REQUIRED_ARGC, git_object_type2string_OPTIONAL_ARGC));
#endif
#if BIND_git_object_typeisloose_FUNCTION
  mrb_define_class_method(mrb, Git_module, "object_typeisloose", mrb_Git_git_object_typeisloose, MRB_ARGS_ARG(git_object_typeisloose_REQUIRED_ARGC, git_object_typeisloose_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_add_alternate_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_add_alternate", mrb_Git_git_odb_add_alternate, MRB_ARGS_ARG(git_odb_add_alternate_REQUIRED_ARGC, git_odb_add_alternate_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_add_backend_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_add_backend", mrb_Git_git_odb_add_backend, MRB_ARGS_ARG(git_odb_add_backend_REQUIRED_ARGC, git_odb_add_backend_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_add_disk_alternate_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_add_disk_alternate", mrb_Git_git_odb_add_disk_alternate, MRB_ARGS_ARG(git_odb_add_disk_alternate_REQUIRED_ARGC, git_odb_add_disk_alternate_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_backend_loose_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_backend_loose", mrb_Git_git_odb_backend_loose, MRB_ARGS_ARG(git_odb_backend_loose_REQUIRED_ARGC, git_odb_backend_loose_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_backend_one_pack_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_backend_one_pack", mrb_Git_git_odb_backend_one_pack, MRB_ARGS_ARG(git_odb_backend_one_pack_REQUIRED_ARGC, git_odb_backend_one_pack_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_backend_pack_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_backend_pack", mrb_Git_git_odb_backend_pack, MRB_ARGS_ARG(git_odb_backend_pack_REQUIRED_ARGC, git_odb_backend_pack_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_exists_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_exists", mrb_Git_git_odb_exists, MRB_ARGS_ARG(git_odb_exists_REQUIRED_ARGC, git_odb_exists_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_exists_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_exists_prefix", mrb_Git_git_odb_exists_prefix, MRB_ARGS_ARG(git_odb_exists_prefix_REQUIRED_ARGC, git_odb_exists_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_foreach", mrb_Git_git_odb_foreach, MRB_ARGS_ARG(git_odb_foreach_REQUIRED_ARGC, git_odb_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_free", mrb_Git_git_odb_free, MRB_ARGS_ARG(git_odb_free_REQUIRED_ARGC, git_odb_free_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_get_backend_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_get_backend", mrb_Git_git_odb_get_backend, MRB_ARGS_ARG(git_odb_get_backend_REQUIRED_ARGC, git_odb_get_backend_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_hash_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_hash", mrb_Git_git_odb_hash, MRB_ARGS_ARG(git_odb_hash_REQUIRED_ARGC, git_odb_hash_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_hashfile_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_hashfile", mrb_Git_git_odb_hashfile, MRB_ARGS_ARG(git_odb_hashfile_REQUIRED_ARGC, git_odb_hashfile_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_new", mrb_Git_git_odb_new, MRB_ARGS_ARG(git_odb_new_REQUIRED_ARGC, git_odb_new_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_num_backends_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_num_backends", mrb_Git_git_odb_num_backends, MRB_ARGS_ARG(git_odb_num_backends_REQUIRED_ARGC, git_odb_num_backends_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_object_data_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_object_data", mrb_Git_git_odb_object_data, MRB_ARGS_ARG(git_odb_object_data_REQUIRED_ARGC, git_odb_object_data_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_object_dup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_object_dup", mrb_Git_git_odb_object_dup, MRB_ARGS_ARG(git_odb_object_dup_REQUIRED_ARGC, git_odb_object_dup_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_object_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_object_free", mrb_Git_git_odb_object_free, MRB_ARGS_ARG(git_odb_object_free_REQUIRED_ARGC, git_odb_object_free_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_object_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_object_id", mrb_Git_git_odb_object_id, MRB_ARGS_ARG(git_odb_object_id_REQUIRED_ARGC, git_odb_object_id_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_object_size_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_object_size", mrb_Git_git_odb_object_size, MRB_ARGS_ARG(git_odb_object_size_REQUIRED_ARGC, git_odb_object_size_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_object_type_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_object_type", mrb_Git_git_odb_object_type, MRB_ARGS_ARG(git_odb_object_type_REQUIRED_ARGC, git_odb_object_type_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_open_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_open", mrb_Git_git_odb_open, MRB_ARGS_ARG(git_odb_open_REQUIRED_ARGC, git_odb_open_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_open_rstream_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_open_rstream", mrb_Git_git_odb_open_rstream, MRB_ARGS_ARG(git_odb_open_rstream_REQUIRED_ARGC, git_odb_open_rstream_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_open_wstream_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_open_wstream", mrb_Git_git_odb_open_wstream, MRB_ARGS_ARG(git_odb_open_wstream_REQUIRED_ARGC, git_odb_open_wstream_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_read_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_read", mrb_Git_git_odb_read, MRB_ARGS_ARG(git_odb_read_REQUIRED_ARGC, git_odb_read_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_read_header_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_read_header", mrb_Git_git_odb_read_header, MRB_ARGS_ARG(git_odb_read_header_REQUIRED_ARGC, git_odb_read_header_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_read_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_read_prefix", mrb_Git_git_odb_read_prefix, MRB_ARGS_ARG(git_odb_read_prefix_REQUIRED_ARGC, git_odb_read_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_refresh_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_refresh", mrb_Git_git_odb_refresh, MRB_ARGS_ARG(git_odb_refresh_REQUIRED_ARGC, git_odb_refresh_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_stream_finalize_write_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_stream_finalize_write", mrb_Git_git_odb_stream_finalize_write, MRB_ARGS_ARG(git_odb_stream_finalize_write_REQUIRED_ARGC, git_odb_stream_finalize_write_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_stream_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_stream_free", mrb_Git_git_odb_stream_free, MRB_ARGS_ARG(git_odb_stream_free_REQUIRED_ARGC, git_odb_stream_free_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_stream_read_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_stream_read", mrb_Git_git_odb_stream_read, MRB_ARGS_ARG(git_odb_stream_read_REQUIRED_ARGC, git_odb_stream_read_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_stream_write_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_stream_write", mrb_Git_git_odb_stream_write, MRB_ARGS_ARG(git_odb_stream_write_REQUIRED_ARGC, git_odb_stream_write_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_write_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_write", mrb_Git_git_odb_write, MRB_ARGS_ARG(git_odb_write_REQUIRED_ARGC, git_odb_write_OPTIONAL_ARGC));
#endif
#if BIND_git_odb_write_pack_FUNCTION
  mrb_define_class_method(mrb, Git_module, "odb_write_pack", mrb_Git_git_odb_write_pack, MRB_ARGS_ARG(git_odb_write_pack_REQUIRED_ARGC, git_odb_write_pack_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_cmp_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_cmp", mrb_Git_git_oid_cmp, MRB_ARGS_ARG(git_oid_cmp_REQUIRED_ARGC, git_oid_cmp_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_cpy_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_cpy", mrb_Git_git_oid_cpy, MRB_ARGS_ARG(git_oid_cpy_REQUIRED_ARGC, git_oid_cpy_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_equal_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_equal", mrb_Git_git_oid_equal, MRB_ARGS_ARG(git_oid_equal_REQUIRED_ARGC, git_oid_equal_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_fmt_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_fmt", mrb_Git_git_oid_fmt, MRB_ARGS_ARG(git_oid_fmt_REQUIRED_ARGC, git_oid_fmt_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_fromraw_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_fromraw", mrb_Git_git_oid_fromraw, MRB_ARGS_ARG(git_oid_fromraw_REQUIRED_ARGC, git_oid_fromraw_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_fromstr_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_fromstr", mrb_Git_git_oid_fromstr, MRB_ARGS_ARG(git_oid_fromstr_REQUIRED_ARGC, git_oid_fromstr_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_fromstrn_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_fromstrn", mrb_Git_git_oid_fromstrn, MRB_ARGS_ARG(git_oid_fromstrn_REQUIRED_ARGC, git_oid_fromstrn_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_fromstrp_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_fromstrp", mrb_Git_git_oid_fromstrp, MRB_ARGS_ARG(git_oid_fromstrp_REQUIRED_ARGC, git_oid_fromstrp_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_iszero_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_iszero", mrb_Git_git_oid_iszero, MRB_ARGS_ARG(git_oid_iszero_REQUIRED_ARGC, git_oid_iszero_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_ncmp_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_ncmp", mrb_Git_git_oid_ncmp, MRB_ARGS_ARG(git_oid_ncmp_REQUIRED_ARGC, git_oid_ncmp_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_nfmt_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_nfmt", mrb_Git_git_oid_nfmt, MRB_ARGS_ARG(git_oid_nfmt_REQUIRED_ARGC, git_oid_nfmt_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_pathfmt_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_pathfmt", mrb_Git_git_oid_pathfmt, MRB_ARGS_ARG(git_oid_pathfmt_REQUIRED_ARGC, git_oid_pathfmt_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_shorten_add_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_shorten_add", mrb_Git_git_oid_shorten_add, MRB_ARGS_ARG(git_oid_shorten_add_REQUIRED_ARGC, git_oid_shorten_add_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_shorten_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_shorten_free", mrb_Git_git_oid_shorten_free, MRB_ARGS_ARG(git_oid_shorten_free_REQUIRED_ARGC, git_oid_shorten_free_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_shorten_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_shorten_new", mrb_Git_git_oid_shorten_new, MRB_ARGS_ARG(git_oid_shorten_new_REQUIRED_ARGC, git_oid_shorten_new_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_strcmp_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_strcmp", mrb_Git_git_oid_strcmp, MRB_ARGS_ARG(git_oid_strcmp_REQUIRED_ARGC, git_oid_strcmp_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_streq_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_streq", mrb_Git_git_oid_streq, MRB_ARGS_ARG(git_oid_streq_REQUIRED_ARGC, git_oid_streq_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_tostr_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_tostr", mrb_Git_git_oid_tostr, MRB_ARGS_ARG(git_oid_tostr_REQUIRED_ARGC, git_oid_tostr_OPTIONAL_ARGC));
#endif
#if BIND_git_oid_tostr_s_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oid_tostr_s", mrb_Git_git_oid_tostr_s, MRB_ARGS_ARG(git_oid_tostr_s_REQUIRED_ARGC, git_oid_tostr_s_OPTIONAL_ARGC));
#endif
#if BIND_git_oidarray_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "oidarray_free", mrb_Git_git_oidarray_free, MRB_ARGS_ARG(git_oidarray_free_REQUIRED_ARGC, git_oidarray_free_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_foreach", mrb_Git_git_packbuilder_foreach, MRB_ARGS_ARG(git_packbuilder_foreach_REQUIRED_ARGC, git_packbuilder_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_free", mrb_Git_git_packbuilder_free, MRB_ARGS_ARG(git_packbuilder_free_REQUIRED_ARGC, git_packbuilder_free_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_hash_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_hash", mrb_Git_git_packbuilder_hash, MRB_ARGS_ARG(git_packbuilder_hash_REQUIRED_ARGC, git_packbuilder_hash_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_insert_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_insert", mrb_Git_git_packbuilder_insert, MRB_ARGS_ARG(git_packbuilder_insert_REQUIRED_ARGC, git_packbuilder_insert_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_insert_commit_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_insert_commit", mrb_Git_git_packbuilder_insert_commit, MRB_ARGS_ARG(git_packbuilder_insert_commit_REQUIRED_ARGC, git_packbuilder_insert_commit_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_insert_recur_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_insert_recur", mrb_Git_git_packbuilder_insert_recur, MRB_ARGS_ARG(git_packbuilder_insert_recur_REQUIRED_ARGC, git_packbuilder_insert_recur_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_insert_tree_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_insert_tree", mrb_Git_git_packbuilder_insert_tree, MRB_ARGS_ARG(git_packbuilder_insert_tree_REQUIRED_ARGC, git_packbuilder_insert_tree_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_insert_walk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_insert_walk", mrb_Git_git_packbuilder_insert_walk, MRB_ARGS_ARG(git_packbuilder_insert_walk_REQUIRED_ARGC, git_packbuilder_insert_walk_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_new", mrb_Git_git_packbuilder_new, MRB_ARGS_ARG(git_packbuilder_new_REQUIRED_ARGC, git_packbuilder_new_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_object_count_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_object_count", mrb_Git_git_packbuilder_object_count, MRB_ARGS_ARG(git_packbuilder_object_count_REQUIRED_ARGC, git_packbuilder_object_count_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_set_callbacks_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_set_callbacks", mrb_Git_git_packbuilder_set_callbacks, MRB_ARGS_ARG(git_packbuilder_set_callbacks_REQUIRED_ARGC, git_packbuilder_set_callbacks_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_set_threads_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_set_threads", mrb_Git_git_packbuilder_set_threads, MRB_ARGS_ARG(git_packbuilder_set_threads_REQUIRED_ARGC, git_packbuilder_set_threads_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_write_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_write", mrb_Git_git_packbuilder_write, MRB_ARGS_ARG(git_packbuilder_write_REQUIRED_ARGC, git_packbuilder_write_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_write_buf_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_write_buf", mrb_Git_git_packbuilder_write_buf, MRB_ARGS_ARG(git_packbuilder_write_buf_REQUIRED_ARGC, git_packbuilder_write_buf_OPTIONAL_ARGC));
#endif
#if BIND_git_packbuilder_written_FUNCTION
  mrb_define_class_method(mrb, Git_module, "packbuilder_written", mrb_Git_git_packbuilder_written, MRB_ARGS_ARG(git_packbuilder_written_REQUIRED_ARGC, git_packbuilder_written_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_free", mrb_Git_git_patch_free, MRB_ARGS_ARG(git_patch_free_REQUIRED_ARGC, git_patch_free_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_from_blob_and_buffer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_from_blob_and_buffer", mrb_Git_git_patch_from_blob_and_buffer, MRB_ARGS_ARG(git_patch_from_blob_and_buffer_REQUIRED_ARGC, git_patch_from_blob_and_buffer_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_from_blobs_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_from_blobs", mrb_Git_git_patch_from_blobs, MRB_ARGS_ARG(git_patch_from_blobs_REQUIRED_ARGC, git_patch_from_blobs_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_from_buffers_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_from_buffers", mrb_Git_git_patch_from_buffers, MRB_ARGS_ARG(git_patch_from_buffers_REQUIRED_ARGC, git_patch_from_buffers_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_from_diff_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_from_diff", mrb_Git_git_patch_from_diff, MRB_ARGS_ARG(git_patch_from_diff_REQUIRED_ARGC, git_patch_from_diff_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_get_delta_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_get_delta", mrb_Git_git_patch_get_delta, MRB_ARGS_ARG(git_patch_get_delta_REQUIRED_ARGC, git_patch_get_delta_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_get_hunk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_get_hunk", mrb_Git_git_patch_get_hunk, MRB_ARGS_ARG(git_patch_get_hunk_REQUIRED_ARGC, git_patch_get_hunk_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_get_line_in_hunk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_get_line_in_hunk", mrb_Git_git_patch_get_line_in_hunk, MRB_ARGS_ARG(git_patch_get_line_in_hunk_REQUIRED_ARGC, git_patch_get_line_in_hunk_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_line_stats_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_line_stats", mrb_Git_git_patch_line_stats, MRB_ARGS_ARG(git_patch_line_stats_REQUIRED_ARGC, git_patch_line_stats_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_num_hunks_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_num_hunks", mrb_Git_git_patch_num_hunks, MRB_ARGS_ARG(git_patch_num_hunks_REQUIRED_ARGC, git_patch_num_hunks_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_num_lines_in_hunk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_num_lines_in_hunk", mrb_Git_git_patch_num_lines_in_hunk, MRB_ARGS_ARG(git_patch_num_lines_in_hunk_REQUIRED_ARGC, git_patch_num_lines_in_hunk_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_print_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_print", mrb_Git_git_patch_print, MRB_ARGS_ARG(git_patch_print_REQUIRED_ARGC, git_patch_print_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_size_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_size", mrb_Git_git_patch_size, MRB_ARGS_ARG(git_patch_size_REQUIRED_ARGC, git_patch_size_OPTIONAL_ARGC));
#endif
#if BIND_git_patch_to_buf_FUNCTION
  mrb_define_class_method(mrb, Git_module, "patch_to_buf", mrb_Git_git_patch_to_buf, MRB_ARGS_ARG(git_patch_to_buf_REQUIRED_ARGC, git_patch_to_buf_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_free", mrb_Git_git_pathspec_free, MRB_ARGS_ARG(git_pathspec_free_REQUIRED_ARGC, git_pathspec_free_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_diff_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_diff", mrb_Git_git_pathspec_match_diff, MRB_ARGS_ARG(git_pathspec_match_diff_REQUIRED_ARGC, git_pathspec_match_diff_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_index", mrb_Git_git_pathspec_match_index, MRB_ARGS_ARG(git_pathspec_match_index_REQUIRED_ARGC, git_pathspec_match_index_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_list_diff_entry_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_list_diff_entry", mrb_Git_git_pathspec_match_list_diff_entry, MRB_ARGS_ARG(git_pathspec_match_list_diff_entry_REQUIRED_ARGC, git_pathspec_match_list_diff_entry_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_list_entry_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_list_entry", mrb_Git_git_pathspec_match_list_entry, MRB_ARGS_ARG(git_pathspec_match_list_entry_REQUIRED_ARGC, git_pathspec_match_list_entry_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_list_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_list_entrycount", mrb_Git_git_pathspec_match_list_entrycount, MRB_ARGS_ARG(git_pathspec_match_list_entrycount_REQUIRED_ARGC, git_pathspec_match_list_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_list_failed_entry_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_list_failed_entry", mrb_Git_git_pathspec_match_list_failed_entry, MRB_ARGS_ARG(git_pathspec_match_list_failed_entry_REQUIRED_ARGC, git_pathspec_match_list_failed_entry_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_list_failed_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_list_failed_entrycount", mrb_Git_git_pathspec_match_list_failed_entrycount, MRB_ARGS_ARG(git_pathspec_match_list_failed_entrycount_REQUIRED_ARGC, git_pathspec_match_list_failed_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_list_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_list_free", mrb_Git_git_pathspec_match_list_free, MRB_ARGS_ARG(git_pathspec_match_list_free_REQUIRED_ARGC, git_pathspec_match_list_free_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_tree_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_tree", mrb_Git_git_pathspec_match_tree, MRB_ARGS_ARG(git_pathspec_match_tree_REQUIRED_ARGC, git_pathspec_match_tree_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_match_workdir_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_match_workdir", mrb_Git_git_pathspec_match_workdir, MRB_ARGS_ARG(git_pathspec_match_workdir_REQUIRED_ARGC, git_pathspec_match_workdir_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_matches_path_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_matches_path", mrb_Git_git_pathspec_matches_path, MRB_ARGS_ARG(git_pathspec_matches_path_REQUIRED_ARGC, git_pathspec_matches_path_OPTIONAL_ARGC));
#endif
#if BIND_git_pathspec_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "pathspec_new", mrb_Git_git_pathspec_new, MRB_ARGS_ARG(git_pathspec_new_REQUIRED_ARGC, git_pathspec_new_OPTIONAL_ARGC));
#endif
#if BIND_git_push_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "push_init_options", mrb_Git_git_push_init_options, MRB_ARGS_ARG(git_push_init_options_REQUIRED_ARGC, git_push_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_abort_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_abort", mrb_Git_git_rebase_abort, MRB_ARGS_ARG(git_rebase_abort_REQUIRED_ARGC, git_rebase_abort_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_commit_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_commit", mrb_Git_git_rebase_commit, MRB_ARGS_ARG(git_rebase_commit_REQUIRED_ARGC, git_rebase_commit_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_finish_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_finish", mrb_Git_git_rebase_finish, MRB_ARGS_ARG(git_rebase_finish_REQUIRED_ARGC, git_rebase_finish_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_free", mrb_Git_git_rebase_free, MRB_ARGS_ARG(git_rebase_free_REQUIRED_ARGC, git_rebase_free_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_init_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_init", mrb_Git_git_rebase_init, MRB_ARGS_ARG(git_rebase_init_REQUIRED_ARGC, git_rebase_init_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_init_options", mrb_Git_git_rebase_init_options, MRB_ARGS_ARG(git_rebase_init_options_REQUIRED_ARGC, git_rebase_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_next_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_next", mrb_Git_git_rebase_next, MRB_ARGS_ARG(git_rebase_next_REQUIRED_ARGC, git_rebase_next_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_open_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_open", mrb_Git_git_rebase_open, MRB_ARGS_ARG(git_rebase_open_REQUIRED_ARGC, git_rebase_open_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_operation_byindex_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_operation_byindex", mrb_Git_git_rebase_operation_byindex, MRB_ARGS_ARG(git_rebase_operation_byindex_REQUIRED_ARGC, git_rebase_operation_byindex_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_operation_current_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_operation_current", mrb_Git_git_rebase_operation_current, MRB_ARGS_ARG(git_rebase_operation_current_REQUIRED_ARGC, git_rebase_operation_current_OPTIONAL_ARGC));
#endif
#if BIND_git_rebase_operation_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "rebase_operation_entrycount", mrb_Git_git_rebase_operation_entrycount, MRB_ARGS_ARG(git_rebase_operation_entrycount_REQUIRED_ARGC, git_rebase_operation_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_refdb_compress_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refdb_compress", mrb_Git_git_refdb_compress, MRB_ARGS_ARG(git_refdb_compress_REQUIRED_ARGC, git_refdb_compress_OPTIONAL_ARGC));
#endif
#if BIND_git_refdb_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refdb_free", mrb_Git_git_refdb_free, MRB_ARGS_ARG(git_refdb_free_REQUIRED_ARGC, git_refdb_free_OPTIONAL_ARGC));
#endif
#if BIND_git_refdb_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refdb_new", mrb_Git_git_refdb_new, MRB_ARGS_ARG(git_refdb_new_REQUIRED_ARGC, git_refdb_new_OPTIONAL_ARGC));
#endif
#if BIND_git_refdb_open_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refdb_open", mrb_Git_git_refdb_open, MRB_ARGS_ARG(git_refdb_open_REQUIRED_ARGC, git_refdb_open_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_cmp_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_cmp", mrb_Git_git_reference_cmp, MRB_ARGS_ARG(git_reference_cmp_REQUIRED_ARGC, git_reference_cmp_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_create", mrb_Git_git_reference_create, MRB_ARGS_ARG(git_reference_create_REQUIRED_ARGC, git_reference_create_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_create_matching_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_create_matching", mrb_Git_git_reference_create_matching, MRB_ARGS_ARG(git_reference_create_matching_REQUIRED_ARGC, git_reference_create_matching_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_delete_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_delete", mrb_Git_git_reference_delete, MRB_ARGS_ARG(git_reference_delete_REQUIRED_ARGC, git_reference_delete_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_dwim_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_dwim", mrb_Git_git_reference_dwim, MRB_ARGS_ARG(git_reference_dwim_REQUIRED_ARGC, git_reference_dwim_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_ensure_log_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_ensure_log", mrb_Git_git_reference_ensure_log, MRB_ARGS_ARG(git_reference_ensure_log_REQUIRED_ARGC, git_reference_ensure_log_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_foreach", mrb_Git_git_reference_foreach, MRB_ARGS_ARG(git_reference_foreach_REQUIRED_ARGC, git_reference_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_foreach_glob_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_foreach_glob", mrb_Git_git_reference_foreach_glob, MRB_ARGS_ARG(git_reference_foreach_glob_REQUIRED_ARGC, git_reference_foreach_glob_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_foreach_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_foreach_name", mrb_Git_git_reference_foreach_name, MRB_ARGS_ARG(git_reference_foreach_name_REQUIRED_ARGC, git_reference_foreach_name_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_free", mrb_Git_git_reference_free, MRB_ARGS_ARG(git_reference_free_REQUIRED_ARGC, git_reference_free_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_has_log_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_has_log", mrb_Git_git_reference_has_log, MRB_ARGS_ARG(git_reference_has_log_REQUIRED_ARGC, git_reference_has_log_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_is_branch_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_is_branch", mrb_Git_git_reference_is_branch, MRB_ARGS_ARG(git_reference_is_branch_REQUIRED_ARGC, git_reference_is_branch_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_is_note_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_is_note", mrb_Git_git_reference_is_note, MRB_ARGS_ARG(git_reference_is_note_REQUIRED_ARGC, git_reference_is_note_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_is_remote_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_is_remote", mrb_Git_git_reference_is_remote, MRB_ARGS_ARG(git_reference_is_remote_REQUIRED_ARGC, git_reference_is_remote_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_is_tag_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_is_tag", mrb_Git_git_reference_is_tag, MRB_ARGS_ARG(git_reference_is_tag_REQUIRED_ARGC, git_reference_is_tag_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_is_valid_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_is_valid_name", mrb_Git_git_reference_is_valid_name, MRB_ARGS_ARG(git_reference_is_valid_name_REQUIRED_ARGC, git_reference_is_valid_name_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_iterator_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_iterator_free", mrb_Git_git_reference_iterator_free, MRB_ARGS_ARG(git_reference_iterator_free_REQUIRED_ARGC, git_reference_iterator_free_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_iterator_glob_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_iterator_glob_new", mrb_Git_git_reference_iterator_glob_new, MRB_ARGS_ARG(git_reference_iterator_glob_new_REQUIRED_ARGC, git_reference_iterator_glob_new_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_iterator_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_iterator_new", mrb_Git_git_reference_iterator_new, MRB_ARGS_ARG(git_reference_iterator_new_REQUIRED_ARGC, git_reference_iterator_new_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_list_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_list", mrb_Git_git_reference_list, MRB_ARGS_ARG(git_reference_list_REQUIRED_ARGC, git_reference_list_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_lookup", mrb_Git_git_reference_lookup, MRB_ARGS_ARG(git_reference_lookup_REQUIRED_ARGC, git_reference_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_name", mrb_Git_git_reference_name, MRB_ARGS_ARG(git_reference_name_REQUIRED_ARGC, git_reference_name_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_name_to_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_name_to_id", mrb_Git_git_reference_name_to_id, MRB_ARGS_ARG(git_reference_name_to_id_REQUIRED_ARGC, git_reference_name_to_id_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_next_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_next", mrb_Git_git_reference_next, MRB_ARGS_ARG(git_reference_next_REQUIRED_ARGC, git_reference_next_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_next_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_next_name", mrb_Git_git_reference_next_name, MRB_ARGS_ARG(git_reference_next_name_REQUIRED_ARGC, git_reference_next_name_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_normalize_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_normalize_name", mrb_Git_git_reference_normalize_name, MRB_ARGS_ARG(git_reference_normalize_name_REQUIRED_ARGC, git_reference_normalize_name_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_owner", mrb_Git_git_reference_owner, MRB_ARGS_ARG(git_reference_owner_REQUIRED_ARGC, git_reference_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_peel_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_peel", mrb_Git_git_reference_peel, MRB_ARGS_ARG(git_reference_peel_REQUIRED_ARGC, git_reference_peel_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_remove_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_remove", mrb_Git_git_reference_remove, MRB_ARGS_ARG(git_reference_remove_REQUIRED_ARGC, git_reference_remove_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_rename_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_rename", mrb_Git_git_reference_rename, MRB_ARGS_ARG(git_reference_rename_REQUIRED_ARGC, git_reference_rename_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_resolve_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_resolve", mrb_Git_git_reference_resolve, MRB_ARGS_ARG(git_reference_resolve_REQUIRED_ARGC, git_reference_resolve_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_set_target_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_set_target", mrb_Git_git_reference_set_target, MRB_ARGS_ARG(git_reference_set_target_REQUIRED_ARGC, git_reference_set_target_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_shorthand_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_shorthand", mrb_Git_git_reference_shorthand, MRB_ARGS_ARG(git_reference_shorthand_REQUIRED_ARGC, git_reference_shorthand_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_symbolic_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_symbolic_create", mrb_Git_git_reference_symbolic_create, MRB_ARGS_ARG(git_reference_symbolic_create_REQUIRED_ARGC, git_reference_symbolic_create_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_symbolic_create_matching_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_symbolic_create_matching", mrb_Git_git_reference_symbolic_create_matching, MRB_ARGS_ARG(git_reference_symbolic_create_matching_REQUIRED_ARGC, git_reference_symbolic_create_matching_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_symbolic_set_target_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_symbolic_set_target", mrb_Git_git_reference_symbolic_set_target, MRB_ARGS_ARG(git_reference_symbolic_set_target_REQUIRED_ARGC, git_reference_symbolic_set_target_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_symbolic_target_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_symbolic_target", mrb_Git_git_reference_symbolic_target, MRB_ARGS_ARG(git_reference_symbolic_target_REQUIRED_ARGC, git_reference_symbolic_target_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_target_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_target", mrb_Git_git_reference_target, MRB_ARGS_ARG(git_reference_target_REQUIRED_ARGC, git_reference_target_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_target_peel_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_target_peel", mrb_Git_git_reference_target_peel, MRB_ARGS_ARG(git_reference_target_peel_REQUIRED_ARGC, git_reference_target_peel_OPTIONAL_ARGC));
#endif
#if BIND_git_reference_type_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reference_type", mrb_Git_git_reference_type, MRB_ARGS_ARG(git_reference_type_REQUIRED_ARGC, git_reference_type_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_append_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_append", mrb_Git_git_reflog_append, MRB_ARGS_ARG(git_reflog_append_REQUIRED_ARGC, git_reflog_append_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_delete_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_delete", mrb_Git_git_reflog_delete, MRB_ARGS_ARG(git_reflog_delete_REQUIRED_ARGC, git_reflog_delete_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_drop_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_drop", mrb_Git_git_reflog_drop, MRB_ARGS_ARG(git_reflog_drop_REQUIRED_ARGC, git_reflog_drop_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_entry_byindex_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_entry_byindex", mrb_Git_git_reflog_entry_byindex, MRB_ARGS_ARG(git_reflog_entry_byindex_REQUIRED_ARGC, git_reflog_entry_byindex_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_entry_committer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_entry_committer", mrb_Git_git_reflog_entry_committer, MRB_ARGS_ARG(git_reflog_entry_committer_REQUIRED_ARGC, git_reflog_entry_committer_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_entry_id_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_entry_id_new", mrb_Git_git_reflog_entry_id_new, MRB_ARGS_ARG(git_reflog_entry_id_new_REQUIRED_ARGC, git_reflog_entry_id_new_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_entry_id_old_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_entry_id_old", mrb_Git_git_reflog_entry_id_old, MRB_ARGS_ARG(git_reflog_entry_id_old_REQUIRED_ARGC, git_reflog_entry_id_old_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_entry_message_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_entry_message", mrb_Git_git_reflog_entry_message, MRB_ARGS_ARG(git_reflog_entry_message_REQUIRED_ARGC, git_reflog_entry_message_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_entrycount", mrb_Git_git_reflog_entrycount, MRB_ARGS_ARG(git_reflog_entrycount_REQUIRED_ARGC, git_reflog_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_free", mrb_Git_git_reflog_free, MRB_ARGS_ARG(git_reflog_free_REQUIRED_ARGC, git_reflog_free_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_read_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_read", mrb_Git_git_reflog_read, MRB_ARGS_ARG(git_reflog_read_REQUIRED_ARGC, git_reflog_read_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_rename_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_rename", mrb_Git_git_reflog_rename, MRB_ARGS_ARG(git_reflog_rename_REQUIRED_ARGC, git_reflog_rename_OPTIONAL_ARGC));
#endif
#if BIND_git_reflog_write_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reflog_write", mrb_Git_git_reflog_write, MRB_ARGS_ARG(git_reflog_write_REQUIRED_ARGC, git_reflog_write_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_direction_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_direction", mrb_Git_git_refspec_direction, MRB_ARGS_ARG(git_refspec_direction_REQUIRED_ARGC, git_refspec_direction_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_dst_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_dst", mrb_Git_git_refspec_dst, MRB_ARGS_ARG(git_refspec_dst_REQUIRED_ARGC, git_refspec_dst_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_dst_matches_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_dst_matches", mrb_Git_git_refspec_dst_matches, MRB_ARGS_ARG(git_refspec_dst_matches_REQUIRED_ARGC, git_refspec_dst_matches_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_force_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_force", mrb_Git_git_refspec_force, MRB_ARGS_ARG(git_refspec_force_REQUIRED_ARGC, git_refspec_force_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_rtransform_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_rtransform", mrb_Git_git_refspec_rtransform, MRB_ARGS_ARG(git_refspec_rtransform_REQUIRED_ARGC, git_refspec_rtransform_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_src_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_src", mrb_Git_git_refspec_src, MRB_ARGS_ARG(git_refspec_src_REQUIRED_ARGC, git_refspec_src_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_src_matches_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_src_matches", mrb_Git_git_refspec_src_matches, MRB_ARGS_ARG(git_refspec_src_matches_REQUIRED_ARGC, git_refspec_src_matches_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_string_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_string", mrb_Git_git_refspec_string, MRB_ARGS_ARG(git_refspec_string_REQUIRED_ARGC, git_refspec_string_OPTIONAL_ARGC));
#endif
#if BIND_git_refspec_transform_FUNCTION
  mrb_define_class_method(mrb, Git_module, "refspec_transform", mrb_Git_git_refspec_transform, MRB_ARGS_ARG(git_refspec_transform_REQUIRED_ARGC, git_refspec_transform_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_add_fetch_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_add_fetch", mrb_Git_git_remote_add_fetch, MRB_ARGS_ARG(git_remote_add_fetch_REQUIRED_ARGC, git_remote_add_fetch_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_add_push_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_add_push", mrb_Git_git_remote_add_push, MRB_ARGS_ARG(git_remote_add_push_REQUIRED_ARGC, git_remote_add_push_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_autotag_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_autotag", mrb_Git_git_remote_autotag, MRB_ARGS_ARG(git_remote_autotag_REQUIRED_ARGC, git_remote_autotag_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_connect_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_connect", mrb_Git_git_remote_connect, MRB_ARGS_ARG(git_remote_connect_REQUIRED_ARGC, git_remote_connect_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_connected_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_connected", mrb_Git_git_remote_connected, MRB_ARGS_ARG(git_remote_connected_REQUIRED_ARGC, git_remote_connected_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_create", mrb_Git_git_remote_create, MRB_ARGS_ARG(git_remote_create_REQUIRED_ARGC, git_remote_create_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_create_anonymous_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_create_anonymous", mrb_Git_git_remote_create_anonymous, MRB_ARGS_ARG(git_remote_create_anonymous_REQUIRED_ARGC, git_remote_create_anonymous_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_create_with_fetchspec_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_create_with_fetchspec", mrb_Git_git_remote_create_with_fetchspec, MRB_ARGS_ARG(git_remote_create_with_fetchspec_REQUIRED_ARGC, git_remote_create_with_fetchspec_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_default_branch_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_default_branch", mrb_Git_git_remote_default_branch, MRB_ARGS_ARG(git_remote_default_branch_REQUIRED_ARGC, git_remote_default_branch_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_delete_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_delete", mrb_Git_git_remote_delete, MRB_ARGS_ARG(git_remote_delete_REQUIRED_ARGC, git_remote_delete_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_disconnect_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_disconnect", mrb_Git_git_remote_disconnect, MRB_ARGS_ARG(git_remote_disconnect_REQUIRED_ARGC, git_remote_disconnect_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_download_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_download", mrb_Git_git_remote_download, MRB_ARGS_ARG(git_remote_download_REQUIRED_ARGC, git_remote_download_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_dup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_dup", mrb_Git_git_remote_dup, MRB_ARGS_ARG(git_remote_dup_REQUIRED_ARGC, git_remote_dup_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_fetch_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_fetch", mrb_Git_git_remote_fetch, MRB_ARGS_ARG(git_remote_fetch_REQUIRED_ARGC, git_remote_fetch_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_free", mrb_Git_git_remote_free, MRB_ARGS_ARG(git_remote_free_REQUIRED_ARGC, git_remote_free_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_get_fetch_refspecs_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_get_fetch_refspecs", mrb_Git_git_remote_get_fetch_refspecs, MRB_ARGS_ARG(git_remote_get_fetch_refspecs_REQUIRED_ARGC, git_remote_get_fetch_refspecs_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_get_push_refspecs_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_get_push_refspecs", mrb_Git_git_remote_get_push_refspecs, MRB_ARGS_ARG(git_remote_get_push_refspecs_REQUIRED_ARGC, git_remote_get_push_refspecs_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_get_refspec_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_get_refspec", mrb_Git_git_remote_get_refspec, MRB_ARGS_ARG(git_remote_get_refspec_REQUIRED_ARGC, git_remote_get_refspec_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_init_callbacks_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_init_callbacks", mrb_Git_git_remote_init_callbacks, MRB_ARGS_ARG(git_remote_init_callbacks_REQUIRED_ARGC, git_remote_init_callbacks_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_is_valid_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_is_valid_name", mrb_Git_git_remote_is_valid_name, MRB_ARGS_ARG(git_remote_is_valid_name_REQUIRED_ARGC, git_remote_is_valid_name_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_list_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_list", mrb_Git_git_remote_list, MRB_ARGS_ARG(git_remote_list_REQUIRED_ARGC, git_remote_list_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_lookup", mrb_Git_git_remote_lookup, MRB_ARGS_ARG(git_remote_lookup_REQUIRED_ARGC, git_remote_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_ls_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_ls", mrb_Git_git_remote_ls, MRB_ARGS_ARG(git_remote_ls_REQUIRED_ARGC, git_remote_ls_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_name", mrb_Git_git_remote_name, MRB_ARGS_ARG(git_remote_name_REQUIRED_ARGC, git_remote_name_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_owner", mrb_Git_git_remote_owner, MRB_ARGS_ARG(git_remote_owner_REQUIRED_ARGC, git_remote_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_prune_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_prune", mrb_Git_git_remote_prune, MRB_ARGS_ARG(git_remote_prune_REQUIRED_ARGC, git_remote_prune_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_prune_refs_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_prune_refs", mrb_Git_git_remote_prune_refs, MRB_ARGS_ARG(git_remote_prune_refs_REQUIRED_ARGC, git_remote_prune_refs_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_push_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_push", mrb_Git_git_remote_push, MRB_ARGS_ARG(git_remote_push_REQUIRED_ARGC, git_remote_push_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_pushurl_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_pushurl", mrb_Git_git_remote_pushurl, MRB_ARGS_ARG(git_remote_pushurl_REQUIRED_ARGC, git_remote_pushurl_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_refspec_count_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_refspec_count", mrb_Git_git_remote_refspec_count, MRB_ARGS_ARG(git_remote_refspec_count_REQUIRED_ARGC, git_remote_refspec_count_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_rename_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_rename", mrb_Git_git_remote_rename, MRB_ARGS_ARG(git_remote_rename_REQUIRED_ARGC, git_remote_rename_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_set_autotag_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_set_autotag", mrb_Git_git_remote_set_autotag, MRB_ARGS_ARG(git_remote_set_autotag_REQUIRED_ARGC, git_remote_set_autotag_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_set_pushurl_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_set_pushurl", mrb_Git_git_remote_set_pushurl, MRB_ARGS_ARG(git_remote_set_pushurl_REQUIRED_ARGC, git_remote_set_pushurl_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_set_url_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_set_url", mrb_Git_git_remote_set_url, MRB_ARGS_ARG(git_remote_set_url_REQUIRED_ARGC, git_remote_set_url_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_stats_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_stats", mrb_Git_git_remote_stats, MRB_ARGS_ARG(git_remote_stats_REQUIRED_ARGC, git_remote_stats_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_stop_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_stop", mrb_Git_git_remote_stop, MRB_ARGS_ARG(git_remote_stop_REQUIRED_ARGC, git_remote_stop_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_update_tips_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_update_tips", mrb_Git_git_remote_update_tips, MRB_ARGS_ARG(git_remote_update_tips_REQUIRED_ARGC, git_remote_update_tips_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_upload_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_upload", mrb_Git_git_remote_upload, MRB_ARGS_ARG(git_remote_upload_REQUIRED_ARGC, git_remote_upload_OPTIONAL_ARGC));
#endif
#if BIND_git_remote_url_FUNCTION
  mrb_define_class_method(mrb, Git_module, "remote_url", mrb_Git_git_remote_url, MRB_ARGS_ARG(git_remote_url_REQUIRED_ARGC, git_remote_url_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_config_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_config", mrb_Git_git_repository_config, MRB_ARGS_ARG(git_repository_config_REQUIRED_ARGC, git_repository_config_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_config_snapshot_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_config_snapshot", mrb_Git_git_repository_config_snapshot, MRB_ARGS_ARG(git_repository_config_snapshot_REQUIRED_ARGC, git_repository_config_snapshot_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_detach_head_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_detach_head", mrb_Git_git_repository_detach_head, MRB_ARGS_ARG(git_repository_detach_head_REQUIRED_ARGC, git_repository_detach_head_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_discover_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_discover", mrb_Git_git_repository_discover, MRB_ARGS_ARG(git_repository_discover_REQUIRED_ARGC, git_repository_discover_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_fetchhead_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_fetchhead_foreach", mrb_Git_git_repository_fetchhead_foreach, MRB_ARGS_ARG(git_repository_fetchhead_foreach_REQUIRED_ARGC, git_repository_fetchhead_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_free", mrb_Git_git_repository_free, MRB_ARGS_ARG(git_repository_free_REQUIRED_ARGC, git_repository_free_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_get_namespace_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_get_namespace", mrb_Git_git_repository_get_namespace, MRB_ARGS_ARG(git_repository_get_namespace_REQUIRED_ARGC, git_repository_get_namespace_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_hashfile_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_hashfile", mrb_Git_git_repository_hashfile, MRB_ARGS_ARG(git_repository_hashfile_REQUIRED_ARGC, git_repository_hashfile_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_head_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_head", mrb_Git_git_repository_head, MRB_ARGS_ARG(git_repository_head_REQUIRED_ARGC, git_repository_head_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_head_detached_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_head_detached", mrb_Git_git_repository_head_detached, MRB_ARGS_ARG(git_repository_head_detached_REQUIRED_ARGC, git_repository_head_detached_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_head_unborn_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_head_unborn", mrb_Git_git_repository_head_unborn, MRB_ARGS_ARG(git_repository_head_unborn_REQUIRED_ARGC, git_repository_head_unborn_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_ident_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_ident", mrb_Git_git_repository_ident, MRB_ARGS_ARG(git_repository_ident_REQUIRED_ARGC, git_repository_ident_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_index", mrb_Git_git_repository_index, MRB_ARGS_ARG(git_repository_index_REQUIRED_ARGC, git_repository_index_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_init_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_init", mrb_Git_git_repository_init, MRB_ARGS_ARG(git_repository_init_REQUIRED_ARGC, git_repository_init_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_init_ext_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_init_ext", mrb_Git_git_repository_init_ext, MRB_ARGS_ARG(git_repository_init_ext_REQUIRED_ARGC, git_repository_init_ext_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_init_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_init_init_options", mrb_Git_git_repository_init_init_options, MRB_ARGS_ARG(git_repository_init_init_options_REQUIRED_ARGC, git_repository_init_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_is_bare_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_is_bare", mrb_Git_git_repository_is_bare, MRB_ARGS_ARG(git_repository_is_bare_REQUIRED_ARGC, git_repository_is_bare_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_is_empty_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_is_empty", mrb_Git_git_repository_is_empty, MRB_ARGS_ARG(git_repository_is_empty_REQUIRED_ARGC, git_repository_is_empty_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_is_shallow_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_is_shallow", mrb_Git_git_repository_is_shallow, MRB_ARGS_ARG(git_repository_is_shallow_REQUIRED_ARGC, git_repository_is_shallow_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_mergehead_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_mergehead_foreach", mrb_Git_git_repository_mergehead_foreach, MRB_ARGS_ARG(git_repository_mergehead_foreach_REQUIRED_ARGC, git_repository_mergehead_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_message_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_message", mrb_Git_git_repository_message, MRB_ARGS_ARG(git_repository_message_REQUIRED_ARGC, git_repository_message_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_message_remove_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_message_remove", mrb_Git_git_repository_message_remove, MRB_ARGS_ARG(git_repository_message_remove_REQUIRED_ARGC, git_repository_message_remove_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_odb_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_odb", mrb_Git_git_repository_odb, MRB_ARGS_ARG(git_repository_odb_REQUIRED_ARGC, git_repository_odb_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_open_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_open", mrb_Git_git_repository_open, MRB_ARGS_ARG(git_repository_open_REQUIRED_ARGC, git_repository_open_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_open_bare_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_open_bare", mrb_Git_git_repository_open_bare, MRB_ARGS_ARG(git_repository_open_bare_REQUIRED_ARGC, git_repository_open_bare_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_open_ext_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_open_ext", mrb_Git_git_repository_open_ext, MRB_ARGS_ARG(git_repository_open_ext_REQUIRED_ARGC, git_repository_open_ext_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_path_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_path", mrb_Git_git_repository_path, MRB_ARGS_ARG(git_repository_path_REQUIRED_ARGC, git_repository_path_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_refdb_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_refdb", mrb_Git_git_repository_refdb, MRB_ARGS_ARG(git_repository_refdb_REQUIRED_ARGC, git_repository_refdb_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_set_head_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_set_head", mrb_Git_git_repository_set_head, MRB_ARGS_ARG(git_repository_set_head_REQUIRED_ARGC, git_repository_set_head_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_set_head_detached_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_set_head_detached", mrb_Git_git_repository_set_head_detached, MRB_ARGS_ARG(git_repository_set_head_detached_REQUIRED_ARGC, git_repository_set_head_detached_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_set_head_detached_from_annotated_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_set_head_detached_from_annotated", mrb_Git_git_repository_set_head_detached_from_annotated, MRB_ARGS_ARG(git_repository_set_head_detached_from_annotated_REQUIRED_ARGC, git_repository_set_head_detached_from_annotated_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_set_ident_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_set_ident", mrb_Git_git_repository_set_ident, MRB_ARGS_ARG(git_repository_set_ident_REQUIRED_ARGC, git_repository_set_ident_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_set_namespace_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_set_namespace", mrb_Git_git_repository_set_namespace, MRB_ARGS_ARG(git_repository_set_namespace_REQUIRED_ARGC, git_repository_set_namespace_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_set_workdir_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_set_workdir", mrb_Git_git_repository_set_workdir, MRB_ARGS_ARG(git_repository_set_workdir_REQUIRED_ARGC, git_repository_set_workdir_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_state_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_state", mrb_Git_git_repository_state, MRB_ARGS_ARG(git_repository_state_REQUIRED_ARGC, git_repository_state_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_state_cleanup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_state_cleanup", mrb_Git_git_repository_state_cleanup, MRB_ARGS_ARG(git_repository_state_cleanup_REQUIRED_ARGC, git_repository_state_cleanup_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_workdir_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_workdir", mrb_Git_git_repository_workdir, MRB_ARGS_ARG(git_repository_workdir_REQUIRED_ARGC, git_repository_workdir_OPTIONAL_ARGC));
#endif
#if BIND_git_repository_wrap_odb_FUNCTION
  mrb_define_class_method(mrb, Git_module, "repository_wrap_odb", mrb_Git_git_repository_wrap_odb, MRB_ARGS_ARG(git_repository_wrap_odb_REQUIRED_ARGC, git_repository_wrap_odb_OPTIONAL_ARGC));
#endif
#if BIND_git_reset_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reset", mrb_Git_git_reset, MRB_ARGS_ARG(git_reset_REQUIRED_ARGC, git_reset_OPTIONAL_ARGC));
#endif
#if BIND_git_reset_default_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reset_default", mrb_Git_git_reset_default, MRB_ARGS_ARG(git_reset_default_REQUIRED_ARGC, git_reset_default_OPTIONAL_ARGC));
#endif
#if BIND_git_reset_from_annotated_FUNCTION
  mrb_define_class_method(mrb, Git_module, "reset_from_annotated", mrb_Git_git_reset_from_annotated, MRB_ARGS_ARG(git_reset_from_annotated_REQUIRED_ARGC, git_reset_from_annotated_OPTIONAL_ARGC));
#endif
#if BIND_git_revert_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revert", mrb_Git_git_revert, MRB_ARGS_ARG(git_revert_REQUIRED_ARGC, git_revert_OPTIONAL_ARGC));
#endif
#if BIND_git_revert_commit_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revert_commit", mrb_Git_git_revert_commit, MRB_ARGS_ARG(git_revert_commit_REQUIRED_ARGC, git_revert_commit_OPTIONAL_ARGC));
#endif
#if BIND_git_revert_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revert_init_options", mrb_Git_git_revert_init_options, MRB_ARGS_ARG(git_revert_init_options_REQUIRED_ARGC, git_revert_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_revparse_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revparse", mrb_Git_git_revparse, MRB_ARGS_ARG(git_revparse_REQUIRED_ARGC, git_revparse_OPTIONAL_ARGC));
#endif
#if BIND_git_revparse_ext_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revparse_ext", mrb_Git_git_revparse_ext, MRB_ARGS_ARG(git_revparse_ext_REQUIRED_ARGC, git_revparse_ext_OPTIONAL_ARGC));
#endif
#if BIND_git_revparse_single_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revparse_single", mrb_Git_git_revparse_single, MRB_ARGS_ARG(git_revparse_single_REQUIRED_ARGC, git_revparse_single_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_add_hide_cb_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_add_hide_cb", mrb_Git_git_revwalk_add_hide_cb, MRB_ARGS_ARG(git_revwalk_add_hide_cb_REQUIRED_ARGC, git_revwalk_add_hide_cb_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_free", mrb_Git_git_revwalk_free, MRB_ARGS_ARG(git_revwalk_free_REQUIRED_ARGC, git_revwalk_free_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_hide_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_hide", mrb_Git_git_revwalk_hide, MRB_ARGS_ARG(git_revwalk_hide_REQUIRED_ARGC, git_revwalk_hide_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_hide_glob_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_hide_glob", mrb_Git_git_revwalk_hide_glob, MRB_ARGS_ARG(git_revwalk_hide_glob_REQUIRED_ARGC, git_revwalk_hide_glob_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_hide_head_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_hide_head", mrb_Git_git_revwalk_hide_head, MRB_ARGS_ARG(git_revwalk_hide_head_REQUIRED_ARGC, git_revwalk_hide_head_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_hide_ref_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_hide_ref", mrb_Git_git_revwalk_hide_ref, MRB_ARGS_ARG(git_revwalk_hide_ref_REQUIRED_ARGC, git_revwalk_hide_ref_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_new", mrb_Git_git_revwalk_new, MRB_ARGS_ARG(git_revwalk_new_REQUIRED_ARGC, git_revwalk_new_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_next_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_next", mrb_Git_git_revwalk_next, MRB_ARGS_ARG(git_revwalk_next_REQUIRED_ARGC, git_revwalk_next_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_push_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_push", mrb_Git_git_revwalk_push, MRB_ARGS_ARG(git_revwalk_push_REQUIRED_ARGC, git_revwalk_push_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_push_glob_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_push_glob", mrb_Git_git_revwalk_push_glob, MRB_ARGS_ARG(git_revwalk_push_glob_REQUIRED_ARGC, git_revwalk_push_glob_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_push_head_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_push_head", mrb_Git_git_revwalk_push_head, MRB_ARGS_ARG(git_revwalk_push_head_REQUIRED_ARGC, git_revwalk_push_head_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_push_range_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_push_range", mrb_Git_git_revwalk_push_range, MRB_ARGS_ARG(git_revwalk_push_range_REQUIRED_ARGC, git_revwalk_push_range_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_push_ref_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_push_ref", mrb_Git_git_revwalk_push_ref, MRB_ARGS_ARG(git_revwalk_push_ref_REQUIRED_ARGC, git_revwalk_push_ref_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_repository_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_repository", mrb_Git_git_revwalk_repository, MRB_ARGS_ARG(git_revwalk_repository_REQUIRED_ARGC, git_revwalk_repository_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_reset_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_reset", mrb_Git_git_revwalk_reset, MRB_ARGS_ARG(git_revwalk_reset_REQUIRED_ARGC, git_revwalk_reset_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_simplify_first_parent_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_simplify_first_parent", mrb_Git_git_revwalk_simplify_first_parent, MRB_ARGS_ARG(git_revwalk_simplify_first_parent_REQUIRED_ARGC, git_revwalk_simplify_first_parent_OPTIONAL_ARGC));
#endif
#if BIND_git_revwalk_sorting_FUNCTION
  mrb_define_class_method(mrb, Git_module, "revwalk_sorting", mrb_Git_git_revwalk_sorting, MRB_ARGS_ARG(git_revwalk_sorting_REQUIRED_ARGC, git_revwalk_sorting_OPTIONAL_ARGC));
#endif
#if BIND_git_signature_default_FUNCTION
  mrb_define_class_method(mrb, Git_module, "signature_default", mrb_Git_git_signature_default, MRB_ARGS_ARG(git_signature_default_REQUIRED_ARGC, git_signature_default_OPTIONAL_ARGC));
#endif
#if BIND_git_signature_dup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "signature_dup", mrb_Git_git_signature_dup, MRB_ARGS_ARG(git_signature_dup_REQUIRED_ARGC, git_signature_dup_OPTIONAL_ARGC));
#endif
#if BIND_git_signature_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "signature_free", mrb_Git_git_signature_free, MRB_ARGS_ARG(git_signature_free_REQUIRED_ARGC, git_signature_free_OPTIONAL_ARGC));
#endif
#if BIND_git_signature_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "signature_new", mrb_Git_git_signature_new, MRB_ARGS_ARG(git_signature_new_REQUIRED_ARGC, git_signature_new_OPTIONAL_ARGC));
#endif
#if BIND_git_signature_now_FUNCTION
  mrb_define_class_method(mrb, Git_module, "signature_now", mrb_Git_git_signature_now, MRB_ARGS_ARG(git_signature_now_REQUIRED_ARGC, git_signature_now_OPTIONAL_ARGC));
#endif
#if BIND_git_stash_apply_FUNCTION
  mrb_define_class_method(mrb, Git_module, "stash_apply", mrb_Git_git_stash_apply, MRB_ARGS_ARG(git_stash_apply_REQUIRED_ARGC, git_stash_apply_OPTIONAL_ARGC));
#endif
#if BIND_git_stash_apply_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "stash_apply_init_options", mrb_Git_git_stash_apply_init_options, MRB_ARGS_ARG(git_stash_apply_init_options_REQUIRED_ARGC, git_stash_apply_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_stash_drop_FUNCTION
  mrb_define_class_method(mrb, Git_module, "stash_drop", mrb_Git_git_stash_drop, MRB_ARGS_ARG(git_stash_drop_REQUIRED_ARGC, git_stash_drop_OPTIONAL_ARGC));
#endif
#if BIND_git_stash_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "stash_foreach", mrb_Git_git_stash_foreach, MRB_ARGS_ARG(git_stash_foreach_REQUIRED_ARGC, git_stash_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_stash_pop_FUNCTION
  mrb_define_class_method(mrb, Git_module, "stash_pop", mrb_Git_git_stash_pop, MRB_ARGS_ARG(git_stash_pop_REQUIRED_ARGC, git_stash_pop_OPTIONAL_ARGC));
#endif
#if BIND_git_stash_save_FUNCTION
  mrb_define_class_method(mrb, Git_module, "stash_save", mrb_Git_git_stash_save, MRB_ARGS_ARG(git_stash_save_REQUIRED_ARGC, git_stash_save_OPTIONAL_ARGC));
#endif
#if BIND_git_status_byindex_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_byindex", mrb_Git_git_status_byindex, MRB_ARGS_ARG(git_status_byindex_REQUIRED_ARGC, git_status_byindex_OPTIONAL_ARGC));
#endif
#if BIND_git_status_file_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_file", mrb_Git_git_status_file, MRB_ARGS_ARG(git_status_file_REQUIRED_ARGC, git_status_file_OPTIONAL_ARGC));
#endif
#if BIND_git_status_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_foreach", mrb_Git_git_status_foreach, MRB_ARGS_ARG(git_status_foreach_REQUIRED_ARGC, git_status_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_status_foreach_ext_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_foreach_ext", mrb_Git_git_status_foreach_ext, MRB_ARGS_ARG(git_status_foreach_ext_REQUIRED_ARGC, git_status_foreach_ext_OPTIONAL_ARGC));
#endif
#if BIND_git_status_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_init_options", mrb_Git_git_status_init_options, MRB_ARGS_ARG(git_status_init_options_REQUIRED_ARGC, git_status_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_status_list_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_list_entrycount", mrb_Git_git_status_list_entrycount, MRB_ARGS_ARG(git_status_list_entrycount_REQUIRED_ARGC, git_status_list_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_status_list_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_list_free", mrb_Git_git_status_list_free, MRB_ARGS_ARG(git_status_list_free_REQUIRED_ARGC, git_status_list_free_OPTIONAL_ARGC));
#endif
#if BIND_git_status_list_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_list_new", mrb_Git_git_status_list_new, MRB_ARGS_ARG(git_status_list_new_REQUIRED_ARGC, git_status_list_new_OPTIONAL_ARGC));
#endif
#if BIND_git_status_should_ignore_FUNCTION
  mrb_define_class_method(mrb, Git_module, "status_should_ignore", mrb_Git_git_status_should_ignore, MRB_ARGS_ARG(git_status_should_ignore_REQUIRED_ARGC, git_status_should_ignore_OPTIONAL_ARGC));
#endif
#if BIND_git_strarray_copy_FUNCTION
  mrb_define_class_method(mrb, Git_module, "strarray_copy", mrb_Git_git_strarray_copy, MRB_ARGS_ARG(git_strarray_copy_REQUIRED_ARGC, git_strarray_copy_OPTIONAL_ARGC));
#endif
#if BIND_git_strarray_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "strarray_free", mrb_Git_git_strarray_free, MRB_ARGS_ARG(git_strarray_free_REQUIRED_ARGC, git_strarray_free_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_add_finalize_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_add_finalize", mrb_Git_git_submodule_add_finalize, MRB_ARGS_ARG(git_submodule_add_finalize_REQUIRED_ARGC, git_submodule_add_finalize_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_add_setup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_add_setup", mrb_Git_git_submodule_add_setup, MRB_ARGS_ARG(git_submodule_add_setup_REQUIRED_ARGC, git_submodule_add_setup_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_add_to_index_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_add_to_index", mrb_Git_git_submodule_add_to_index, MRB_ARGS_ARG(git_submodule_add_to_index_REQUIRED_ARGC, git_submodule_add_to_index_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_branch_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_branch", mrb_Git_git_submodule_branch, MRB_ARGS_ARG(git_submodule_branch_REQUIRED_ARGC, git_submodule_branch_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_fetch_recurse_submodules_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_fetch_recurse_submodules", mrb_Git_git_submodule_fetch_recurse_submodules, MRB_ARGS_ARG(git_submodule_fetch_recurse_submodules_REQUIRED_ARGC, git_submodule_fetch_recurse_submodules_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_foreach", mrb_Git_git_submodule_foreach, MRB_ARGS_ARG(git_submodule_foreach_REQUIRED_ARGC, git_submodule_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_free", mrb_Git_git_submodule_free, MRB_ARGS_ARG(git_submodule_free_REQUIRED_ARGC, git_submodule_free_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_head_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_head_id", mrb_Git_git_submodule_head_id, MRB_ARGS_ARG(git_submodule_head_id_REQUIRED_ARGC, git_submodule_head_id_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_ignore_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_ignore", mrb_Git_git_submodule_ignore, MRB_ARGS_ARG(git_submodule_ignore_REQUIRED_ARGC, git_submodule_ignore_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_index_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_index_id", mrb_Git_git_submodule_index_id, MRB_ARGS_ARG(git_submodule_index_id_REQUIRED_ARGC, git_submodule_index_id_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_init_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_init", mrb_Git_git_submodule_init, MRB_ARGS_ARG(git_submodule_init_REQUIRED_ARGC, git_submodule_init_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_location_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_location", mrb_Git_git_submodule_location, MRB_ARGS_ARG(git_submodule_location_REQUIRED_ARGC, git_submodule_location_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_lookup", mrb_Git_git_submodule_lookup, MRB_ARGS_ARG(git_submodule_lookup_REQUIRED_ARGC, git_submodule_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_name", mrb_Git_git_submodule_name, MRB_ARGS_ARG(git_submodule_name_REQUIRED_ARGC, git_submodule_name_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_open_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_open", mrb_Git_git_submodule_open, MRB_ARGS_ARG(git_submodule_open_REQUIRED_ARGC, git_submodule_open_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_owner", mrb_Git_git_submodule_owner, MRB_ARGS_ARG(git_submodule_owner_REQUIRED_ARGC, git_submodule_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_path_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_path", mrb_Git_git_submodule_path, MRB_ARGS_ARG(git_submodule_path_REQUIRED_ARGC, git_submodule_path_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_reload_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_reload", mrb_Git_git_submodule_reload, MRB_ARGS_ARG(git_submodule_reload_REQUIRED_ARGC, git_submodule_reload_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_repo_init_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_repo_init", mrb_Git_git_submodule_repo_init, MRB_ARGS_ARG(git_submodule_repo_init_REQUIRED_ARGC, git_submodule_repo_init_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_resolve_url_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_resolve_url", mrb_Git_git_submodule_resolve_url, MRB_ARGS_ARG(git_submodule_resolve_url_REQUIRED_ARGC, git_submodule_resolve_url_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_set_branch_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_set_branch", mrb_Git_git_submodule_set_branch, MRB_ARGS_ARG(git_submodule_set_branch_REQUIRED_ARGC, git_submodule_set_branch_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_set_fetch_recurse_submodules_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_set_fetch_recurse_submodules", mrb_Git_git_submodule_set_fetch_recurse_submodules, MRB_ARGS_ARG(git_submodule_set_fetch_recurse_submodules_REQUIRED_ARGC, git_submodule_set_fetch_recurse_submodules_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_set_ignore_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_set_ignore", mrb_Git_git_submodule_set_ignore, MRB_ARGS_ARG(git_submodule_set_ignore_REQUIRED_ARGC, git_submodule_set_ignore_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_set_update_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_set_update", mrb_Git_git_submodule_set_update, MRB_ARGS_ARG(git_submodule_set_update_REQUIRED_ARGC, git_submodule_set_update_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_set_url_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_set_url", mrb_Git_git_submodule_set_url, MRB_ARGS_ARG(git_submodule_set_url_REQUIRED_ARGC, git_submodule_set_url_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_status_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_status", mrb_Git_git_submodule_status, MRB_ARGS_ARG(git_submodule_status_REQUIRED_ARGC, git_submodule_status_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_sync_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_sync", mrb_Git_git_submodule_sync, MRB_ARGS_ARG(git_submodule_sync_REQUIRED_ARGC, git_submodule_sync_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_update_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_update", mrb_Git_git_submodule_update, MRB_ARGS_ARG(git_submodule_update_REQUIRED_ARGC, git_submodule_update_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_update_init_options_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_update_init_options", mrb_Git_git_submodule_update_init_options, MRB_ARGS_ARG(git_submodule_update_init_options_REQUIRED_ARGC, git_submodule_update_init_options_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_update_strategy_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_update_strategy", mrb_Git_git_submodule_update_strategy, MRB_ARGS_ARG(git_submodule_update_strategy_REQUIRED_ARGC, git_submodule_update_strategy_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_url_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_url", mrb_Git_git_submodule_url, MRB_ARGS_ARG(git_submodule_url_REQUIRED_ARGC, git_submodule_url_OPTIONAL_ARGC));
#endif
#if BIND_git_submodule_wd_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "submodule_wd_id", mrb_Git_git_submodule_wd_id, MRB_ARGS_ARG(git_submodule_wd_id_REQUIRED_ARGC, git_submodule_wd_id_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_annotation_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_annotation_create", mrb_Git_git_tag_annotation_create, MRB_ARGS_ARG(git_tag_annotation_create_REQUIRED_ARGC, git_tag_annotation_create_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_create_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_create", mrb_Git_git_tag_create, MRB_ARGS_ARG(git_tag_create_REQUIRED_ARGC, git_tag_create_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_create_frombuffer_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_create_frombuffer", mrb_Git_git_tag_create_frombuffer, MRB_ARGS_ARG(git_tag_create_frombuffer_REQUIRED_ARGC, git_tag_create_frombuffer_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_create_lightweight_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_create_lightweight", mrb_Git_git_tag_create_lightweight, MRB_ARGS_ARG(git_tag_create_lightweight_REQUIRED_ARGC, git_tag_create_lightweight_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_delete_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_delete", mrb_Git_git_tag_delete, MRB_ARGS_ARG(git_tag_delete_REQUIRED_ARGC, git_tag_delete_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_foreach_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_foreach", mrb_Git_git_tag_foreach, MRB_ARGS_ARG(git_tag_foreach_REQUIRED_ARGC, git_tag_foreach_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_free", mrb_Git_git_tag_free, MRB_ARGS_ARG(git_tag_free_REQUIRED_ARGC, git_tag_free_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_id", mrb_Git_git_tag_id, MRB_ARGS_ARG(git_tag_id_REQUIRED_ARGC, git_tag_id_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_list_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_list", mrb_Git_git_tag_list, MRB_ARGS_ARG(git_tag_list_REQUIRED_ARGC, git_tag_list_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_list_match_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_list_match", mrb_Git_git_tag_list_match, MRB_ARGS_ARG(git_tag_list_match_REQUIRED_ARGC, git_tag_list_match_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_lookup", mrb_Git_git_tag_lookup, MRB_ARGS_ARG(git_tag_lookup_REQUIRED_ARGC, git_tag_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_lookup_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_lookup_prefix", mrb_Git_git_tag_lookup_prefix, MRB_ARGS_ARG(git_tag_lookup_prefix_REQUIRED_ARGC, git_tag_lookup_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_message_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_message", mrb_Git_git_tag_message, MRB_ARGS_ARG(git_tag_message_REQUIRED_ARGC, git_tag_message_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_name", mrb_Git_git_tag_name, MRB_ARGS_ARG(git_tag_name_REQUIRED_ARGC, git_tag_name_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_owner", mrb_Git_git_tag_owner, MRB_ARGS_ARG(git_tag_owner_REQUIRED_ARGC, git_tag_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_peel_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_peel", mrb_Git_git_tag_peel, MRB_ARGS_ARG(git_tag_peel_REQUIRED_ARGC, git_tag_peel_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_tagger_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_tagger", mrb_Git_git_tag_tagger, MRB_ARGS_ARG(git_tag_tagger_REQUIRED_ARGC, git_tag_tagger_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_target_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_target", mrb_Git_git_tag_target, MRB_ARGS_ARG(git_tag_target_REQUIRED_ARGC, git_tag_target_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_target_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_target_id", mrb_Git_git_tag_target_id, MRB_ARGS_ARG(git_tag_target_id_REQUIRED_ARGC, git_tag_target_id_OPTIONAL_ARGC));
#endif
#if BIND_git_tag_target_type_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tag_target_type", mrb_Git_git_tag_target_type, MRB_ARGS_ARG(git_tag_target_type_REQUIRED_ARGC, git_tag_target_type_OPTIONAL_ARGC));
#endif
#if BIND_git_trace_set_FUNCTION
  mrb_define_class_method(mrb, Git_module, "trace_set", mrb_Git_git_trace_set, MRB_ARGS_ARG(git_trace_set_REQUIRED_ARGC, git_trace_set_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_commit_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_commit", mrb_Git_git_transaction_commit, MRB_ARGS_ARG(git_transaction_commit_REQUIRED_ARGC, git_transaction_commit_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_free", mrb_Git_git_transaction_free, MRB_ARGS_ARG(git_transaction_free_REQUIRED_ARGC, git_transaction_free_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_lock_ref_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_lock_ref", mrb_Git_git_transaction_lock_ref, MRB_ARGS_ARG(git_transaction_lock_ref_REQUIRED_ARGC, git_transaction_lock_ref_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_new", mrb_Git_git_transaction_new, MRB_ARGS_ARG(git_transaction_new_REQUIRED_ARGC, git_transaction_new_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_remove_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_remove", mrb_Git_git_transaction_remove, MRB_ARGS_ARG(git_transaction_remove_REQUIRED_ARGC, git_transaction_remove_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_set_reflog_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_set_reflog", mrb_Git_git_transaction_set_reflog, MRB_ARGS_ARG(git_transaction_set_reflog_REQUIRED_ARGC, git_transaction_set_reflog_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_set_symbolic_target_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_set_symbolic_target", mrb_Git_git_transaction_set_symbolic_target, MRB_ARGS_ARG(git_transaction_set_symbolic_target_REQUIRED_ARGC, git_transaction_set_symbolic_target_OPTIONAL_ARGC));
#endif
#if BIND_git_transaction_set_target_FUNCTION
  mrb_define_class_method(mrb, Git_module, "transaction_set_target", mrb_Git_git_transaction_set_target, MRB_ARGS_ARG(git_transaction_set_target_REQUIRED_ARGC, git_transaction_set_target_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_byid_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_byid", mrb_Git_git_tree_entry_byid, MRB_ARGS_ARG(git_tree_entry_byid_REQUIRED_ARGC, git_tree_entry_byid_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_byindex_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_byindex", mrb_Git_git_tree_entry_byindex, MRB_ARGS_ARG(git_tree_entry_byindex_REQUIRED_ARGC, git_tree_entry_byindex_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_byname_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_byname", mrb_Git_git_tree_entry_byname, MRB_ARGS_ARG(git_tree_entry_byname_REQUIRED_ARGC, git_tree_entry_byname_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_bypath_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_bypath", mrb_Git_git_tree_entry_bypath, MRB_ARGS_ARG(git_tree_entry_bypath_REQUIRED_ARGC, git_tree_entry_bypath_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_cmp_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_cmp", mrb_Git_git_tree_entry_cmp, MRB_ARGS_ARG(git_tree_entry_cmp_REQUIRED_ARGC, git_tree_entry_cmp_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_dup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_dup", mrb_Git_git_tree_entry_dup, MRB_ARGS_ARG(git_tree_entry_dup_REQUIRED_ARGC, git_tree_entry_dup_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_filemode_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_filemode", mrb_Git_git_tree_entry_filemode, MRB_ARGS_ARG(git_tree_entry_filemode_REQUIRED_ARGC, git_tree_entry_filemode_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_filemode_raw_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_filemode_raw", mrb_Git_git_tree_entry_filemode_raw, MRB_ARGS_ARG(git_tree_entry_filemode_raw_REQUIRED_ARGC, git_tree_entry_filemode_raw_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_free", mrb_Git_git_tree_entry_free, MRB_ARGS_ARG(git_tree_entry_free_REQUIRED_ARGC, git_tree_entry_free_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_id", mrb_Git_git_tree_entry_id, MRB_ARGS_ARG(git_tree_entry_id_REQUIRED_ARGC, git_tree_entry_id_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_name_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_name", mrb_Git_git_tree_entry_name, MRB_ARGS_ARG(git_tree_entry_name_REQUIRED_ARGC, git_tree_entry_name_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_to_object_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_to_object", mrb_Git_git_tree_entry_to_object, MRB_ARGS_ARG(git_tree_entry_to_object_REQUIRED_ARGC, git_tree_entry_to_object_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entry_type_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entry_type", mrb_Git_git_tree_entry_type, MRB_ARGS_ARG(git_tree_entry_type_REQUIRED_ARGC, git_tree_entry_type_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_entrycount", mrb_Git_git_tree_entrycount, MRB_ARGS_ARG(git_tree_entrycount_REQUIRED_ARGC, git_tree_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_free", mrb_Git_git_tree_free, MRB_ARGS_ARG(git_tree_free_REQUIRED_ARGC, git_tree_free_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_id_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_id", mrb_Git_git_tree_id, MRB_ARGS_ARG(git_tree_id_REQUIRED_ARGC, git_tree_id_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_lookup_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_lookup", mrb_Git_git_tree_lookup, MRB_ARGS_ARG(git_tree_lookup_REQUIRED_ARGC, git_tree_lookup_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_lookup_prefix_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_lookup_prefix", mrb_Git_git_tree_lookup_prefix, MRB_ARGS_ARG(git_tree_lookup_prefix_REQUIRED_ARGC, git_tree_lookup_prefix_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_owner_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_owner", mrb_Git_git_tree_owner, MRB_ARGS_ARG(git_tree_owner_REQUIRED_ARGC, git_tree_owner_OPTIONAL_ARGC));
#endif
#if BIND_git_tree_walk_FUNCTION
  mrb_define_class_method(mrb, Git_module, "tree_walk", mrb_Git_git_tree_walk, MRB_ARGS_ARG(git_tree_walk_REQUIRED_ARGC, git_tree_walk_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_clear_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_clear", mrb_Git_git_treebuilder_clear, MRB_ARGS_ARG(git_treebuilder_clear_REQUIRED_ARGC, git_treebuilder_clear_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_entrycount_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_entrycount", mrb_Git_git_treebuilder_entrycount, MRB_ARGS_ARG(git_treebuilder_entrycount_REQUIRED_ARGC, git_treebuilder_entrycount_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_filter_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_filter", mrb_Git_git_treebuilder_filter, MRB_ARGS_ARG(git_treebuilder_filter_REQUIRED_ARGC, git_treebuilder_filter_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_free_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_free", mrb_Git_git_treebuilder_free, MRB_ARGS_ARG(git_treebuilder_free_REQUIRED_ARGC, git_treebuilder_free_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_get_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_get", mrb_Git_git_treebuilder_get, MRB_ARGS_ARG(git_treebuilder_get_REQUIRED_ARGC, git_treebuilder_get_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_insert_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_insert", mrb_Git_git_treebuilder_insert, MRB_ARGS_ARG(git_treebuilder_insert_REQUIRED_ARGC, git_treebuilder_insert_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_new_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_new", mrb_Git_git_treebuilder_new, MRB_ARGS_ARG(git_treebuilder_new_REQUIRED_ARGC, git_treebuilder_new_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_remove_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_remove", mrb_Git_git_treebuilder_remove, MRB_ARGS_ARG(git_treebuilder_remove_REQUIRED_ARGC, git_treebuilder_remove_OPTIONAL_ARGC));
#endif
#if BIND_git_treebuilder_write_FUNCTION
  mrb_define_class_method(mrb, Git_module, "treebuilder_write", mrb_Git_git_treebuilder_write, MRB_ARGS_ARG(git_treebuilder_write_REQUIRED_ARGC, git_treebuilder_write_OPTIONAL_ARGC));
#endif
#if BIND_giterr_clear_FUNCTION
  mrb_define_class_method(mrb, Git_module, "err_clear", mrb_Git_giterr_clear, MRB_ARGS_ARG(giterr_clear_REQUIRED_ARGC, giterr_clear_OPTIONAL_ARGC));
#endif
#if BIND_giterr_last_FUNCTION
  mrb_define_class_method(mrb, Git_module, "err_last", mrb_Git_giterr_last, MRB_ARGS_ARG(giterr_last_REQUIRED_ARGC, giterr_last_OPTIONAL_ARGC));
#endif
#if BIND_giterr_set_oom_FUNCTION
  mrb_define_class_method(mrb, Git_module, "err_set_oom", mrb_Git_giterr_set_oom, MRB_ARGS_ARG(giterr_set_oom_REQUIRED_ARGC, giterr_set_oom_OPTIONAL_ARGC));
#endif
#if BIND_giterr_set_str_FUNCTION
  mrb_define_class_method(mrb, Git_module, "err_set_str", mrb_Git_giterr_set_str, MRB_ARGS_ARG(giterr_set_str_REQUIRED_ARGC, giterr_set_str_OPTIONAL_ARGC));
#endif
#if BIND_imaxdiv_FUNCTION
  mrb_define_class_method(mrb, Git_module, "imaxdiv", mrb_Git_imaxdiv, MRB_ARGS_ARG(imaxdiv_REQUIRED_ARGC, imaxdiv_OPTIONAL_ARGC));
#endif
/* MRUBY_BINDING_END */

/* MRUBY_BINDING: post_module_definition */
/* sha: user_defined */

/* MRUBY_BINDING_END */
}

void mrb_mruby_git_gem_final(mrb_state* mrb){
/* MRUBY_BINDING: module_final */
/* sha: user_defined */
  // XXX Segfaulting on Mac.... come back to this
  // git_libgit2_shutdown();
/* MRUBY_BINDING_END */
}

/* MRUBY_BINDING: footer */
/* sha: user_defined */

/* MRUBY_BINDING_END */

#ifdef __cplusplus
}
#endif
